/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}

impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self {
            storage,
            align: [],
        }
    }

    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];

        let bit_index = index % 8;
        let mask = 1 << bit_index;

        byte & mask == mask
    }

    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];

        let bit_index = index % 8;
        let mask = 1 << bit_index;

        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }

    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        let mut val = 0;

        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                val |= 1 << i;
            }
        }

        val
    }

    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            self.set_bit(i + bit_offset, val_bit_is_set);
        }
    }
}
 pub const MMAL_FALSE : :: std :: os :: raw :: c_uint = 0 ; pub const MMAL_TRUE : :: std :: os :: raw :: c_uint = 1 ; pub const MMAL_ENCODING_VARIANT_H264_DEFAULT : :: std :: os :: raw :: c_uint = 0 ; pub const MMAL_ENCODING_VARIANT_MP4A_DEFAULT : :: std :: os :: raw :: c_uint = 0 ; pub const MMAL_COLOR_SPACE_UNKNOWN : :: std :: os :: raw :: c_uint = 0 ; pub const MMAL_ES_FORMAT_FLAG_FRAMED : :: std :: os :: raw :: c_uint = 1 ; pub const MMAL_ENCODING_UNKNOWN : :: std :: os :: raw :: c_uint = 0 ; pub const MMAL_ENCODING_VARIANT_DEFAULT : :: std :: os :: raw :: c_uint = 0 ; pub const MMAL_ES_FORMAT_COMPARE_FLAG_TYPE : :: std :: os :: raw :: c_uint = 1 ; pub const MMAL_ES_FORMAT_COMPARE_FLAG_ENCODING : :: std :: os :: raw :: c_uint = 2 ; pub const MMAL_ES_FORMAT_COMPARE_FLAG_BITRATE : :: std :: os :: raw :: c_uint = 4 ; pub const MMAL_ES_FORMAT_COMPARE_FLAG_FLAGS : :: std :: os :: raw :: c_uint = 8 ; pub const MMAL_ES_FORMAT_COMPARE_FLAG_EXTRADATA : :: std :: os :: raw :: c_uint = 16 ; pub const MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_RESOLUTION : :: std :: os :: raw :: c_uint = 256 ; pub const MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_CROPPING : :: std :: os :: raw :: c_uint = 512 ; pub const MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_FRAME_RATE : :: std :: os :: raw :: c_uint = 1024 ; pub const MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_ASPECT_RATIO : :: std :: os :: raw :: c_uint = 2048 ; pub const MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_COLOR_SPACE : :: std :: os :: raw :: c_uint = 4096 ; pub const MMAL_ES_FORMAT_COMPARE_FLAG_ES_OTHER : :: std :: os :: raw :: c_uint = 268435456 ; pub const MMAL_BUFFER_HEADER_FLAG_EOS : :: std :: os :: raw :: c_uint = 1 ; pub const MMAL_BUFFER_HEADER_FLAG_FRAME_START : :: std :: os :: raw :: c_uint = 2 ; pub const MMAL_BUFFER_HEADER_FLAG_FRAME_END : :: std :: os :: raw :: c_uint = 4 ; pub const MMAL_BUFFER_HEADER_FLAG_FRAME : :: std :: os :: raw :: c_uint = 6 ; pub const MMAL_BUFFER_HEADER_FLAG_KEYFRAME : :: std :: os :: raw :: c_uint = 8 ; pub const MMAL_BUFFER_HEADER_FLAG_DISCONTINUITY : :: std :: os :: raw :: c_uint = 16 ; pub const MMAL_BUFFER_HEADER_FLAG_CONFIG : :: std :: os :: raw :: c_uint = 32 ; pub const MMAL_BUFFER_HEADER_FLAG_ENCRYPTED : :: std :: os :: raw :: c_uint = 64 ; pub const MMAL_BUFFER_HEADER_FLAG_CODECSIDEINFO : :: std :: os :: raw :: c_uint = 128 ; pub const MMAL_BUFFER_HEADER_FLAGS_SNAPSHOT : :: std :: os :: raw :: c_uint = 256 ; pub const MMAL_BUFFER_HEADER_FLAG_CORRUPTED : :: std :: os :: raw :: c_uint = 512 ; pub const MMAL_BUFFER_HEADER_FLAG_TRANSMISSION_FAILED : :: std :: os :: raw :: c_uint = 1024 ; pub const MMAL_BUFFER_HEADER_FLAG_DECODEONLY : :: std :: os :: raw :: c_uint = 2048 ; pub const MMAL_BUFFER_HEADER_FLAG_NAL_END : :: std :: os :: raw :: c_uint = 4096 ; pub const MMAL_BUFFER_HEADER_FLAG_USER0 : :: std :: os :: raw :: c_uint = 268435456 ; pub const MMAL_BUFFER_HEADER_FLAG_USER1 : :: std :: os :: raw :: c_uint = 536870912 ; pub const MMAL_BUFFER_HEADER_FLAG_USER2 : :: std :: os :: raw :: c_uint = 1073741824 ; pub const MMAL_BUFFER_HEADER_FLAG_USER3 : :: std :: os :: raw :: c_uint = 2147483648 ; pub const MMAL_BUFFER_HEADER_FLAG_FORMAT_SPECIFIC_START : :: std :: os :: raw :: c_uint = 65536 ; pub const MMAL_BUFFER_HEADER_VIDEO_FLAG_INTERLACED : :: std :: os :: raw :: c_uint = 65536 ; pub const MMAL_BUFFER_HEADER_VIDEO_FLAG_TOP_FIELD_FIRST : :: std :: os :: raw :: c_uint = 131072 ; pub const MMAL_BUFFER_HEADER_VIDEO_FLAG_DISPLAY_EXTERNAL : :: std :: os :: raw :: c_uint = 524288 ; pub const MMAL_BUFFER_HEADER_VIDEO_FLAG_PROTECTED : :: std :: os :: raw :: c_uint = 1048576 ; pub const MMAL_PARAMETER_GROUP_COMMON : :: std :: os :: raw :: c_uint = 0 ; pub const MMAL_PARAMETER_GROUP_CAMERA : :: std :: os :: raw :: c_uint = 65536 ; pub const MMAL_PARAMETER_GROUP_VIDEO : :: std :: os :: raw :: c_uint = 131072 ; pub const MMAL_PARAMETER_GROUP_AUDIO : :: std :: os :: raw :: c_uint = 196608 ; pub const MMAL_PARAMETER_GROUP_CLOCK : :: std :: os :: raw :: c_uint = 262144 ; pub const MMAL_PARAMETER_GROUP_MIRACAST : :: std :: os :: raw :: c_uint = 327680 ; pub const MMAL_PARAM_SEEK_FLAG_PRECISE : :: std :: os :: raw :: c_uint = 1 ; pub const MMAL_PARAM_SEEK_FLAG_FORWARD : :: std :: os :: raw :: c_uint = 2 ; pub const MMAL_MAX_IMAGEFX_PARAMETERS : :: std :: os :: raw :: c_uint = 6 ; pub const MMAL_PARAMETER_CAMERA_INFO_MAX_CAMERAS : :: std :: os :: raw :: c_uint = 4 ; pub const MMAL_PARAMETER_CAMERA_INFO_MAX_FLASHES : :: std :: os :: raw :: c_uint = 2 ; pub const MMAL_PARAMETER_CAMERA_INFO_MAX_STR_LEN : :: std :: os :: raw :: c_uint = 16 ; pub const MMAL_CAMERA_ANNOTATE_MAX_TEXT_LEN : :: std :: os :: raw :: c_uint = 32 ; pub const MMAL_CAMERA_ANNOTATE_MAX_TEXT_LEN_V2 : :: std :: os :: raw :: c_uint = 256 ; pub const MMAL_CAMERA_ANNOTATE_MAX_TEXT_LEN_V3 : :: std :: os :: raw :: c_uint = 256 ; pub const MMAL_CLOCK_EVENT_INVALID : :: std :: os :: raw :: c_uint = 0 ; pub const MMAL_FIXED_16_16_ONE : :: std :: os :: raw :: c_uint = 65536 ; pub const MMAL_PORT_CAPABILITY_PASSTHROUGH : :: std :: os :: raw :: c_uint = 1 ; pub const MMAL_PORT_CAPABILITY_ALLOCATION : :: std :: os :: raw :: c_uint = 2 ; pub const MMAL_PORT_CAPABILITY_SUPPORTS_EVENT_FORMAT_CHANGE : :: std :: os :: raw :: c_uint = 4 ; pub const MMAL_VERSION_MAJOR : :: std :: os :: raw :: c_uint = 0 ; pub const MMAL_VERSION_MINOR : :: std :: os :: raw :: c_uint = 1 ; pub const MMAL_VERSION : :: std :: os :: raw :: c_uint = 1 ; pub const MMAL_COMPONENT_DEFAULT_CONTAINER_READER : & 'static [ u8 ; 17usize ] = b"container_reader\0" ; pub const MMAL_COMPONENT_DEFAULT_CONTAINER_WRITER : & 'static [ u8 ; 17usize ] = b"container_writer\0" ; pub const MMAL_COMPONENT_DEFAULT_VIDEO_DECODER : & 'static [ u8 ; 20usize ] = b"vc.ril.video_decode\0" ; pub const MMAL_COMPONENT_DEFAULT_VIDEO_ENCODER : & 'static [ u8 ; 20usize ] = b"vc.ril.video_encode\0" ; pub const MMAL_COMPONENT_DEFAULT_VIDEO_RENDERER : & 'static [ u8 ; 20usize ] = b"vc.ril.video_render\0" ; pub const MMAL_COMPONENT_DEFAULT_IMAGE_DECODER : & 'static [ u8 ; 20usize ] = b"vc.ril.image_decode\0" ; pub const MMAL_COMPONENT_DEFAULT_IMAGE_ENCODER : & 'static [ u8 ; 20usize ] = b"vc.ril.image_encode\0" ; pub const MMAL_COMPONENT_DEFAULT_CAMERA : & 'static [ u8 ; 14usize ] = b"vc.ril.camera\0" ; pub const MMAL_COMPONENT_DEFAULT_VIDEO_CONVERTER : & 'static [ u8 ; 17usize ] = b"vc.video_convert\0" ; pub const MMAL_COMPONENT_DEFAULT_SPLITTER : & 'static [ u8 ; 12usize ] = b"vc.splitter\0" ; pub const MMAL_COMPONENT_DEFAULT_SCHEDULER : & 'static [ u8 ; 13usize ] = b"vc.scheduler\0" ; pub const MMAL_COMPONENT_DEFAULT_VIDEO_INJECTER : & 'static [ u8 ; 16usize ] = b"vc.video_inject\0" ; pub const MMAL_COMPONENT_DEFAULT_VIDEO_SPLITTER : & 'static [ u8 ; 22usize ] = b"vc.ril.video_splitter\0" ; pub const MMAL_COMPONENT_DEFAULT_AUDIO_DECODER : & 'static [ u8 ; 5usize ] = b"none\0" ; pub const MMAL_COMPONENT_DEFAULT_AUDIO_RENDERER : & 'static [ u8 ; 20usize ] = b"vc.ril.audio_render\0" ; pub const MMAL_COMPONENT_DEFAULT_MIRACAST : & 'static [ u8 ; 12usize ] = b"vc.miracast\0" ; pub const MMAL_COMPONENT_DEFAULT_CLOCK : & 'static [ u8 ; 9usize ] = b"vc.clock\0" ; pub const MMAL_COMPONENT_DEFAULT_CAMERA_INFO : & 'static [ u8 ; 15usize ] = b"vc.camera_info\0" ; pub const MMAL_CONNECTION_FLAG_TUNNELLING : :: std :: os :: raw :: c_uint = 1 ; pub const MMAL_CONNECTION_FLAG_ALLOCATION_ON_INPUT : :: std :: os :: raw :: c_uint = 2 ; pub const MMAL_CONNECTION_FLAG_ALLOCATION_ON_OUTPUT : :: std :: os :: raw :: c_uint = 4 ; pub const MMAL_CONNECTION_FLAG_KEEP_BUFFER_REQUIREMENTS : :: std :: os :: raw :: c_uint = 8 ; pub const MMAL_CONNECTION_FLAG_DIRECT : :: std :: os :: raw :: c_uint = 16 ; pub const MMAL_DEV_VCHIQ_PATH : & 'static [ u8 ; 11usize ] = b"/dev/vchiq\0" ; pub type __uint8_t = :: std :: os :: raw :: c_uchar ; pub type __uint16_t = :: std :: os :: raw :: c_ushort ; pub type __int32_t = :: std :: os :: raw :: c_int ; pub type __uint32_t = :: std :: os :: raw :: c_uint ; pub type __int64_t = :: std :: os :: raw :: c_long ; pub type __uint64_t = :: std :: os :: raw :: c_ulong ; pub type __time_t = :: std :: os :: raw :: c_long ; pub type __syscall_slong_t = :: std :: os :: raw :: c_long ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct timespec { pub tv_sec : __time_t , pub tv_nsec : __syscall_slong_t , } # [ test ] fn bindgen_test_layout_timespec ( ) { assert_eq ! ( :: std :: mem :: size_of :: < timespec > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( timespec ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < timespec > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( timespec ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < timespec > ( ) ) ) . tv_sec as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( timespec ) , "::" , stringify ! ( tv_sec ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < timespec > ( ) ) ) . tv_nsec as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( timespec ) , "::" , stringify ! ( tv_nsec ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_internal_list { pub __prev : * mut __pthread_internal_list , pub __next : * mut __pthread_internal_list , } # [ test ] fn bindgen_test_layout___pthread_internal_list ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_internal_list > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( __pthread_internal_list ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_internal_list > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_internal_list ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_internal_list > ( ) ) ) . __prev as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_internal_list ) , "::" , stringify ! ( __prev ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_internal_list > ( ) ) ) . __next as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_internal_list ) , "::" , stringify ! ( __next ) ) ) ; } pub type __pthread_list_t = __pthread_internal_list ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_mutex_s { pub __lock : :: std :: os :: raw :: c_int , pub __count : :: std :: os :: raw :: c_uint , pub __owner : :: std :: os :: raw :: c_int , pub __nusers : :: std :: os :: raw :: c_uint , pub __kind : :: std :: os :: raw :: c_int , pub __spins : :: std :: os :: raw :: c_short , pub __elision : :: std :: os :: raw :: c_short , pub __list : __pthread_list_t , } # [ test ] fn bindgen_test_layout___pthread_mutex_s ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_mutex_s > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( __pthread_mutex_s ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_mutex_s > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_mutex_s ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_mutex_s > ( ) ) ) . __lock as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_mutex_s ) , "::" , stringify ! ( __lock ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_mutex_s > ( ) ) ) . __count as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_mutex_s ) , "::" , stringify ! ( __count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_mutex_s > ( ) ) ) . __owner as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_mutex_s ) , "::" , stringify ! ( __owner ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_mutex_s > ( ) ) ) . __nusers as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_mutex_s ) , "::" , stringify ! ( __nusers ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_mutex_s > ( ) ) ) . __kind as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_mutex_s ) , "::" , stringify ! ( __kind ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_mutex_s > ( ) ) ) . __spins as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_mutex_s ) , "::" , stringify ! ( __spins ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_mutex_s > ( ) ) ) . __elision as * const _ as usize } , 22usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_mutex_s ) , "::" , stringify ! ( __elision ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_mutex_s > ( ) ) ) . __list as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_mutex_s ) , "::" , stringify ! ( __list ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct __pthread_cond_s { pub __bindgen_anon_1 : __pthread_cond_s__bindgen_ty_1 , pub __bindgen_anon_2 : __pthread_cond_s__bindgen_ty_2 , pub __g_refs : [ :: std :: os :: raw :: c_uint ; 2usize ] , pub __g_size : [ :: std :: os :: raw :: c_uint ; 2usize ] , pub __g1_orig_size : :: std :: os :: raw :: c_uint , pub __wrefs : :: std :: os :: raw :: c_uint , pub __g_signals : [ :: std :: os :: raw :: c_uint ; 2usize ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union __pthread_cond_s__bindgen_ty_1 { pub __wseq : :: std :: os :: raw :: c_ulonglong , pub __wseq32 : __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 , _bindgen_union_align : u64 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 { pub __low : :: std :: os :: raw :: c_uint , pub __high : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . __low as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( __low ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . __high as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( __high ) ) ) ; } # [ test ] fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_cond_s__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __pthread_cond_s__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_cond_s__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_cond_s__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cond_s__bindgen_ty_1 > ( ) ) ) . __wseq as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cond_s__bindgen_ty_1 ) , "::" , stringify ! ( __wseq ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cond_s__bindgen_ty_1 > ( ) ) ) . __wseq32 as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cond_s__bindgen_ty_1 ) , "::" , stringify ! ( __wseq32 ) ) ) ; } impl :: std :: fmt :: Debug for __pthread_cond_s__bindgen_ty_1 { fn fmt ( & self , f : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { write ! ( f , "__pthread_cond_s__bindgen_ty_1 {{ union }}" ) } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union __pthread_cond_s__bindgen_ty_2 { pub __g1_start : :: std :: os :: raw :: c_ulonglong , pub __g1_start32 : __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 , _bindgen_union_align : u64 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 { pub __low : :: std :: os :: raw :: c_uint , pub __high : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 > ( ) ) ) . __low as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! ( __low ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 > ( ) ) ) . __high as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! ( __high ) ) ) ; } # [ test ] fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_cond_s__bindgen_ty_2 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __pthread_cond_s__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_cond_s__bindgen_ty_2 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_cond_s__bindgen_ty_2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cond_s__bindgen_ty_2 > ( ) ) ) . __g1_start as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cond_s__bindgen_ty_2 ) , "::" , stringify ! ( __g1_start ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cond_s__bindgen_ty_2 > ( ) ) ) . __g1_start32 as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cond_s__bindgen_ty_2 ) , "::" , stringify ! ( __g1_start32 ) ) ) ; } impl :: std :: fmt :: Debug for __pthread_cond_s__bindgen_ty_2 { fn fmt ( & self , f : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { write ! ( f , "__pthread_cond_s__bindgen_ty_2 {{ union }}" ) } } # [ test ] fn bindgen_test_layout___pthread_cond_s ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_cond_s > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( __pthread_cond_s ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_cond_s > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_cond_s ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cond_s > ( ) ) ) . __g_refs as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cond_s ) , "::" , stringify ! ( __g_refs ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cond_s > ( ) ) ) . __g_size as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cond_s ) , "::" , stringify ! ( __g_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cond_s > ( ) ) ) . __g1_orig_size as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cond_s ) , "::" , stringify ! ( __g1_orig_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cond_s > ( ) ) ) . __wrefs as * const _ as usize } , 36usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cond_s ) , "::" , stringify ! ( __wrefs ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cond_s > ( ) ) ) . __g_signals as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cond_s ) , "::" , stringify ! ( __g_signals ) ) ) ; } impl :: std :: fmt :: Debug for __pthread_cond_s { fn fmt ( & self , f : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { write ! ( f , "__pthread_cond_s {{ __bindgen_anon_1: {:?}, __bindgen_anon_2: {:?}, __g_refs: {:?}, __g_size: {:?}, __g1_orig_size: {:?}, __wrefs: {:?}, __g_signals: {:?} }}" , self . __bindgen_anon_1 , self . __bindgen_anon_2 , self . __g_refs , self . __g_size , self . __g1_orig_size , self . __wrefs , self . __g_signals ) } } pub type pthread_t = :: std :: os :: raw :: c_ulong ; pub type pthread_once_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_mutex_t { pub __data : __pthread_mutex_s , pub __size : [ :: std :: os :: raw :: c_char ; 40usize ] , pub __align : :: std :: os :: raw :: c_long , _bindgen_union_align : [ u64 ; 5usize ] , } # [ test ] fn bindgen_test_layout_pthread_mutex_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_mutex_t > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( pthread_mutex_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_mutex_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_mutex_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_mutex_t > ( ) ) ) . __data as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutex_t ) , "::" , stringify ! ( __data ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_mutex_t > ( ) ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutex_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_mutex_t > ( ) ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutex_t ) , "::" , stringify ! ( __align ) ) ) ; } impl :: std :: fmt :: Debug for pthread_mutex_t { fn fmt ( & self , f : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { write ! ( f , "pthread_mutex_t {{ union }}" ) } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_cond_t { pub __data : __pthread_cond_s , pub __size : [ :: std :: os :: raw :: c_char ; 48usize ] , pub __align : :: std :: os :: raw :: c_longlong , _bindgen_union_align : [ u64 ; 6usize ] , } # [ test ] fn bindgen_test_layout_pthread_cond_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_cond_t > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( pthread_cond_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_cond_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_cond_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_cond_t > ( ) ) ) . __data as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_cond_t ) , "::" , stringify ! ( __data ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_cond_t > ( ) ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_cond_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_cond_t > ( ) ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_cond_t ) , "::" , stringify ! ( __align ) ) ) ; } impl :: std :: fmt :: Debug for pthread_cond_t { fn fmt ( & self , f : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { write ! ( f , "pthread_cond_t {{ union }}" ) } } extern "C" { pub fn vcos_pthreads_logging_assert ( file : * const :: std :: os :: raw :: c_char , func : * const :: std :: os :: raw :: c_char , line : :: std :: os :: raw :: c_uint , fmt : * const :: std :: os :: raw :: c_char , ... ) ; } /// Thread entry point. Returns a void* for consistency
/// with pthreads.
 pub type VCOS_THREAD_ENTRY_FN_T = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut :: std :: os :: raw :: c_void ) -> * mut :: std :: os :: raw :: c_void > ; pub const VCOS_STATUS_T_VCOS_SUCCESS : VCOS_STATUS_T = 0 ; pub const VCOS_STATUS_T_VCOS_EAGAIN : VCOS_STATUS_T = 1 ; pub const VCOS_STATUS_T_VCOS_ENOENT : VCOS_STATUS_T = 2 ; pub const VCOS_STATUS_T_VCOS_ENOSPC : VCOS_STATUS_T = 3 ; pub const VCOS_STATUS_T_VCOS_EINVAL : VCOS_STATUS_T = 4 ; pub const VCOS_STATUS_T_VCOS_EACCESS : VCOS_STATUS_T = 5 ; pub const VCOS_STATUS_T_VCOS_ENOMEM : VCOS_STATUS_T = 6 ; pub const VCOS_STATUS_T_VCOS_ENOSYS : VCOS_STATUS_T = 7 ; pub const VCOS_STATUS_T_VCOS_EEXIST : VCOS_STATUS_T = 8 ; pub const VCOS_STATUS_T_VCOS_ENXIO : VCOS_STATUS_T = 9 ; pub const VCOS_STATUS_T_VCOS_EINTR : VCOS_STATUS_T = 10 ; pub type VCOS_STATUS_T = u32 ; extern "C" { pub fn vcos_verify_bkpts_enabled ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vcos_verify_bkpts_enable ( enable : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vcos_abort ( ) ; } extern "C" { /// Print out a backtrace, on supported platforms.
 pub fn vcos_backtrace_self ( ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union sem_t { pub __size : [ :: std :: os :: raw :: c_char ; 32usize ] , pub __align : :: std :: os :: raw :: c_long , _bindgen_union_align : [ u64 ; 4usize ] , } # [ test ] fn bindgen_test_layout_sem_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sem_t > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( sem_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sem_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sem_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < sem_t > ( ) ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( sem_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < sem_t > ( ) ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( sem_t ) , "::" , stringify ! ( __align ) ) ) ; } impl :: std :: fmt :: Debug for sem_t { fn fmt ( & self , f : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { write ! ( f , "sem_t {{ union }}" ) } } pub type VCOS_SEMAPHORE_T = sem_t ; pub type VCOS_UNSIGNED = u32 ; pub type VCOS_OPTION = u32 ; pub type VCOS_ONCE_T = pthread_once_t ; pub type VCOS_MUTEX_T = pthread_mutex_t ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct VCOS_TIMER_T { /// < id of the timer thread
 pub thread : pthread_t , /// < lock protecting all other members of the struct
 pub lock : pthread_mutex_t , /// < cond. var. for informing the timer thread about changes
 pub settings_changed : pthread_cond_t , /// < non-zero if the timer thread is requested to quit
 pub quit : :: std :: os :: raw :: c_int , /// < absolute time of next expiration, or 0 if disarmed
 pub expires : timespec , /// < the expiration routine provided by the user of the timer
 pub orig_expiration_routine : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut :: std :: os :: raw :: c_void ) > , /// < the context for exp. routine provided by the user
 pub orig_context : * mut :: std :: os :: raw :: c_void , } # [ test ] fn bindgen_test_layout_VCOS_TIMER_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < VCOS_TIMER_T > ( ) , 136usize , concat ! ( "Size of: " , stringify ! ( VCOS_TIMER_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < VCOS_TIMER_T > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( VCOS_TIMER_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_TIMER_T > ( ) ) ) . thread as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_TIMER_T ) , "::" , stringify ! ( thread ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_TIMER_T > ( ) ) ) . lock as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_TIMER_T ) , "::" , stringify ! ( lock ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_TIMER_T > ( ) ) ) . settings_changed as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_TIMER_T ) , "::" , stringify ! ( settings_changed ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_TIMER_T > ( ) ) ) . quit as * const _ as usize } , 96usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_TIMER_T ) , "::" , stringify ! ( quit ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_TIMER_T > ( ) ) ) . expires as * const _ as usize } , 104usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_TIMER_T ) , "::" , stringify ! ( expires ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_TIMER_T > ( ) ) ) . orig_expiration_routine as * const _ as usize } , 120usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_TIMER_T ) , "::" , stringify ! ( orig_expiration_routine ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_TIMER_T > ( ) ) ) . orig_context as * const _ as usize } , 128usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_TIMER_T ) , "::" , stringify ! ( orig_context ) ) ) ; } impl :: std :: fmt :: Debug for VCOS_TIMER_T { fn fmt ( & self , f : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { write ! ( f , "VCOS_TIMER_T {{ thread: {:?}, lock: {:?}, settings_changed: {:?}, quit: {:?}, expires: {:?}, orig_expiration_routine: {:?}, orig_context: {:?} }}" , self . thread , self . lock , self . settings_changed , self . quit , self . expires , self . orig_expiration_routine , self . orig_context ) } } /// Thread attribute structure. Don't use pthread_attr directly, as
/// the calls can fail, and inits must match deletes.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct VCOS_THREAD_ATTR_T { pub ta_stackaddr : * mut :: std :: os :: raw :: c_void , pub ta_stacksz : VCOS_UNSIGNED , pub ta_priority : VCOS_UNSIGNED , pub ta_affinity : VCOS_UNSIGNED , pub ta_timeslice : VCOS_UNSIGNED , pub legacy : VCOS_UNSIGNED , } # [ test ] fn bindgen_test_layout_VCOS_THREAD_ATTR_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < VCOS_THREAD_ATTR_T > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( VCOS_THREAD_ATTR_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < VCOS_THREAD_ATTR_T > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( VCOS_THREAD_ATTR_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_THREAD_ATTR_T > ( ) ) ) . ta_stackaddr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_THREAD_ATTR_T ) , "::" , stringify ! ( ta_stackaddr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_THREAD_ATTR_T > ( ) ) ) . ta_stacksz as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_THREAD_ATTR_T ) , "::" , stringify ! ( ta_stacksz ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_THREAD_ATTR_T > ( ) ) ) . ta_priority as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_THREAD_ATTR_T ) , "::" , stringify ! ( ta_priority ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_THREAD_ATTR_T > ( ) ) ) . ta_affinity as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_THREAD_ATTR_T ) , "::" , stringify ! ( ta_affinity ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_THREAD_ATTR_T > ( ) ) ) . ta_timeslice as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_THREAD_ATTR_T ) , "::" , stringify ! ( ta_timeslice ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_THREAD_ATTR_T > ( ) ) ) . legacy as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_THREAD_ATTR_T ) , "::" , stringify ! ( legacy ) ) ) ; } /// Called at thread exit.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct VCOS_THREAD_EXIT_T { pub pfn : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut :: std :: os :: raw :: c_void ) > , pub cxt : * mut :: std :: os :: raw :: c_void , } # [ test ] fn bindgen_test_layout_VCOS_THREAD_EXIT_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < VCOS_THREAD_EXIT_T > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( VCOS_THREAD_EXIT_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < VCOS_THREAD_EXIT_T > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( VCOS_THREAD_EXIT_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_THREAD_EXIT_T > ( ) ) ) . pfn as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_THREAD_EXIT_T ) , "::" , stringify ! ( pfn ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_THREAD_EXIT_T > ( ) ) ) . cxt as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_THREAD_EXIT_T ) , "::" , stringify ! ( cxt ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct VCOS_THREAD_T { /// < The thread itself
 pub thread : pthread_t , /// < The thread entry point
 pub entry : VCOS_THREAD_ENTRY_FN_T , /// < The argument to be passed to entry
 pub arg : * mut :: std :: os :: raw :: c_void , /// < For support event groups and similar - a per thread semaphore
 pub suspend : VCOS_SEMAPHORE_T , pub task_timer : VCOS_TIMER_T , /// < non-zero if the task timer has already been created
 pub task_timer_created : :: std :: os :: raw :: c_int , pub orig_task_timer_expiration_routine : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut :: std :: os :: raw :: c_void ) > , pub orig_task_timer_context : * mut :: std :: os :: raw :: c_void , pub legacy : VCOS_UNSIGNED , /// < Record the name of this thread, for diagnostics
 pub name : [ :: std :: os :: raw :: c_char ; 16usize ] , /// < Dummy thread created for non-vcos created threads
 pub dummy : VCOS_UNSIGNED , /// Callback invoked at thread exit time
 pub at_exit : [ VCOS_THREAD_EXIT_T ; 4usize ] , } # [ test ] fn bindgen_test_layout_VCOS_THREAD_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < VCOS_THREAD_T > ( ) , 304usize , concat ! ( "Size of: " , stringify ! ( VCOS_THREAD_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < VCOS_THREAD_T > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( VCOS_THREAD_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_THREAD_T > ( ) ) ) . thread as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_THREAD_T ) , "::" , stringify ! ( thread ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_THREAD_T > ( ) ) ) . entry as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_THREAD_T ) , "::" , stringify ! ( entry ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_THREAD_T > ( ) ) ) . arg as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_THREAD_T ) , "::" , stringify ! ( arg ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_THREAD_T > ( ) ) ) . suspend as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_THREAD_T ) , "::" , stringify ! ( suspend ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_THREAD_T > ( ) ) ) . task_timer as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_THREAD_T ) , "::" , stringify ! ( task_timer ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_THREAD_T > ( ) ) ) . task_timer_created as * const _ as usize } , 192usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_THREAD_T ) , "::" , stringify ! ( task_timer_created ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_THREAD_T > ( ) ) ) . orig_task_timer_expiration_routine as * const _ as usize } , 200usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_THREAD_T ) , "::" , stringify ! ( orig_task_timer_expiration_routine ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_THREAD_T > ( ) ) ) . orig_task_timer_context as * const _ as usize } , 208usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_THREAD_T ) , "::" , stringify ! ( orig_task_timer_context ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_THREAD_T > ( ) ) ) . legacy as * const _ as usize } , 216usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_THREAD_T ) , "::" , stringify ! ( legacy ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_THREAD_T > ( ) ) ) . name as * const _ as usize } , 220usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_THREAD_T ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_THREAD_T > ( ) ) ) . dummy as * const _ as usize } , 236usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_THREAD_T ) , "::" , stringify ! ( dummy ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_THREAD_T > ( ) ) ) . at_exit as * const _ as usize } , 240usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_THREAD_T ) , "::" , stringify ! ( at_exit ) ) ) ; } impl :: std :: fmt :: Debug for VCOS_THREAD_T { fn fmt ( & self , f : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { write ! ( f , "VCOS_THREAD_T {{ thread: {:?}, entry: {:?}, arg: {:?}, suspend: {:?}, task_timer: {:?}, task_timer_created: {:?}, orig_task_timer_expiration_routine: {:?}, orig_task_timer_context: {:?}, legacy: {:?}, name: {:?}, dummy: {:?}, at_exit: {:?} }}" , self . thread , self . entry , self . arg , self . suspend , self . task_timer , self . task_timer_created , self . orig_task_timer_expiration_routine , self . orig_task_timer_context , self . legacy , self . name , self . dummy , self . at_exit ) } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct VCOS_EVENT_WAITER_T { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct VCOS_EVENT_FLAGS_T { /// < Events currently set
 pub events : VCOS_UNSIGNED , /// < Serialize access
 pub lock : VCOS_MUTEX_T , pub waiters : VCOS_EVENT_FLAGS_T__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct VCOS_EVENT_FLAGS_T__bindgen_ty_1 { /// < List of threads waiting
 pub head : * mut VCOS_EVENT_WAITER_T , /// < List of threads waiting
 pub tail : * mut VCOS_EVENT_WAITER_T , } # [ test ] fn bindgen_test_layout_VCOS_EVENT_FLAGS_T__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < VCOS_EVENT_FLAGS_T__bindgen_ty_1 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( VCOS_EVENT_FLAGS_T__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < VCOS_EVENT_FLAGS_T__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( VCOS_EVENT_FLAGS_T__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_EVENT_FLAGS_T__bindgen_ty_1 > ( ) ) ) . head as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_EVENT_FLAGS_T__bindgen_ty_1 ) , "::" , stringify ! ( head ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_EVENT_FLAGS_T__bindgen_ty_1 > ( ) ) ) . tail as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_EVENT_FLAGS_T__bindgen_ty_1 ) , "::" , stringify ! ( tail ) ) ) ; } # [ test ] fn bindgen_test_layout_VCOS_EVENT_FLAGS_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < VCOS_EVENT_FLAGS_T > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( VCOS_EVENT_FLAGS_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < VCOS_EVENT_FLAGS_T > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( VCOS_EVENT_FLAGS_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_EVENT_FLAGS_T > ( ) ) ) . events as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_EVENT_FLAGS_T ) , "::" , stringify ! ( events ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_EVENT_FLAGS_T > ( ) ) ) . lock as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_EVENT_FLAGS_T ) , "::" , stringify ! ( lock ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_EVENT_FLAGS_T > ( ) ) ) . waiters as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_EVENT_FLAGS_T ) , "::" , stringify ! ( waiters ) ) ) ; } impl :: std :: fmt :: Debug for VCOS_EVENT_FLAGS_T { fn fmt ( & self , f : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { write ! ( f , "VCOS_EVENT_FLAGS_T {{ events: {:?}, lock: {:?}, waiters: {:?} }}" , self . events , self . lock , self . waiters ) } } extern "C" { pub fn vcos_generic_event_flags_create ( flags : * mut VCOS_EVENT_FLAGS_T , name : * const :: std :: os :: raw :: c_char ) -> VCOS_STATUS_T ; } extern "C" { pub fn vcos_generic_event_flags_set ( flags : * mut VCOS_EVENT_FLAGS_T , events : VCOS_UNSIGNED , op : VCOS_OPTION ) ; } extern "C" { pub fn vcos_generic_event_flags_delete ( arg1 : * mut VCOS_EVENT_FLAGS_T ) ; } extern "C" { pub fn vcos_generic_event_flags_get ( flags : * mut VCOS_EVENT_FLAGS_T , requested_events : VCOS_UNSIGNED , op : VCOS_OPTION , suspend : VCOS_UNSIGNED , retrieved_events : * mut VCOS_UNSIGNED ) -> VCOS_STATUS_T ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct VCOS_BLOCKPOOL_HEADER_TAG { pub owner : VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1 { pub next : * mut VCOS_BLOCKPOOL_HEADER_TAG , pub subpool : * mut VCOS_BLOCKPOOL_SUBPOOL_TAG , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1 > ( ) ) ) . next as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1 ) , "::" , stringify ! ( next ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1 > ( ) ) ) . subpool as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1 ) , "::" , stringify ! ( subpool ) ) ) ; } impl :: std :: fmt :: Debug for VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1 { fn fmt ( & self , f : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { write ! ( f , "VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1 {{ union }}" ) } } # [ test ] fn bindgen_test_layout_VCOS_BLOCKPOOL_HEADER_TAG ( ) { assert_eq ! ( :: std :: mem :: size_of :: < VCOS_BLOCKPOOL_HEADER_TAG > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( VCOS_BLOCKPOOL_HEADER_TAG ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < VCOS_BLOCKPOOL_HEADER_TAG > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( VCOS_BLOCKPOOL_HEADER_TAG ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_BLOCKPOOL_HEADER_TAG > ( ) ) ) . owner as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_BLOCKPOOL_HEADER_TAG ) , "::" , stringify ! ( owner ) ) ) ; } impl :: std :: fmt :: Debug for VCOS_BLOCKPOOL_HEADER_TAG { fn fmt ( & self , f : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { write ! ( f , "VCOS_BLOCKPOOL_HEADER_TAG {{ owner: {:?} }}" , self . owner ) } } pub type VCOS_BLOCKPOOL_HEADER_T = VCOS_BLOCKPOOL_HEADER_TAG ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct VCOS_BLOCKPOOL_SUBPOOL_TAG { /// VCOS_BLOCKPOOL_SUBPOOL_MAGIC
 pub magic : u32 , pub free_list : * mut VCOS_BLOCKPOOL_HEADER_T , pub mem : * mut :: std :: os :: raw :: c_void , pub start : * mut :: std :: os :: raw :: c_void , pub end : * mut :: std :: os :: raw :: c_void , /// The number of blocks in this sub-pool
 pub num_blocks : VCOS_UNSIGNED , /// Current number of available blocks in this sub-pool
 pub available_blocks : VCOS_UNSIGNED , /// Pointers to the pool that owns this sub-pool
 pub owner : * mut VCOS_BLOCKPOOL_TAG , /// Define properties such as memory ownership
 pub flags : u32 , } # [ test ] fn bindgen_test_layout_VCOS_BLOCKPOOL_SUBPOOL_TAG ( ) { assert_eq ! ( :: std :: mem :: size_of :: < VCOS_BLOCKPOOL_SUBPOOL_TAG > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( VCOS_BLOCKPOOL_SUBPOOL_TAG ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < VCOS_BLOCKPOOL_SUBPOOL_TAG > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( VCOS_BLOCKPOOL_SUBPOOL_TAG ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_BLOCKPOOL_SUBPOOL_TAG > ( ) ) ) . magic as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_BLOCKPOOL_SUBPOOL_TAG ) , "::" , stringify ! ( magic ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_BLOCKPOOL_SUBPOOL_TAG > ( ) ) ) . free_list as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_BLOCKPOOL_SUBPOOL_TAG ) , "::" , stringify ! ( free_list ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_BLOCKPOOL_SUBPOOL_TAG > ( ) ) ) . mem as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_BLOCKPOOL_SUBPOOL_TAG ) , "::" , stringify ! ( mem ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_BLOCKPOOL_SUBPOOL_TAG > ( ) ) ) . start as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_BLOCKPOOL_SUBPOOL_TAG ) , "::" , stringify ! ( start ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_BLOCKPOOL_SUBPOOL_TAG > ( ) ) ) . end as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_BLOCKPOOL_SUBPOOL_TAG ) , "::" , stringify ! ( end ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_BLOCKPOOL_SUBPOOL_TAG > ( ) ) ) . num_blocks as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_BLOCKPOOL_SUBPOOL_TAG ) , "::" , stringify ! ( num_blocks ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_BLOCKPOOL_SUBPOOL_TAG > ( ) ) ) . available_blocks as * const _ as usize } , 44usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_BLOCKPOOL_SUBPOOL_TAG ) , "::" , stringify ! ( available_blocks ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_BLOCKPOOL_SUBPOOL_TAG > ( ) ) ) . owner as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_BLOCKPOOL_SUBPOOL_TAG ) , "::" , stringify ! ( owner ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_BLOCKPOOL_SUBPOOL_TAG > ( ) ) ) . flags as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_BLOCKPOOL_SUBPOOL_TAG ) , "::" , stringify ! ( flags ) ) ) ; } pub type VCOS_BLOCKPOOL_SUBPOOL_T = VCOS_BLOCKPOOL_SUBPOOL_TAG ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct VCOS_BLOCKPOOL_TAG { /// VCOS_BLOCKPOOL_MAGIC
 pub magic : u32 , /// Thread safety for Alloc, Free, Delete, Stats
 pub mutex : VCOS_MUTEX_T , /// Alignment of block data pointers
 pub align : VCOS_UNSIGNED , /// Flags for future use e.g. cache options
 pub flags : VCOS_UNSIGNED , /// The size of the block data
 pub block_data_size : usize , /// Block size inc overheads
 pub block_size : usize , /// Name for debugging
 pub name : * const :: std :: os :: raw :: c_char , pub num_subpools : VCOS_UNSIGNED , /// Number of blocks in each dynamically allocated subpool
 pub num_extension_blocks : VCOS_UNSIGNED , /// Array of subpools. Subpool zero is is not deleted until the pool is
    /// destroed. If the index of the pool is < num_subpools and
    /// subpool[index.mem] is null then the subpool entry is valid but
    /// "not currently allocated"
 pub subpools : [ VCOS_BLOCKPOOL_SUBPOOL_T ; 8usize ] , } # [ test ] fn bindgen_test_layout_VCOS_BLOCKPOOL_TAG ( ) { assert_eq ! ( :: std :: mem :: size_of :: < VCOS_BLOCKPOOL_TAG > ( ) , 600usize , concat ! ( "Size of: " , stringify ! ( VCOS_BLOCKPOOL_TAG ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < VCOS_BLOCKPOOL_TAG > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( VCOS_BLOCKPOOL_TAG ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_BLOCKPOOL_TAG > ( ) ) ) . magic as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_BLOCKPOOL_TAG ) , "::" , stringify ! ( magic ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_BLOCKPOOL_TAG > ( ) ) ) . mutex as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_BLOCKPOOL_TAG ) , "::" , stringify ! ( mutex ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_BLOCKPOOL_TAG > ( ) ) ) . align as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_BLOCKPOOL_TAG ) , "::" , stringify ! ( align ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_BLOCKPOOL_TAG > ( ) ) ) . flags as * const _ as usize } , 52usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_BLOCKPOOL_TAG ) , "::" , stringify ! ( flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_BLOCKPOOL_TAG > ( ) ) ) . block_data_size as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_BLOCKPOOL_TAG ) , "::" , stringify ! ( block_data_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_BLOCKPOOL_TAG > ( ) ) ) . block_size as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_BLOCKPOOL_TAG ) , "::" , stringify ! ( block_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_BLOCKPOOL_TAG > ( ) ) ) . name as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_BLOCKPOOL_TAG ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_BLOCKPOOL_TAG > ( ) ) ) . num_subpools as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_BLOCKPOOL_TAG ) , "::" , stringify ! ( num_subpools ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_BLOCKPOOL_TAG > ( ) ) ) . num_extension_blocks as * const _ as usize } , 84usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_BLOCKPOOL_TAG ) , "::" , stringify ! ( num_extension_blocks ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_BLOCKPOOL_TAG > ( ) ) ) . subpools as * const _ as usize } , 88usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_BLOCKPOOL_TAG ) , "::" , stringify ! ( subpools ) ) ) ; } impl :: std :: fmt :: Debug for VCOS_BLOCKPOOL_TAG { fn fmt ( & self , f : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { write ! ( f , "VCOS_BLOCKPOOL_TAG {{ magic: {:?}, mutex: {:?}, align: {:?}, flags: {:?}, block_data_size: {:?}, block_size: {:?}, name: {:?}, num_subpools: {:?}, num_extension_blocks: {:?}, subpools: {:?} }}" , self . magic , self . mutex , self . align , self . flags , self . block_data_size , self . block_size , self . name , self . num_subpools , self . num_extension_blocks , self . subpools ) } } pub type VCOS_BLOCKPOOL_T = VCOS_BLOCKPOOL_TAG ; extern "C" { pub fn vcos_generic_blockpool_init ( pool : * mut VCOS_BLOCKPOOL_T , num_blocks : VCOS_UNSIGNED , block_size : VCOS_UNSIGNED , start : * mut :: std :: os :: raw :: c_void , pool_size : VCOS_UNSIGNED , align : VCOS_UNSIGNED , flags : VCOS_UNSIGNED , name : * const :: std :: os :: raw :: c_char ) -> VCOS_STATUS_T ; } extern "C" { pub fn vcos_generic_blockpool_create_on_heap ( pool : * mut VCOS_BLOCKPOOL_T , num_blocks : VCOS_UNSIGNED , block_size : VCOS_UNSIGNED , align : VCOS_UNSIGNED , flags : VCOS_UNSIGNED , name : * const :: std :: os :: raw :: c_char ) -> VCOS_STATUS_T ; } extern "C" { pub fn vcos_generic_blockpool_extend ( pool : * mut VCOS_BLOCKPOOL_T , num_extensions : VCOS_UNSIGNED , num_blocks : VCOS_UNSIGNED ) -> VCOS_STATUS_T ; } extern "C" { pub fn vcos_generic_blockpool_alloc ( pool : * mut VCOS_BLOCKPOOL_T ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn vcos_generic_blockpool_calloc ( pool : * mut VCOS_BLOCKPOOL_T ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn vcos_generic_blockpool_free ( block : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { pub fn vcos_generic_blockpool_available_count ( pool : * mut VCOS_BLOCKPOOL_T ) -> VCOS_UNSIGNED ; } extern "C" { pub fn vcos_generic_blockpool_used_count ( pool : * mut VCOS_BLOCKPOOL_T ) -> VCOS_UNSIGNED ; } extern "C" { pub fn vcos_generic_blockpool_delete ( pool : * mut VCOS_BLOCKPOOL_T ) ; } extern "C" { pub fn vcos_generic_blockpool_elem_to_handle ( block : * mut :: std :: os :: raw :: c_void ) -> u32 ; } extern "C" { pub fn vcos_generic_blockpool_elem_from_handle ( pool : * mut VCOS_BLOCKPOOL_T , handle : u32 ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn vcos_generic_blockpool_is_valid_elem ( pool : * mut VCOS_BLOCKPOOL_T , block : * const :: std :: os :: raw :: c_void ) -> u32 ; } extern "C" { /// \file
///
/// Create the vcos malloc API from a regular system malloc/free library.
///
/// The API lets callers specify an alignment.
///
/// Under VideoCore this is not needed, as we can simply use the rtos_malloc routines.
/// But on host platforms that won't be the case.
///
 pub fn vcos_generic_mem_alloc ( sz : VCOS_UNSIGNED , desc : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn vcos_generic_mem_calloc ( count : VCOS_UNSIGNED , sz : VCOS_UNSIGNED , descr : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn vcos_generic_mem_free ( ptr : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { pub fn vcos_generic_mem_alloc_aligned ( sz : VCOS_UNSIGNED , align : VCOS_UNSIGNED , desc : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { /// Convert errno values into the values recognized by vcos
 pub fn vcos_pthreads_map_error ( error : :: std :: os :: raw :: c_int ) -> VCOS_STATUS_T ; } extern "C" { pub fn vcos_pthreads_map_errno ( ) -> VCOS_STATUS_T ; } extern "C" { /// Register a function to be called when the current thread exits.
 pub fn vcos_thread_at_exit ( pfn : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut :: std :: os :: raw :: c_void ) > , cxt : * mut :: std :: os :: raw :: c_void ) -> VCOS_STATUS_T ; } extern "C" { /// Threads
///
 pub fn vcos_dummy_thread_create ( ) -> * mut VCOS_THREAD_T ; } extern "C" { pub fn vcos_getmicrosecs64_internal ( ) -> u64 ; } extern "C" { /// Timers
///
 pub fn vcos_pthreads_timer_create ( timer : * mut VCOS_TIMER_T , name : * const :: std :: os :: raw :: c_char , expiration_routine : :: std :: option :: Option < unsafe extern "C" fn ( context : * mut :: std :: os :: raw :: c_void ) > , context : * mut :: std :: os :: raw :: c_void ) -> VCOS_STATUS_T ; } extern "C" { pub fn vcos_pthreads_timer_set ( timer : * mut VCOS_TIMER_T , delay_ms : VCOS_UNSIGNED ) ; } extern "C" { pub fn vcos_pthreads_timer_cancel ( timer : * mut VCOS_TIMER_T ) ; } extern "C" { pub fn vcos_pthreads_timer_reset ( timer : * mut VCOS_TIMER_T , delay_ms : VCOS_UNSIGNED ) ; } extern "C" { pub fn vcos_pthreads_timer_delete ( timer : * mut VCOS_TIMER_T ) ; } /// \file
///
/// Reentrant Mutexes from regular ones.
///
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct VCOS_REENTRANT_MUTEX_T { pub mutex : VCOS_MUTEX_T , pub owner : * mut VCOS_THREAD_T , pub count : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout_VCOS_REENTRANT_MUTEX_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < VCOS_REENTRANT_MUTEX_T > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( VCOS_REENTRANT_MUTEX_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < VCOS_REENTRANT_MUTEX_T > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( VCOS_REENTRANT_MUTEX_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_REENTRANT_MUTEX_T > ( ) ) ) . mutex as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_REENTRANT_MUTEX_T ) , "::" , stringify ! ( mutex ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_REENTRANT_MUTEX_T > ( ) ) ) . owner as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_REENTRANT_MUTEX_T ) , "::" , stringify ! ( owner ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_REENTRANT_MUTEX_T > ( ) ) ) . count as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_REENTRANT_MUTEX_T ) , "::" , stringify ! ( count ) ) ) ; } impl :: std :: fmt :: Debug for VCOS_REENTRANT_MUTEX_T { fn fmt ( & self , f : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { write ! ( f , "VCOS_REENTRANT_MUTEX_T {{ mutex: {:?}, owner: {:?}, count: {:?} }}" , self . mutex , self . owner , self . count ) } } extern "C" { pub fn vcos_generic_reentrant_mutex_create ( m : * mut VCOS_REENTRANT_MUTEX_T , name : * const :: std :: os :: raw :: c_char ) -> VCOS_STATUS_T ; } extern "C" { pub fn vcos_generic_reentrant_mutex_delete ( m : * mut VCOS_REENTRANT_MUTEX_T ) ; } extern "C" { pub fn vcos_generic_reentrant_mutex_lock ( m : * mut VCOS_REENTRANT_MUTEX_T ) ; } extern "C" { pub fn vcos_generic_reentrant_mutex_unlock ( m : * mut VCOS_REENTRANT_MUTEX_T ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct VCOS_NAMED_SEMAPHORE_T { /// < There are 'n' named semaphores per 1 actual semaphore
 pub actual : * mut VCOS_NAMED_SEMAPHORE_IMPL_T , /// < Pointer to actual underlying semaphore
 pub sem : * mut VCOS_SEMAPHORE_T , } # [ test ] fn bindgen_test_layout_VCOS_NAMED_SEMAPHORE_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < VCOS_NAMED_SEMAPHORE_T > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( VCOS_NAMED_SEMAPHORE_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < VCOS_NAMED_SEMAPHORE_T > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( VCOS_NAMED_SEMAPHORE_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_NAMED_SEMAPHORE_T > ( ) ) ) . actual as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_NAMED_SEMAPHORE_T ) , "::" , stringify ! ( actual ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_NAMED_SEMAPHORE_T > ( ) ) ) . sem as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_NAMED_SEMAPHORE_T ) , "::" , stringify ! ( sem ) ) ) ; } extern "C" { pub fn vcos_generic_named_semaphore_create ( sem : * mut VCOS_NAMED_SEMAPHORE_T , name : * const :: std :: os :: raw :: c_char , count : VCOS_UNSIGNED ) -> VCOS_STATUS_T ; } extern "C" { /// \brief Delete a semaphore, releasing any resources consumed by it.
///
/// @param sem Semaphore to wait on
 pub fn vcos_named_semaphore_delete ( sem : * mut VCOS_NAMED_SEMAPHORE_T ) ; } extern "C" { /// vcos initialization. Call this function before using other vcos functions.
/// Calls can be nested within the same process; they are reference counted so
/// that only a call from uninitialized state has any effect.
/// @note On platforms/toolchains that support it, gcc's constructor attribute or
/// similar is used to invoke this function before main() or equivalent.
/// @return Status of initialisation.
 pub fn vcos_init ( ) -> VCOS_STATUS_T ; } extern "C" { /// vcos deinitialization. Call this function when vcos is no longer required,
/// in order to free resources.
/// Calls can be nested within the same process; they are reference counted so
/// that only a call that decrements the reference count to 0 has any effect.
/// @note On platforms/toolchains that support it, gcc's destructor attribute or
/// similar is used to invoke this function after exit() or equivalent.
/// @return Status of initialisation.
 pub fn vcos_deinit ( ) ; } extern "C" { /// Acquire global lock. This must be available independent of vcos_init()/vcos_deinit().
 pub fn vcos_global_lock ( ) ; } extern "C" { /// Release global lock. This must be available independent of vcos_init()/vcos_deinit().
 pub fn vcos_global_unlock ( ) ; } extern "C" { /// Pass in the argv/argc arguments passed to main()
 pub fn vcos_set_args ( argc : :: std :: os :: raw :: c_int , argv : * mut * const :: std :: os :: raw :: c_char ) ; } extern "C" { /// Return argc.
 pub fn vcos_get_argc ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { /// Return argv.
 pub fn vcos_get_argv ( ) -> * mut * const :: std :: os :: raw :: c_char ; } extern "C" { /// Platform-specific initialisation.
/// VCOS internal function, not part of public API, do not call from outside
/// vcos. vcos_init()/vcos_deinit() reference count calls, so this function is
/// only called from an uninitialized state, i.e. there will not be two
/// consecutive calls to vcos_platform_init() without an intervening call to
/// vcos_platform_deinit().
/// This function is called with vcos_global_lock held.
/// @return Status of initialisation.
 pub fn vcos_platform_init ( ) -> VCOS_STATUS_T ; } extern "C" { /// Platform-specific de-initialisation.
/// VCOS internal function, not part of public API, do not call from outside
/// vcos.
/// See vcos_platform_init() re reference counting.
/// This function is called with vcos_global_lock held.
 pub fn vcos_platform_deinit ( ) ; } extern "C" { /// Report whether or not we have an RTOS at all, and hence the ability to
/// create threads.
 pub fn vcos_have_rtos ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { /// Create a thread. It must be cleaned up by calling vcos_thread_join().
///
/// @param thread   Filled in on return with thread
/// @param name     A name for the thread. May be the empty string.
/// @param attrs    Attributes; default attributes will be used if this is NULL.
/// @param entry    Entry point.
/// @param arg      Argument passed to the entry point.
 pub fn vcos_thread_create ( thread : * mut VCOS_THREAD_T , name : * const :: std :: os :: raw :: c_char , attrs : * mut VCOS_THREAD_ATTR_T , entry : VCOS_THREAD_ENTRY_FN_T , arg : * mut :: std :: os :: raw :: c_void ) -> VCOS_STATUS_T ; } extern "C" { /// Exit the thread from within the thread function itself.
/// Resources must still be cleaned up via a call to thread_join().
///
/// The thread can also be terminated by simply exiting the thread function.
///
/// @param data Data passed to thread_join. May be NULL.
 pub fn vcos_thread_exit ( data : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { /// Wait for a thread to terminate and then clean up its resources.
///
/// @param thread Thread to wait for
/// @param pData  Updated to point at data provided in vcos_thread_exit or exit
/// code of thread function.
 pub fn vcos_thread_join ( thread : * mut VCOS_THREAD_T , pData : * mut * mut :: std :: os :: raw :: c_void ) ; } extern "C" { /// \brief Create a thread using an API similar to the one "traditionally"
/// used under Nucleus.
///
/// This creates a thread which must be cleaned up by calling vcos_thread_join().
/// The thread cannot be simply terminated (as in Nucleus and ThreadX) as thread
/// termination is not universally supported.
///
/// @param thread       Filled in with thread instance
/// @param name         An optional name for the thread. NULL or "" may be used (but
/// a name will aid in debugging).
/// @param entry        Entry point
/// @param arg          A single argument passed to the entry point function
/// @param stack        Pointer to stack address
/// @param stacksz      Size of stack in bytes
/// @param priaff       Priority of task, between VCOS_PRI_LOW and VCOS_PRI_HIGH, ORed with the CPU affinity
/// @param autostart    If non-zero the thread will start immediately.
/// @param timeslice    Timeslice (system ticks) for this thread.
///
/// @sa vcos_thread_terminate vcos_thread_delete
 pub fn vcos_thread_create_classic ( thread : * mut VCOS_THREAD_T , name : * const :: std :: os :: raw :: c_char , entry : :: std :: option :: Option < unsafe extern "C" fn ( arg : * mut :: std :: os :: raw :: c_void ) -> * mut :: std :: os :: raw :: c_void > , arg : * mut :: std :: os :: raw :: c_void , stack : * mut :: std :: os :: raw :: c_void , stacksz : VCOS_UNSIGNED , priaff : VCOS_UNSIGNED , timeslice : VCOS_UNSIGNED , autostart : VCOS_UNSIGNED ) -> VCOS_STATUS_T ; } extern "C" { /// Return the name of the given thread.
 pub fn vcos_thread_get_name ( thread : * const VCOS_THREAD_T ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn vcos_kmalloc ( size : VCOS_UNSIGNED , description : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn vcos_kcalloc ( num : VCOS_UNSIGNED , size : VCOS_UNSIGNED , description : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn vcos_kfree ( ptr : * mut :: std :: os :: raw :: c_void ) ; } pub type va_list = __builtin_va_list ; pub const VCOS_LOG_LEVEL_T_VCOS_LOG_UNINITIALIZED : VCOS_LOG_LEVEL_T = 0 ; pub const VCOS_LOG_LEVEL_T_VCOS_LOG_NEVER : VCOS_LOG_LEVEL_T = 1 ; pub const VCOS_LOG_LEVEL_T_VCOS_LOG_ERROR : VCOS_LOG_LEVEL_T = 2 ; pub const VCOS_LOG_LEVEL_T_VCOS_LOG_WARN : VCOS_LOG_LEVEL_T = 3 ; pub const VCOS_LOG_LEVEL_T_VCOS_LOG_INFO : VCOS_LOG_LEVEL_T = 4 ; pub const VCOS_LOG_LEVEL_T_VCOS_LOG_TRACE : VCOS_LOG_LEVEL_T = 5 ; pub type VCOS_LOG_LEVEL_T = u32 ; /// A registered logging category.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct VCOS_LOG_CAT_T { /// < Which levels are enabled for this category
 pub level : VCOS_LOG_LEVEL_T , /// < Name for this category.
 pub name : * const :: std :: os :: raw :: c_char , pub next : * mut VCOS_LOG_CAT_T , pub flags : VCOS_LOG_CAT_T__bindgen_ty_1 , pub refcount : :: std :: os :: raw :: c_uint , /// < platform specific data
 pub platform_data : * mut :: std :: os :: raw :: c_void , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct VCOS_LOG_CAT_T__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub __bindgen_padding_0 : [ u8 ; 3usize ] , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_VCOS_LOG_CAT_T__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < VCOS_LOG_CAT_T__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( VCOS_LOG_CAT_T__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < VCOS_LOG_CAT_T__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( VCOS_LOG_CAT_T__bindgen_ty_1 ) ) ) ; } impl VCOS_LOG_CAT_T__bindgen_ty_1 { # [ inline ] pub fn want_prefix ( & self ) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_want_prefix ( & mut self , val : :: std :: os :: raw :: c_uint ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( want_prefix : :: std :: os :: raw :: c_uint ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let want_prefix : u32 = unsafe { :: std :: mem :: transmute ( want_prefix ) } ; want_prefix as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_VCOS_LOG_CAT_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < VCOS_LOG_CAT_T > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( VCOS_LOG_CAT_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < VCOS_LOG_CAT_T > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( VCOS_LOG_CAT_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_LOG_CAT_T > ( ) ) ) . level as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_LOG_CAT_T ) , "::" , stringify ! ( level ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_LOG_CAT_T > ( ) ) ) . name as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_LOG_CAT_T ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_LOG_CAT_T > ( ) ) ) . next as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_LOG_CAT_T ) , "::" , stringify ! ( next ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_LOG_CAT_T > ( ) ) ) . flags as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_LOG_CAT_T ) , "::" , stringify ! ( flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_LOG_CAT_T > ( ) ) ) . refcount as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_LOG_CAT_T ) , "::" , stringify ! ( refcount ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_LOG_CAT_T > ( ) ) ) . platform_data as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_LOG_CAT_T ) , "::" , stringify ! ( platform_data ) ) ) ; } pub type VCOS_VLOG_IMPL_FUNC_T = :: std :: option :: Option < unsafe extern "C" fn ( cat : * const VCOS_LOG_CAT_T , _level : VCOS_LOG_LEVEL_T , fmt : * const :: std :: os :: raw :: c_char , args : * mut __va_list_tag ) > ; extern "C" { /// Convert a VCOS_LOG_LEVEL_T into a printable string.
/// The platform needs to implement this function.
 pub fn vcos_log_level_to_string ( level : VCOS_LOG_LEVEL_T ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { /// Convert a string into a VCOS_LOG_LEVEL_T
/// The platform needs to implement this function.
 pub fn vcos_string_to_log_level ( str : * const :: std :: os :: raw :: c_char , level : * mut VCOS_LOG_LEVEL_T ) -> VCOS_STATUS_T ; } extern "C" { /// Log a message. Basic API. Normal code should not use this.
/// The platform needs to implement this function.
 pub fn vcos_log_impl ( cat : * const VCOS_LOG_CAT_T , _level : VCOS_LOG_LEVEL_T , fmt : * const :: std :: os :: raw :: c_char , ... ) ; } extern "C" { /// Log a message using a varargs parameter list. Normal code should
/// not use this.
 pub fn vcos_vlog_impl ( cat : * const VCOS_LOG_CAT_T , _level : VCOS_LOG_LEVEL_T , fmt : * const :: std :: os :: raw :: c_char , args : * mut __va_list_tag ) ; } extern "C" { /// Set the function which does the actual logging output.
/// Passing in NULL causes the default logging function to be
/// used.
 pub fn vcos_set_vlog_impl ( vlog_impl_func : VCOS_VLOG_IMPL_FUNC_T ) ; } extern "C" { /// The default logging function, which is provided by each
/// platform.
 pub fn vcos_vlog_default_impl ( cat : * const VCOS_LOG_CAT_T , _level : VCOS_LOG_LEVEL_T , fmt : * const :: std :: os :: raw :: c_char , args : * mut __va_list_tag ) ; } extern "C" { pub fn vcos_logging_init ( ) ; } extern "C" { /// Register a logging category.
///
/// @param name the name of this category.
/// @param category the category to register.
 pub fn vcos_log_register ( name : * const :: std :: os :: raw :: c_char , category : * mut VCOS_LOG_CAT_T ) ; } extern "C" { /// Unregister a logging category.
 pub fn vcos_log_unregister ( category : * mut VCOS_LOG_CAT_T ) ; } extern "C" { /// Return a default logging category, for people too lazy to create their own.
///
/// Using the default category will be slow (there's an extra function
/// call overhead). Don't do this in normal code.
 pub fn vcos_log_get_default_category ( ) -> * const VCOS_LOG_CAT_T ; } extern "C" { pub fn vcos_set_log_options ( opt : * const :: std :: os :: raw :: c_char ) ; } extern "C" { pub fn vcos_log_dump_mem_impl ( cat : * const VCOS_LOG_CAT_T , label : * const :: std :: os :: raw :: c_char , addr : u32 , voidMem : * const :: std :: os :: raw :: c_void , numBytes : usize ) ; } pub type VCOS_CMD_T = VCOS_CMD_S ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct VCOS_CMD_PARAM_T { pub argc : :: std :: os :: raw :: c_int , pub argv : * mut * mut :: std :: os :: raw :: c_char , pub argv_orig : * mut * mut :: std :: os :: raw :: c_char , pub cmd_entry : * mut VCOS_CMD_T , pub cmd_parent_entry : * mut VCOS_CMD_T , pub use_log : :: std :: os :: raw :: c_int , pub result_size : usize , pub result_ptr : * mut :: std :: os :: raw :: c_char , pub result_buf : * mut :: std :: os :: raw :: c_char , } # [ test ] fn bindgen_test_layout_VCOS_CMD_PARAM_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < VCOS_CMD_PARAM_T > ( ) , 72usize , concat ! ( "Size of: " , stringify ! ( VCOS_CMD_PARAM_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < VCOS_CMD_PARAM_T > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( VCOS_CMD_PARAM_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_CMD_PARAM_T > ( ) ) ) . argc as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_CMD_PARAM_T ) , "::" , stringify ! ( argc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_CMD_PARAM_T > ( ) ) ) . argv as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_CMD_PARAM_T ) , "::" , stringify ! ( argv ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_CMD_PARAM_T > ( ) ) ) . argv_orig as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_CMD_PARAM_T ) , "::" , stringify ! ( argv_orig ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_CMD_PARAM_T > ( ) ) ) . cmd_entry as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_CMD_PARAM_T ) , "::" , stringify ! ( cmd_entry ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_CMD_PARAM_T > ( ) ) ) . cmd_parent_entry as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_CMD_PARAM_T ) , "::" , stringify ! ( cmd_parent_entry ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_CMD_PARAM_T > ( ) ) ) . use_log as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_CMD_PARAM_T ) , "::" , stringify ! ( use_log ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_CMD_PARAM_T > ( ) ) ) . result_size as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_CMD_PARAM_T ) , "::" , stringify ! ( result_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_CMD_PARAM_T > ( ) ) ) . result_ptr as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_CMD_PARAM_T ) , "::" , stringify ! ( result_ptr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_CMD_PARAM_T > ( ) ) ) . result_buf as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_CMD_PARAM_T ) , "::" , stringify ! ( result_buf ) ) ) ; } pub type VCOS_CMD_FUNC_T = :: std :: option :: Option < unsafe extern "C" fn ( param : * mut VCOS_CMD_PARAM_T ) -> VCOS_STATUS_T > ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct VCOS_CMD_S { pub name : * const :: std :: os :: raw :: c_char , pub args : * const :: std :: os :: raw :: c_char , pub cmd_fn : VCOS_CMD_FUNC_T , pub sub_cmd_entry : * mut VCOS_CMD_T , pub descr : * const :: std :: os :: raw :: c_char , } # [ test ] fn bindgen_test_layout_VCOS_CMD_S ( ) { assert_eq ! ( :: std :: mem :: size_of :: < VCOS_CMD_S > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( VCOS_CMD_S ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < VCOS_CMD_S > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( VCOS_CMD_S ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_CMD_S > ( ) ) ) . name as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_CMD_S ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_CMD_S > ( ) ) ) . args as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_CMD_S ) , "::" , stringify ! ( args ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_CMD_S > ( ) ) ) . cmd_fn as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_CMD_S ) , "::" , stringify ! ( cmd_fn ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_CMD_S > ( ) ) ) . sub_cmd_entry as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_CMD_S ) , "::" , stringify ! ( sub_cmd_entry ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < VCOS_CMD_S > ( ) ) ) . descr as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( VCOS_CMD_S ) , "::" , stringify ! ( descr ) ) ) ; } extern "C" { pub fn vcos_cmd_error ( param : * mut VCOS_CMD_PARAM_T , fmt : * const :: std :: os :: raw :: c_char , ... ) ; } extern "C" { pub fn vcos_cmd_printf ( param : * mut VCOS_CMD_PARAM_T , fmt : * const :: std :: os :: raw :: c_char , ... ) ; } extern "C" { pub fn vcos_cmd_vprintf ( param : * mut VCOS_CMD_PARAM_T , fmt : * const :: std :: os :: raw :: c_char , args : * mut __va_list_tag ) ; } extern "C" { pub fn vcos_cmd_always_log_output ( log_category : * mut VCOS_LOG_CAT_T ) ; } extern "C" { pub fn vcos_cmd_usage ( param : * mut VCOS_CMD_PARAM_T ) ; } extern "C" { pub fn vcos_cmd_register ( cmd_entry : * mut VCOS_CMD_T ) -> VCOS_STATUS_T ; } extern "C" { pub fn vcos_cmd_register_multiple ( cmd_entry : * mut VCOS_CMD_T ) -> VCOS_STATUS_T ; } extern "C" { pub fn vcos_cmd_execute ( argc : :: std :: os :: raw :: c_int , argv : * mut * mut :: std :: os :: raw :: c_char , result_size : usize , result_buf : * mut :: std :: os :: raw :: c_char ) -> VCOS_STATUS_T ; } extern "C" { pub fn vcos_cmd_shutdown ( ) ; } extern "C" { pub fn vcos_log_assert_cmd ( param : * mut VCOS_CMD_PARAM_T ) -> VCOS_STATUS_T ; } extern "C" { pub fn vcos_log_set_cmd ( param : * mut VCOS_CMD_PARAM_T ) -> VCOS_STATUS_T ; } extern "C" { pub fn vcos_log_status_cmd ( param : * mut VCOS_CMD_PARAM_T ) -> VCOS_STATUS_T ; } extern "C" { pub fn vcos_log_test_cmd ( param : * mut VCOS_CMD_PARAM_T ) -> VCOS_STATUS_T ; } extern "C" { pub fn vcos_vsnprintf ( buf : * mut :: std :: os :: raw :: c_char , buflen : usize , fmt : * const :: std :: os :: raw :: c_char , ap : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vcos_snprintf ( buf : * mut :: std :: os :: raw :: c_char , buflen : usize , fmt : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { /// Like vsnprintf, except it places the output at the specified offset.
/// Output is truncated to fit in buflen bytes, and is guaranteed to be NUL-terminated.
/// Returns the string length before/without truncation.
 pub fn vcos_safe_vsprintf ( buf : * mut :: std :: os :: raw :: c_char , buflen : usize , offset : usize , fmt : * const :: std :: os :: raw :: c_char , ap : * mut __va_list_tag ) -> usize ; } extern "C" { /// Like snprintf, except it places the output at the specified offset.
/// Output is truncated to fit in buflen bytes, and is guaranteed to be NUL-terminated.
/// Returns the string length before/without truncation.
 pub fn vcos_safe_sprintf ( buf : * mut :: std :: os :: raw :: c_char , buflen : usize , offset : usize , fmt : * const :: std :: os :: raw :: c_char , ... ) -> usize ; } extern "C" { /// Copies string src to dst at the specified offset.
/// Output is truncated to fit in dstlen bytes, i.e. the string is at most
/// (buflen - 1) characters long. Unlike strncpy, exactly one NUL is written
/// to dst, which is always NUL-terminated.
/// Returns the string length before/without truncation.
 pub fn vcos_safe_strcpy ( dst : * mut :: std :: os :: raw :: c_char , src : * const :: std :: os :: raw :: c_char , dstlen : usize , offset : usize ) -> usize ; } extern "C" { /// Initialize thread attribute struct. This call does not allocate memory,
/// and so cannot fail.
///
 pub fn vcos_thread_attr_init ( attrs : * mut VCOS_THREAD_ATTR_T ) ; } extern "C" { /// Perform timer subsystem initialization. This function is not needed
/// on non-Windows platforms but is still present so that it can be
/// called. On Windows it is needed because vcos_init() gets called
/// from DLL initialization where it is not possible to create a
/// time queue (deadlock occurs if you try).
///
/// @return VCOS_SUCCESS on success. VCOS_EEXIST if this has already been called
/// once. VCOS_ENOMEM if resource allocation failed.
 pub fn vcos_timer_init ( ) -> VCOS_STATUS_T ; } extern "C" { /// \file vcos_once.h
///
/// Ensure something is called only once.
///
/// Initialize once_control to VCOS_ONCE_INIT. The first
/// time this is called, the init_routine will be called. Thereafter
/// it won't.
///
/// \sa pthread_once()
///
 pub fn vcos_once ( once_control : * mut VCOS_ONCE_T , init_routine : :: std :: option :: Option < unsafe extern "C" fn ( ) > ) -> VCOS_STATUS_T ; } pub type MMAL_BOOL_T = i32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_CORE_STATISTICS_T { /// < Total buffer count on this port
 pub buffer_count : u32 , /// < Time (us) of first buffer seen on this port
 pub first_buffer_time : u32 , /// < Time (us) of most recently buffer on this port
 pub last_buffer_time : u32 , /// < Max delay (us) between buffers, ignoring first few frames
 pub max_delay : u32 , } # [ test ] fn bindgen_test_layout_MMAL_CORE_STATISTICS_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_CORE_STATISTICS_T > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( MMAL_CORE_STATISTICS_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_CORE_STATISTICS_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_CORE_STATISTICS_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CORE_STATISTICS_T > ( ) ) ) . buffer_count as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CORE_STATISTICS_T ) , "::" , stringify ! ( buffer_count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CORE_STATISTICS_T > ( ) ) ) . first_buffer_time as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CORE_STATISTICS_T ) , "::" , stringify ! ( first_buffer_time ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CORE_STATISTICS_T > ( ) ) ) . last_buffer_time as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CORE_STATISTICS_T ) , "::" , stringify ! ( last_buffer_time ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CORE_STATISTICS_T > ( ) ) ) . max_delay as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CORE_STATISTICS_T ) , "::" , stringify ! ( max_delay ) ) ) ; } /// Statistics collected by the core on all ports, if enabled in the build.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_CORE_PORT_STATISTICS_T { pub rx : MMAL_CORE_STATISTICS_T , pub tx : MMAL_CORE_STATISTICS_T , } # [ test ] fn bindgen_test_layout_MMAL_CORE_PORT_STATISTICS_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_CORE_PORT_STATISTICS_T > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( MMAL_CORE_PORT_STATISTICS_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_CORE_PORT_STATISTICS_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_CORE_PORT_STATISTICS_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CORE_PORT_STATISTICS_T > ( ) ) ) . rx as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CORE_PORT_STATISTICS_T ) , "::" , stringify ! ( rx ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CORE_PORT_STATISTICS_T > ( ) ) ) . tx as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CORE_PORT_STATISTICS_T ) , "::" , stringify ! ( tx ) ) ) ; } /// Unsigned 16.16 fixed point value, also known as Q16.16
 pub type MMAL_FIXED_16_16_T = u32 ; pub mod MMAL_STATUS_T { pub type Type = u32 ; pub const MMAL_SUCCESS : Type = 0 ; pub const MMAL_ENOMEM : Type = 1 ; pub const MMAL_ENOSPC : Type = 2 ; pub const MMAL_EINVAL : Type = 3 ; pub const MMAL_ENOSYS : Type = 4 ; pub const MMAL_ENOENT : Type = 5 ; pub const MMAL_ENXIO : Type = 6 ; pub const MMAL_EIO : Type = 7 ; pub const MMAL_ESPIPE : Type = 8 ; pub const MMAL_ECORRUPT : Type = 9 ; pub const MMAL_ENOTREADY : Type = 10 ; pub const MMAL_ECONFIG : Type = 11 ; pub const MMAL_EISCONN : Type = 12 ; pub const MMAL_ENOTCONN : Type = 13 ; pub const MMAL_EAGAIN : Type = 14 ; pub const MMAL_EFAULT : Type = 15 ; pub const MMAL_STATUS_MAX : Type = 2147483647 ; } /// Describes a rectangle
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_RECT_T { /// < x coordinate (from left)
 pub x : i32 , /// < y coordinate (from top)
 pub y : i32 , /// < width
 pub width : i32 , /// < height
 pub height : i32 , } # [ test ] fn bindgen_test_layout_MMAL_RECT_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_RECT_T > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( MMAL_RECT_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_RECT_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_RECT_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_RECT_T > ( ) ) ) . x as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_RECT_T ) , "::" , stringify ! ( x ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_RECT_T > ( ) ) ) . y as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_RECT_T ) , "::" , stringify ! ( y ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_RECT_T > ( ) ) ) . width as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_RECT_T ) , "::" , stringify ! ( width ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_RECT_T > ( ) ) ) . height as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_RECT_T ) , "::" , stringify ! ( height ) ) ) ; } /// Describes a rational number
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_RATIONAL_T { /// < Numerator
 pub num : i32 , /// < Denominator
 pub den : i32 , } # [ test ] fn bindgen_test_layout_MMAL_RATIONAL_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_RATIONAL_T > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( MMAL_RATIONAL_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_RATIONAL_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_RATIONAL_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_RATIONAL_T > ( ) ) ) . num as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_RATIONAL_T ) , "::" , stringify ! ( num ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_RATIONAL_T > ( ) ) ) . den as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_RATIONAL_T ) , "::" , stringify ! ( den ) ) ) ; } /// Four Character Code type
 pub type MMAL_FOURCC_T = u32 ; pub const MMAL_ES_TYPE_T_MMAL_ES_TYPE_UNKNOWN : MMAL_ES_TYPE_T = 0 ; pub const MMAL_ES_TYPE_T_MMAL_ES_TYPE_CONTROL : MMAL_ES_TYPE_T = 1 ; pub const MMAL_ES_TYPE_T_MMAL_ES_TYPE_AUDIO : MMAL_ES_TYPE_T = 2 ; pub const MMAL_ES_TYPE_T_MMAL_ES_TYPE_VIDEO : MMAL_ES_TYPE_T = 3 ; pub const MMAL_ES_TYPE_T_MMAL_ES_TYPE_SUBPICTURE : MMAL_ES_TYPE_T = 4 ; pub type MMAL_ES_TYPE_T = u32 ; /// Definition of a video format.
/// This describes the properties specific to a video stream
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_VIDEO_FORMAT_T { /// < Width of frame in pixels
 pub width : u32 , /// < Height of frame in rows of pixels
 pub height : u32 , /// < Visible region of the frame
 pub crop : MMAL_RECT_T , /// < Frame rate
 pub frame_rate : MMAL_RATIONAL_T , /// < Pixel aspect ratio
 pub par : MMAL_RATIONAL_T , /// < FourCC specifying the color space of the
    /// video stream. See the \ref MmalColorSpace
    /// "pre-defined color spaces" for some examples.
 pub color_space : MMAL_FOURCC_T , } # [ test ] fn bindgen_test_layout_MMAL_VIDEO_FORMAT_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_VIDEO_FORMAT_T > ( ) , 44usize , concat ! ( "Size of: " , stringify ! ( MMAL_VIDEO_FORMAT_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_VIDEO_FORMAT_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_VIDEO_FORMAT_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VIDEO_FORMAT_T > ( ) ) ) . width as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VIDEO_FORMAT_T ) , "::" , stringify ! ( width ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VIDEO_FORMAT_T > ( ) ) ) . height as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VIDEO_FORMAT_T ) , "::" , stringify ! ( height ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VIDEO_FORMAT_T > ( ) ) ) . crop as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VIDEO_FORMAT_T ) , "::" , stringify ! ( crop ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VIDEO_FORMAT_T > ( ) ) ) . frame_rate as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VIDEO_FORMAT_T ) , "::" , stringify ! ( frame_rate ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VIDEO_FORMAT_T > ( ) ) ) . par as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VIDEO_FORMAT_T ) , "::" , stringify ! ( par ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VIDEO_FORMAT_T > ( ) ) ) . color_space as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VIDEO_FORMAT_T ) , "::" , stringify ! ( color_space ) ) ) ; } /// Definition of an audio format.
/// This describes the properties specific to an audio stream
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_AUDIO_FORMAT_T { /// < Number of audio channels
 pub channels : u32 , /// < Sample rate
 pub sample_rate : u32 , /// < Bits per sample
 pub bits_per_sample : u32 , /// < Size of a block of data
 pub block_align : u32 , } # [ test ] fn bindgen_test_layout_MMAL_AUDIO_FORMAT_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_AUDIO_FORMAT_T > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( MMAL_AUDIO_FORMAT_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_AUDIO_FORMAT_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_AUDIO_FORMAT_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_AUDIO_FORMAT_T > ( ) ) ) . channels as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_AUDIO_FORMAT_T ) , "::" , stringify ! ( channels ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_AUDIO_FORMAT_T > ( ) ) ) . sample_rate as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_AUDIO_FORMAT_T ) , "::" , stringify ! ( sample_rate ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_AUDIO_FORMAT_T > ( ) ) ) . bits_per_sample as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_AUDIO_FORMAT_T ) , "::" , stringify ! ( bits_per_sample ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_AUDIO_FORMAT_T > ( ) ) ) . block_align as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_AUDIO_FORMAT_T ) , "::" , stringify ! ( block_align ) ) ) ; } /// Definition of a subpicture format.
/// This describes the properties specific to a subpicture stream
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_SUBPICTURE_FORMAT_T { /// < Width offset to the start of the subpicture
 pub x_offset : u32 , /// < Height offset to the start of the subpicture
 pub y_offset : u32 , } # [ test ] fn bindgen_test_layout_MMAL_SUBPICTURE_FORMAT_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_SUBPICTURE_FORMAT_T > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( MMAL_SUBPICTURE_FORMAT_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_SUBPICTURE_FORMAT_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_SUBPICTURE_FORMAT_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_SUBPICTURE_FORMAT_T > ( ) ) ) . x_offset as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_SUBPICTURE_FORMAT_T ) , "::" , stringify ! ( x_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_SUBPICTURE_FORMAT_T > ( ) ) ) . y_offset as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_SUBPICTURE_FORMAT_T ) , "::" , stringify ! ( y_offset ) ) ) ; } /// Definition of the type specific format.
/// This describes the type specific information of the elementary stream.
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union MMAL_ES_SPECIFIC_FORMAT_T { /// < Audio specific information
 pub audio : MMAL_AUDIO_FORMAT_T , /// < Video specific information
 pub video : MMAL_VIDEO_FORMAT_T , /// < Subpicture specific information
 pub subpicture : MMAL_SUBPICTURE_FORMAT_T , _bindgen_union_align : [ u32 ; 11usize ] , } # [ test ] fn bindgen_test_layout_MMAL_ES_SPECIFIC_FORMAT_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_ES_SPECIFIC_FORMAT_T > ( ) , 44usize , concat ! ( "Size of: " , stringify ! ( MMAL_ES_SPECIFIC_FORMAT_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_ES_SPECIFIC_FORMAT_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_ES_SPECIFIC_FORMAT_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_ES_SPECIFIC_FORMAT_T > ( ) ) ) . audio as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_ES_SPECIFIC_FORMAT_T ) , "::" , stringify ! ( audio ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_ES_SPECIFIC_FORMAT_T > ( ) ) ) . video as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_ES_SPECIFIC_FORMAT_T ) , "::" , stringify ! ( video ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_ES_SPECIFIC_FORMAT_T > ( ) ) ) . subpicture as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_ES_SPECIFIC_FORMAT_T ) , "::" , stringify ! ( subpicture ) ) ) ; } impl :: std :: fmt :: Debug for MMAL_ES_SPECIFIC_FORMAT_T { fn fmt ( & self , f : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { write ! ( f , "MMAL_ES_SPECIFIC_FORMAT_T {{ union }}" ) } } /// Definition of an elementary stream format
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_ES_FORMAT_T { /// < Type of the elementary stream
 pub type_ : MMAL_ES_TYPE_T , /// < FourCC specifying the encoding of the elementary stream.
    /// See the \ref MmalEncodings "pre-defined encodings" for some
    /// examples.
 pub encoding : MMAL_FOURCC_T , /// < FourCC specifying the specific encoding variant of
    /// the elementary stream. See the \ref MmalEncodingVariants
    /// "pre-defined encoding variants" for some examples.
 pub encoding_variant : MMAL_FOURCC_T , /// < Type specific information for the elementary stream
 pub es : * mut MMAL_ES_SPECIFIC_FORMAT_T , /// < Bitrate in bits per second
 pub bitrate : u32 , /// < Flags describing properties of the elementary stream.
    /// See \ref elementarystreamflags "Elementary stream flags".
 pub flags : u32 , /// < Size of the codec specific data
 pub extradata_size : u32 , /// < Codec specific data
 pub extradata : * mut u8 , } # [ test ] fn bindgen_test_layout_MMAL_ES_FORMAT_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_ES_FORMAT_T > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( MMAL_ES_FORMAT_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_ES_FORMAT_T > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( MMAL_ES_FORMAT_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_ES_FORMAT_T > ( ) ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_ES_FORMAT_T ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_ES_FORMAT_T > ( ) ) ) . encoding as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_ES_FORMAT_T ) , "::" , stringify ! ( encoding ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_ES_FORMAT_T > ( ) ) ) . encoding_variant as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_ES_FORMAT_T ) , "::" , stringify ! ( encoding_variant ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_ES_FORMAT_T > ( ) ) ) . es as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_ES_FORMAT_T ) , "::" , stringify ! ( es ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_ES_FORMAT_T > ( ) ) ) . bitrate as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_ES_FORMAT_T ) , "::" , stringify ! ( bitrate ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_ES_FORMAT_T > ( ) ) ) . flags as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_ES_FORMAT_T ) , "::" , stringify ! ( flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_ES_FORMAT_T > ( ) ) ) . extradata_size as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_ES_FORMAT_T ) , "::" , stringify ! ( extradata_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_ES_FORMAT_T > ( ) ) ) . extradata as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_ES_FORMAT_T ) , "::" , stringify ! ( extradata ) ) ) ; } extern "C" { /// Allocate and initialise a \ref MMAL_ES_FORMAT_T structure.
///
/// @return a \ref MMAL_ES_FORMAT_T structure
 pub fn mmal_format_alloc ( ) -> * mut MMAL_ES_FORMAT_T ; } extern "C" { /// Free a \ref MMAL_ES_FORMAT_T structure allocated by \ref mmal_format_alloc.
///
/// @param format the \ref MMAL_ES_FORMAT_T structure to free
 pub fn mmal_format_free ( format : * mut MMAL_ES_FORMAT_T ) ; } extern "C" { /// Allocate the extradata buffer in \ref MMAL_ES_FORMAT_T.
/// This buffer will be freed automatically when the format is destroyed or
/// another allocation is done.
///
/// @param format format structure for which the extradata buffer will be allocated
/// @param size size of the extradata buffer to allocate
/// @return MMAL_SUCCESS on success
 pub fn mmal_format_extradata_alloc ( format : * mut MMAL_ES_FORMAT_T , size : :: std :: os :: raw :: c_uint ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Shallow copy a format structure.
/// It is worth noting that the extradata buffer will not be copied in the new format.
///
/// @param format_dest destination \ref MMAL_ES_FORMAT_T for the copy
/// @param format_src source \ref MMAL_ES_FORMAT_T for the copy
 pub fn mmal_format_copy ( format_dest : * mut MMAL_ES_FORMAT_T , format_src : * mut MMAL_ES_FORMAT_T ) ; } extern "C" { /// Fully copy a format structure, including the extradata buffer.
///
/// @param format_dest destination \ref MMAL_ES_FORMAT_T for the copy
/// @param format_src source \ref MMAL_ES_FORMAT_T for the copy
/// @return MMAL_SUCCESS on success
 pub fn mmal_format_full_copy ( format_dest : * mut MMAL_ES_FORMAT_T , format_src : * mut MMAL_ES_FORMAT_T ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Compare 2 format structures and returns a set of flags describing the differences.
/// The result will be zero if the structures are the same, or a combination of
/// one or more of the \ref comparisonflags "Comparison flags" if different.
///
/// @param format_1 first \ref MMAL_ES_FORMAT_T to compare
/// @param format_2 second \ref MMAL_ES_FORMAT_T to compare
/// @return set of flags describing the differences
 pub fn mmal_format_compare ( format_1 : * mut MMAL_ES_FORMAT_T , format_2 : * mut MMAL_ES_FORMAT_T ) -> u32 ; } /// Specific data associated with video frames
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T { /// < Number of planes composing the video frame
 pub planes : u32 , /// < Offsets to the different planes. These must point within the
    /// payload buffer
 pub offset : [ u32 ; 4usize ] , /// < Pitch (size in bytes of a line of a plane) of the different
    /// planes
 pub pitch : [ u32 ; 4usize ] , /// < Flags describing video specific properties of a buffer header
    /// (see \ref videobufferheaderflags "Video buffer header flags")
 pub flags : u32 , } # [ test ] fn bindgen_test_layout_MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T > ( ) ) ) . planes as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T ) , "::" , stringify ! ( planes ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T > ( ) ) ) . offset as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T ) , "::" , stringify ! ( offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T > ( ) ) ) . pitch as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T ) , "::" , stringify ! ( pitch ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T > ( ) ) ) . flags as * const _ as usize } , 36usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T ) , "::" , stringify ! ( flags ) ) ) ; } /// Type specific data that's associated with a payload buffer
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T { /// Specific data associated with video frames
 pub video : MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T , _bindgen_union_align : [ u32 ; 10usize ] , } # [ test ] fn bindgen_test_layout_MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T > ( ) ) ) . video as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T ) , "::" , stringify ! ( video ) ) ) ; } impl :: std :: fmt :: Debug for MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T { fn fmt ( & self , f : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { write ! ( f , "MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T {{ union }}" ) } } /// Definition of the buffer header structure.
/// A buffer header does not directly carry the data to be passed to a component but instead
/// it references the actual data using a pointer (and an associated length).
/// It also contains an internal area which can be used to store command or metadata to be
/// associated with the external data.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_BUFFER_HEADER_T { /// < Used to link several buffer headers together
 pub next : * mut MMAL_BUFFER_HEADER_T , /// < Data private to the framework
 pub priv_ : * mut MMAL_BUFFER_HEADER_PRIVATE_T , /// < Defines what the buffer header contains. This is a FourCC
    /// with 0 as a special value meaning stream data
 pub cmd : u32 , /// < Pointer to the start of the payload buffer (should not be
    /// changed by component)
 pub data : * mut u8 , /// < Allocated size in bytes of payload buffer
 pub alloc_size : u32 , /// < Number of bytes currently used in the payload buffer (starting
    /// from offset)
 pub length : u32 , /// < Offset in bytes to the start of valid data in the payload buffer
 pub offset : u32 , /// < Flags describing properties of a buffer header (see
    /// \ref bufferheaderflags "Buffer header flags")
 pub flags : u32 , /// < Presentation timestamp in microseconds. \ref MMAL_TIME_UNKNOWN
    /// is used when the pts is unknown.
 pub pts : i64 , /// < Decode timestamp in microseconds (dts = pts, except in the case
    /// of video streams with B frames). \ref MMAL_TIME_UNKNOWN
    /// is used when the dts is unknown.
 pub dts : i64 , /// Type specific data that's associated with a payload buffer
 pub type_ : * mut MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T , /// < Field reserved for use by the client
 pub user_data : * mut :: std :: os :: raw :: c_void , } # [ test ] fn bindgen_test_layout_MMAL_BUFFER_HEADER_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_BUFFER_HEADER_T > ( ) , 80usize , concat ! ( "Size of: " , stringify ! ( MMAL_BUFFER_HEADER_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_BUFFER_HEADER_T > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( MMAL_BUFFER_HEADER_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_BUFFER_HEADER_T > ( ) ) ) . next as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_BUFFER_HEADER_T ) , "::" , stringify ! ( next ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_BUFFER_HEADER_T > ( ) ) ) . priv_ as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_BUFFER_HEADER_T ) , "::" , stringify ! ( priv_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_BUFFER_HEADER_T > ( ) ) ) . cmd as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_BUFFER_HEADER_T ) , "::" , stringify ! ( cmd ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_BUFFER_HEADER_T > ( ) ) ) . data as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_BUFFER_HEADER_T ) , "::" , stringify ! ( data ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_BUFFER_HEADER_T > ( ) ) ) . alloc_size as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_BUFFER_HEADER_T ) , "::" , stringify ! ( alloc_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_BUFFER_HEADER_T > ( ) ) ) . length as * const _ as usize } , 36usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_BUFFER_HEADER_T ) , "::" , stringify ! ( length ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_BUFFER_HEADER_T > ( ) ) ) . offset as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_BUFFER_HEADER_T ) , "::" , stringify ! ( offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_BUFFER_HEADER_T > ( ) ) ) . flags as * const _ as usize } , 44usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_BUFFER_HEADER_T ) , "::" , stringify ! ( flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_BUFFER_HEADER_T > ( ) ) ) . pts as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_BUFFER_HEADER_T ) , "::" , stringify ! ( pts ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_BUFFER_HEADER_T > ( ) ) ) . dts as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_BUFFER_HEADER_T ) , "::" , stringify ! ( dts ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_BUFFER_HEADER_T > ( ) ) ) . type_ as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_BUFFER_HEADER_T ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_BUFFER_HEADER_T > ( ) ) ) . user_data as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_BUFFER_HEADER_T ) , "::" , stringify ! ( user_data ) ) ) ; } extern "C" { /// Acquire a buffer header.
/// Acquiring a buffer header increases a reference counter on it and makes sure that the
/// buffer header won't be recycled until all the references to it are gone.
/// This is useful for instance if a component needs to return a buffer header but still needs
/// access to it for some internal processing (e.g. reference frames in video codecs).
///
/// @param header buffer header to acquire
 pub fn mmal_buffer_header_acquire ( header : * mut MMAL_BUFFER_HEADER_T ) ; } extern "C" { /// Reset a buffer header.
/// Resets all header variables to default values.
///
/// @param header buffer header to reset
 pub fn mmal_buffer_header_reset ( header : * mut MMAL_BUFFER_HEADER_T ) ; } extern "C" { /// Release a buffer header.
/// Releasing a buffer header will decrease its reference counter and when no more references
/// are left, the buffer header will be recycled by calling its 'release' callback function.
///
/// If a pre-release callback is set (\ref MMAL_BH_PRE_RELEASE_CB_T), this will be invoked
/// before calling the buffer's release callback and potentially postpone buffer recycling.
/// Once pre-release is complete the buffer header is recycled with
/// \ref mmal_buffer_header_release_continue.
///
/// @param header buffer header to release
 pub fn mmal_buffer_header_release ( header : * mut MMAL_BUFFER_HEADER_T ) ; } extern "C" { /// Continue the buffer header release process.
/// This should be called to complete buffer header recycling once all pre-release activity
/// has been completed.
///
/// @param header buffer header to release
 pub fn mmal_buffer_header_release_continue ( header : * mut MMAL_BUFFER_HEADER_T ) ; } /// Buffer header pre-release callback.
/// The callback is invoked just before a buffer is released back into a
/// pool. This is used by clients who need to trigger additional actions
/// before the buffer can finally be released (e.g. wait for a bulk transfer
/// to complete).
///
/// The callback should return TRUE if the buffer release need to be post-poned.
///
/// @param header   buffer header about to be released
/// @param userdata user-specific data
///
/// @return TRUE if the buffer should not be released
 pub type MMAL_BH_PRE_RELEASE_CB_T = :: std :: option :: Option < unsafe extern "C" fn ( header : * mut MMAL_BUFFER_HEADER_T , userdata : * mut :: std :: os :: raw :: c_void ) -> MMAL_BOOL_T > ; extern "C" { /// Set a buffer header pre-release callback.
/// If the callback is NULL, the buffer will be released back into the pool
/// immediately as usual.
///
/// @param header   buffer header to associate callback with
/// @param cb       pre-release callback to invoke
/// @param userdata user-specific data
 pub fn mmal_buffer_header_pre_release_cb_set ( header : * mut MMAL_BUFFER_HEADER_T , cb : MMAL_BH_PRE_RELEASE_CB_T , userdata : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { /// Replicate a buffer header into another one.
/// Replicating a buffer header will not only do an exact copy of all the public fields of the
/// buffer header (including data and alloc_size), but it will also acquire a reference to the
/// source buffer header which will only be released once the replicate has been released.
///
/// @param dest buffer header into which to replicate
/// @param src buffer header to use as the source for the replication
/// @return MMAL_SUCCESS on success
 pub fn mmal_buffer_header_replicate ( dest : * mut MMAL_BUFFER_HEADER_T , src : * mut MMAL_BUFFER_HEADER_T ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Lock the data buffer contained in the buffer header in memory.
/// This call does nothing on all platforms except VideoCore where it is needed to pin a
/// buffer in memory before any access to it.
///
/// @param header buffer header to lock
 pub fn mmal_buffer_header_mem_lock ( header : * mut MMAL_BUFFER_HEADER_T ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Unlock the data buffer contained in the buffer header.
/// This call does nothing on all platforms except VideoCore where it is needed to un-pin a
/// buffer in memory after any access to it.
///
/// @param header buffer header to unlock
 pub fn mmal_buffer_header_mem_unlock ( header : * mut MMAL_BUFFER_HEADER_T ) ; } pub const MMAL_PARAMETER_UNUSED : _bindgen_ty_23 = 0 ; pub const MMAL_PARAMETER_SUPPORTED_ENCODINGS : _bindgen_ty_23 = 1 ; pub const MMAL_PARAMETER_URI : _bindgen_ty_23 = 2 ; pub const MMAL_PARAMETER_CHANGE_EVENT_REQUEST : _bindgen_ty_23 = 3 ; pub const MMAL_PARAMETER_ZERO_COPY : _bindgen_ty_23 = 4 ; pub const MMAL_PARAMETER_BUFFER_REQUIREMENTS : _bindgen_ty_23 = 5 ; pub const MMAL_PARAMETER_STATISTICS : _bindgen_ty_23 = 6 ; pub const MMAL_PARAMETER_CORE_STATISTICS : _bindgen_ty_23 = 7 ; pub const MMAL_PARAMETER_MEM_USAGE : _bindgen_ty_23 = 8 ; pub const MMAL_PARAMETER_BUFFER_FLAG_FILTER : _bindgen_ty_23 = 9 ; pub const MMAL_PARAMETER_SEEK : _bindgen_ty_23 = 10 ; pub const MMAL_PARAMETER_POWERMON_ENABLE : _bindgen_ty_23 = 11 ; pub const MMAL_PARAMETER_LOGGING : _bindgen_ty_23 = 12 ; pub const MMAL_PARAMETER_SYSTEM_TIME : _bindgen_ty_23 = 13 ; pub const MMAL_PARAMETER_NO_IMAGE_PADDING : _bindgen_ty_23 = 14 ; pub const MMAL_PARAMETER_LOCKSTEP_ENABLE : _bindgen_ty_23 = 15 ; pub type _bindgen_ty_23 = u32 ; /// Parameter header type. All parameter structures need to begin with this type.
/// The \ref id field must be set to a parameter ID, such as one of those listed on
/// the \ref MMAL_PARAMETER_IDS "Pre-defined MMAL parameter IDs" page.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_HEADER_T { /// < Parameter ID.
 pub id : u32 , /// < Size in bytes of the parameter (including the header)
 pub size : u32 , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_HEADER_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_HEADER_T > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_HEADER_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_HEADER_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_HEADER_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_HEADER_T > ( ) ) ) . id as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_HEADER_T ) , "::" , stringify ! ( id ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_HEADER_T > ( ) ) ) . size as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_HEADER_T ) , "::" , stringify ! ( size ) ) ) ; } /// Change event request parameter type.
/// This is used to control whether a \ref MMAL_EVENT_PARAMETER_CHANGED_T event
/// is issued should a given parameter change.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < ID of parameter that may change, see \ref MMAL_PARAMETER_IDS
 pub change_id : u32 , /// < True if the event is enabled, false if disabled
 pub enable : MMAL_BOOL_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T > ( ) ) ) . change_id as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T ) , "::" , stringify ! ( change_id ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T > ( ) ) ) . enable as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T ) , "::" , stringify ! ( enable ) ) ) ; } /// Buffer requirements parameter.
/// This is mainly used to increase the requirements of a component.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_BUFFER_REQUIREMENTS_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < Minimum number of buffers the port requires
 pub buffer_num_min : u32 , /// < Minimum size of buffers the port requires
 pub buffer_size_min : u32 , /// < Minimum alignment requirement for the buffers.
    /// A value of zero means no special alignment requirements.
 pub buffer_alignment_min : u32 , /// < Number of buffers the port recommends for optimal performance.
    /// A value of zero means no special recommendation.
 pub buffer_num_recommended : u32 , /// < Size of buffers the port recommends for optimal performance.
    /// A value of zero means no special recommendation.
 pub buffer_size_recommended : u32 , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_BUFFER_REQUIREMENTS_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_BUFFER_REQUIREMENTS_T > ( ) , 28usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_BUFFER_REQUIREMENTS_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_BUFFER_REQUIREMENTS_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_BUFFER_REQUIREMENTS_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_BUFFER_REQUIREMENTS_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_BUFFER_REQUIREMENTS_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_BUFFER_REQUIREMENTS_T > ( ) ) ) . buffer_num_min as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_BUFFER_REQUIREMENTS_T ) , "::" , stringify ! ( buffer_num_min ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_BUFFER_REQUIREMENTS_T > ( ) ) ) . buffer_size_min as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_BUFFER_REQUIREMENTS_T ) , "::" , stringify ! ( buffer_size_min ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_BUFFER_REQUIREMENTS_T > ( ) ) ) . buffer_alignment_min as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_BUFFER_REQUIREMENTS_T ) , "::" , stringify ! ( buffer_alignment_min ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_BUFFER_REQUIREMENTS_T > ( ) ) ) . buffer_num_recommended as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_BUFFER_REQUIREMENTS_T ) , "::" , stringify ! ( buffer_num_recommended ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_BUFFER_REQUIREMENTS_T > ( ) ) ) . buffer_size_recommended as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_BUFFER_REQUIREMENTS_T ) , "::" , stringify ! ( buffer_size_recommended ) ) ) ; } /// Seek request parameter type.
/// This is used to issue a seek request to a source component.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_SEEK_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < Offset (in microseconds) to seek to
 pub offset : i64 , /// < Seeking flags
 pub flags : u32 , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_SEEK_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_SEEK_T > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_SEEK_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_SEEK_T > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_SEEK_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_SEEK_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_SEEK_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_SEEK_T > ( ) ) ) . offset as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_SEEK_T ) , "::" , stringify ! ( offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_SEEK_T > ( ) ) ) . flags as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_SEEK_T ) , "::" , stringify ! ( flags ) ) ) ; } /// Port statistics for debugging/test purposes.
/// Ports may support query of this parameter to return statistics for debugging or
/// test purposes. Not all values may be relevant for a given port.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_STATISTICS_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < Total number of buffers processed
 pub buffer_count : u32 , /// < Total number of frames processed
 pub frame_count : u32 , /// < Number of frames without expected PTS based on frame rate
 pub frames_skipped : u32 , /// < Number of frames discarded
 pub frames_discarded : u32 , /// < Set if the end of stream has been reached
 pub eos_seen : u32 , /// < Maximum frame size in bytes
 pub maximum_frame_bytes : u32 , /// < Total number of bytes processed
 pub total_bytes : i64 , /// < Number of corrupt macroblocks in the stream
 pub corrupt_macroblocks : u32 , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_STATISTICS_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_STATISTICS_T > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_STATISTICS_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_STATISTICS_T > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_STATISTICS_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_STATISTICS_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_STATISTICS_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_STATISTICS_T > ( ) ) ) . buffer_count as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_STATISTICS_T ) , "::" , stringify ! ( buffer_count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_STATISTICS_T > ( ) ) ) . frame_count as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_STATISTICS_T ) , "::" , stringify ! ( frame_count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_STATISTICS_T > ( ) ) ) . frames_skipped as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_STATISTICS_T ) , "::" , stringify ! ( frames_skipped ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_STATISTICS_T > ( ) ) ) . frames_discarded as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_STATISTICS_T ) , "::" , stringify ! ( frames_discarded ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_STATISTICS_T > ( ) ) ) . eos_seen as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_STATISTICS_T ) , "::" , stringify ! ( eos_seen ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_STATISTICS_T > ( ) ) ) . maximum_frame_bytes as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_STATISTICS_T ) , "::" , stringify ! ( maximum_frame_bytes ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_STATISTICS_T > ( ) ) ) . total_bytes as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_STATISTICS_T ) , "::" , stringify ! ( total_bytes ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_STATISTICS_T > ( ) ) ) . corrupt_macroblocks as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_STATISTICS_T ) , "::" , stringify ! ( corrupt_macroblocks ) ) ) ; } pub const MMAL_CORE_STATS_DIR_MMAL_CORE_STATS_RX : MMAL_CORE_STATS_DIR = 0 ; pub const MMAL_CORE_STATS_DIR_MMAL_CORE_STATS_TX : MMAL_CORE_STATS_DIR = 1 ; pub const MMAL_CORE_STATS_DIR_MMAL_CORE_STATS_MAX : MMAL_CORE_STATS_DIR = 2147483647 ; pub type MMAL_CORE_STATS_DIR = u32 ; /// MMAL core statistics. These are collected by the core itself.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_CORE_STATISTICS_T { pub hdr : MMAL_PARAMETER_HEADER_T , pub dir : MMAL_CORE_STATS_DIR , /// < Reset to zero after reading
 pub reset : MMAL_BOOL_T , /// < The statistics
 pub stats : MMAL_CORE_STATISTICS_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_CORE_STATISTICS_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_CORE_STATISTICS_T > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_CORE_STATISTICS_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_CORE_STATISTICS_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_CORE_STATISTICS_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CORE_STATISTICS_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CORE_STATISTICS_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CORE_STATISTICS_T > ( ) ) ) . dir as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CORE_STATISTICS_T ) , "::" , stringify ! ( dir ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CORE_STATISTICS_T > ( ) ) ) . reset as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CORE_STATISTICS_T ) , "::" , stringify ! ( reset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CORE_STATISTICS_T > ( ) ) ) . stats as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CORE_STATISTICS_T ) , "::" , stringify ! ( stats ) ) ) ; } /// Component memory usage statistics.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_MEM_USAGE_T { pub hdr : MMAL_PARAMETER_HEADER_T , pub pool_mem_alloc_size : u32 , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_MEM_USAGE_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_MEM_USAGE_T > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_MEM_USAGE_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_MEM_USAGE_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_MEM_USAGE_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_MEM_USAGE_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_MEM_USAGE_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_MEM_USAGE_T > ( ) ) ) . pool_mem_alloc_size as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_MEM_USAGE_T ) , "::" , stringify ! ( pool_mem_alloc_size ) ) ) ; } /// Logging control.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_LOGGING_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < Logging bits to set
 pub set : u32 , /// < Logging bits to clear
 pub clear : u32 , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_LOGGING_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_LOGGING_T > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_LOGGING_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_LOGGING_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_LOGGING_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_LOGGING_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_LOGGING_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_LOGGING_T > ( ) ) ) . set as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_LOGGING_T ) , "::" , stringify ! ( set ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_LOGGING_T > ( ) ) ) . clear as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_LOGGING_T ) , "::" , stringify ! ( clear ) ) ) ; } pub const MMAL_PARAMETER_THUMBNAIL_CONFIGURATION : _bindgen_ty_24 = 65536 ; pub const MMAL_PARAMETER_CAPTURE_QUALITY : _bindgen_ty_24 = 65537 ; pub const MMAL_PARAMETER_ROTATION : _bindgen_ty_24 = 65538 ; pub const MMAL_PARAMETER_EXIF_DISABLE : _bindgen_ty_24 = 65539 ; pub const MMAL_PARAMETER_EXIF : _bindgen_ty_24 = 65540 ; pub const MMAL_PARAMETER_AWB_MODE : _bindgen_ty_24 = 65541 ; pub const MMAL_PARAMETER_IMAGE_EFFECT : _bindgen_ty_24 = 65542 ; pub const MMAL_PARAMETER_COLOUR_EFFECT : _bindgen_ty_24 = 65543 ; pub const MMAL_PARAMETER_FLICKER_AVOID : _bindgen_ty_24 = 65544 ; pub const MMAL_PARAMETER_FLASH : _bindgen_ty_24 = 65545 ; pub const MMAL_PARAMETER_REDEYE : _bindgen_ty_24 = 65546 ; pub const MMAL_PARAMETER_FOCUS : _bindgen_ty_24 = 65547 ; pub const MMAL_PARAMETER_FOCAL_LENGTHS : _bindgen_ty_24 = 65548 ; pub const MMAL_PARAMETER_EXPOSURE_COMP : _bindgen_ty_24 = 65549 ; pub const MMAL_PARAMETER_ZOOM : _bindgen_ty_24 = 65550 ; pub const MMAL_PARAMETER_MIRROR : _bindgen_ty_24 = 65551 ; pub const MMAL_PARAMETER_CAMERA_NUM : _bindgen_ty_24 = 65552 ; pub const MMAL_PARAMETER_CAPTURE : _bindgen_ty_24 = 65553 ; pub const MMAL_PARAMETER_EXPOSURE_MODE : _bindgen_ty_24 = 65554 ; pub const MMAL_PARAMETER_EXP_METERING_MODE : _bindgen_ty_24 = 65555 ; pub const MMAL_PARAMETER_FOCUS_STATUS : _bindgen_ty_24 = 65556 ; pub const MMAL_PARAMETER_CAMERA_CONFIG : _bindgen_ty_24 = 65557 ; pub const MMAL_PARAMETER_CAPTURE_STATUS : _bindgen_ty_24 = 65558 ; pub const MMAL_PARAMETER_FACE_TRACK : _bindgen_ty_24 = 65559 ; pub const MMAL_PARAMETER_DRAW_BOX_FACES_AND_FOCUS : _bindgen_ty_24 = 65560 ; pub const MMAL_PARAMETER_JPEG_Q_FACTOR : _bindgen_ty_24 = 65561 ; pub const MMAL_PARAMETER_FRAME_RATE : _bindgen_ty_24 = 65562 ; pub const MMAL_PARAMETER_USE_STC : _bindgen_ty_24 = 65563 ; pub const MMAL_PARAMETER_CAMERA_INFO : _bindgen_ty_24 = 65564 ; pub const MMAL_PARAMETER_VIDEO_STABILISATION : _bindgen_ty_24 = 65565 ; pub const MMAL_PARAMETER_FACE_TRACK_RESULTS : _bindgen_ty_24 = 65566 ; pub const MMAL_PARAMETER_ENABLE_RAW_CAPTURE : _bindgen_ty_24 = 65567 ; pub const MMAL_PARAMETER_DPF_FILE : _bindgen_ty_24 = 65568 ; pub const MMAL_PARAMETER_ENABLE_DPF_FILE : _bindgen_ty_24 = 65569 ; pub const MMAL_PARAMETER_DPF_FAIL_IS_FATAL : _bindgen_ty_24 = 65570 ; pub const MMAL_PARAMETER_CAPTURE_MODE : _bindgen_ty_24 = 65571 ; pub const MMAL_PARAMETER_FOCUS_REGIONS : _bindgen_ty_24 = 65572 ; pub const MMAL_PARAMETER_INPUT_CROP : _bindgen_ty_24 = 65573 ; pub const MMAL_PARAMETER_SENSOR_INFORMATION : _bindgen_ty_24 = 65574 ; pub const MMAL_PARAMETER_FLASH_SELECT : _bindgen_ty_24 = 65575 ; pub const MMAL_PARAMETER_FIELD_OF_VIEW : _bindgen_ty_24 = 65576 ; pub const MMAL_PARAMETER_HIGH_DYNAMIC_RANGE : _bindgen_ty_24 = 65577 ; pub const MMAL_PARAMETER_DYNAMIC_RANGE_COMPRESSION : _bindgen_ty_24 = 65578 ; pub const MMAL_PARAMETER_ALGORITHM_CONTROL : _bindgen_ty_24 = 65579 ; pub const MMAL_PARAMETER_SHARPNESS : _bindgen_ty_24 = 65580 ; pub const MMAL_PARAMETER_CONTRAST : _bindgen_ty_24 = 65581 ; pub const MMAL_PARAMETER_BRIGHTNESS : _bindgen_ty_24 = 65582 ; pub const MMAL_PARAMETER_SATURATION : _bindgen_ty_24 = 65583 ; pub const MMAL_PARAMETER_ISO : _bindgen_ty_24 = 65584 ; pub const MMAL_PARAMETER_ANTISHAKE : _bindgen_ty_24 = 65585 ; pub const MMAL_PARAMETER_IMAGE_EFFECT_PARAMETERS : _bindgen_ty_24 = 65586 ; pub const MMAL_PARAMETER_CAMERA_BURST_CAPTURE : _bindgen_ty_24 = 65587 ; pub const MMAL_PARAMETER_CAMERA_MIN_ISO : _bindgen_ty_24 = 65588 ; pub const MMAL_PARAMETER_CAMERA_USE_CASE : _bindgen_ty_24 = 65589 ; pub const MMAL_PARAMETER_CAPTURE_STATS_PASS : _bindgen_ty_24 = 65590 ; pub const MMAL_PARAMETER_CAMERA_CUSTOM_SENSOR_CONFIG : _bindgen_ty_24 = 65591 ; pub const MMAL_PARAMETER_ENABLE_REGISTER_FILE : _bindgen_ty_24 = 65592 ; pub const MMAL_PARAMETER_REGISTER_FAIL_IS_FATAL : _bindgen_ty_24 = 65593 ; pub const MMAL_PARAMETER_CONFIGFILE_REGISTERS : _bindgen_ty_24 = 65594 ; pub const MMAL_PARAMETER_CONFIGFILE_CHUNK_REGISTERS : _bindgen_ty_24 = 65595 ; pub const MMAL_PARAMETER_JPEG_ATTACH_LOG : _bindgen_ty_24 = 65596 ; pub const MMAL_PARAMETER_ZERO_SHUTTER_LAG : _bindgen_ty_24 = 65597 ; pub const MMAL_PARAMETER_FPS_RANGE : _bindgen_ty_24 = 65598 ; pub const MMAL_PARAMETER_CAPTURE_EXPOSURE_COMP : _bindgen_ty_24 = 65599 ; pub const MMAL_PARAMETER_SW_SHARPEN_DISABLE : _bindgen_ty_24 = 65600 ; pub const MMAL_PARAMETER_FLASH_REQUIRED : _bindgen_ty_24 = 65601 ; pub const MMAL_PARAMETER_SW_SATURATION_DISABLE : _bindgen_ty_24 = 65602 ; pub const MMAL_PARAMETER_SHUTTER_SPEED : _bindgen_ty_24 = 65603 ; pub const MMAL_PARAMETER_CUSTOM_AWB_GAINS : _bindgen_ty_24 = 65604 ; pub const MMAL_PARAMETER_CAMERA_SETTINGS : _bindgen_ty_24 = 65605 ; pub const MMAL_PARAMETER_PRIVACY_INDICATOR : _bindgen_ty_24 = 65606 ; pub const MMAL_PARAMETER_VIDEO_DENOISE : _bindgen_ty_24 = 65607 ; pub const MMAL_PARAMETER_STILLS_DENOISE : _bindgen_ty_24 = 65608 ; pub const MMAL_PARAMETER_ANNOTATE : _bindgen_ty_24 = 65609 ; pub const MMAL_PARAMETER_STEREOSCOPIC_MODE : _bindgen_ty_24 = 65610 ; pub const MMAL_PARAMETER_CAMERA_INTERFACE : _bindgen_ty_24 = 65611 ; pub const MMAL_PARAMETER_CAMERA_CLOCKING_MODE : _bindgen_ty_24 = 65612 ; pub const MMAL_PARAMETER_CAMERA_RX_CONFIG : _bindgen_ty_24 = 65613 ; pub const MMAL_PARAMETER_CAMERA_RX_TIMING : _bindgen_ty_24 = 65614 ; pub const MMAL_PARAMETER_DPF_CONFIG : _bindgen_ty_24 = 65615 ; pub const MMAL_PARAMETER_JPEG_RESTART_INTERVAL : _bindgen_ty_24 = 65616 ; pub const MMAL_PARAMETER_CAMERA_ISP_BLOCK_OVERRIDE : _bindgen_ty_24 = 65617 ; pub const MMAL_PARAMETER_LENS_SHADING_OVERRIDE : _bindgen_ty_24 = 65618 ; pub const MMAL_PARAMETER_BLACK_LEVEL : _bindgen_ty_24 = 65619 ; pub const MMAL_PARAMETER_RESIZE_PARAMS : _bindgen_ty_24 = 65620 ; pub const MMAL_PARAMETER_CROP : _bindgen_ty_24 = 65621 ; pub const MMAL_PARAMETER_OUTPUT_SHIFT : _bindgen_ty_24 = 65622 ; pub const MMAL_PARAMETER_CCM_SHIFT : _bindgen_ty_24 = 65623 ; pub const MMAL_PARAMETER_CUSTOM_CCM : _bindgen_ty_24 = 65624 ; pub const MMAL_PARAMETER_ANALOG_GAIN : _bindgen_ty_24 = 65625 ; pub const MMAL_PARAMETER_DIGITAL_GAIN : _bindgen_ty_24 = 65626 ; pub type _bindgen_ty_24 = u32 ; /// Thumbnail configuration parameter type
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_THUMBNAIL_CONFIG_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < Enable generation of thumbnails during still capture
 pub enable : u32 , /// < Desired width of the thumbnail
 pub width : u32 , /// < Desired height of the thumbnail
 pub height : u32 , /// < Desired compression quality of the thumbnail
 pub quality : u32 , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_THUMBNAIL_CONFIG_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_THUMBNAIL_CONFIG_T > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_THUMBNAIL_CONFIG_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_THUMBNAIL_CONFIG_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_THUMBNAIL_CONFIG_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_THUMBNAIL_CONFIG_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_THUMBNAIL_CONFIG_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_THUMBNAIL_CONFIG_T > ( ) ) ) . enable as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_THUMBNAIL_CONFIG_T ) , "::" , stringify ! ( enable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_THUMBNAIL_CONFIG_T > ( ) ) ) . width as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_THUMBNAIL_CONFIG_T ) , "::" , stringify ! ( width ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_THUMBNAIL_CONFIG_T > ( ) ) ) . height as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_THUMBNAIL_CONFIG_T ) , "::" , stringify ! ( height ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_THUMBNAIL_CONFIG_T > ( ) ) ) . quality as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_THUMBNAIL_CONFIG_T ) , "::" , stringify ! ( quality ) ) ) ; } /// EXIF parameter type.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_EXIF_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < If 0, assume key is terminated by '=', otherwise length of key and treat data as binary
 pub keylen : u32 , /// < Offset within data buffer of the start of the value. If 0, look for a "key=value" string
 pub value_offset : u32 , /// < If 0, assume value is null-terminated, otherwise length of value and treat data as binary
 pub valuelen : u32 , /// < EXIF key/value string. Variable length
 pub data : [ u8 ; 1usize ] , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_EXIF_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_EXIF_T > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_EXIF_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_EXIF_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_EXIF_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_EXIF_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_EXIF_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_EXIF_T > ( ) ) ) . keylen as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_EXIF_T ) , "::" , stringify ! ( keylen ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_EXIF_T > ( ) ) ) . value_offset as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_EXIF_T ) , "::" , stringify ! ( value_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_EXIF_T > ( ) ) ) . valuelen as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_EXIF_T ) , "::" , stringify ! ( valuelen ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_EXIF_T > ( ) ) ) . data as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_EXIF_T ) , "::" , stringify ! ( data ) ) ) ; } pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_OFF : MMAL_PARAM_EXPOSUREMODE_T = 0 ; pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_AUTO : MMAL_PARAM_EXPOSUREMODE_T = 1 ; pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_NIGHT : MMAL_PARAM_EXPOSUREMODE_T = 2 ; pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_NIGHTPREVIEW : MMAL_PARAM_EXPOSUREMODE_T = 3 ; pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_BACKLIGHT : MMAL_PARAM_EXPOSUREMODE_T = 4 ; pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_SPOTLIGHT : MMAL_PARAM_EXPOSUREMODE_T = 5 ; pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_SPORTS : MMAL_PARAM_EXPOSUREMODE_T = 6 ; pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_SNOW : MMAL_PARAM_EXPOSUREMODE_T = 7 ; pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_BEACH : MMAL_PARAM_EXPOSUREMODE_T = 8 ; pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_VERYLONG : MMAL_PARAM_EXPOSUREMODE_T = 9 ; pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_FIXEDFPS : MMAL_PARAM_EXPOSUREMODE_T = 10 ; pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_ANTISHAKE : MMAL_PARAM_EXPOSUREMODE_T = 11 ; pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_FIREWORKS : MMAL_PARAM_EXPOSUREMODE_T = 12 ; pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_MAX : MMAL_PARAM_EXPOSUREMODE_T = 2147483647 ; pub type MMAL_PARAM_EXPOSUREMODE_T = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_EXPOSUREMODE_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < exposure mode
 pub value : MMAL_PARAM_EXPOSUREMODE_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_EXPOSUREMODE_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_EXPOSUREMODE_T > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_EXPOSUREMODE_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_EXPOSUREMODE_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_EXPOSUREMODE_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_EXPOSUREMODE_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_EXPOSUREMODE_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_EXPOSUREMODE_T > ( ) ) ) . value as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_EXPOSUREMODE_T ) , "::" , stringify ! ( value ) ) ) ; } pub const MMAL_PARAM_EXPOSUREMETERINGMODE_T_MMAL_PARAM_EXPOSUREMETERINGMODE_AVERAGE : MMAL_PARAM_EXPOSUREMETERINGMODE_T = 0 ; pub const MMAL_PARAM_EXPOSUREMETERINGMODE_T_MMAL_PARAM_EXPOSUREMETERINGMODE_SPOT : MMAL_PARAM_EXPOSUREMETERINGMODE_T = 1 ; pub const MMAL_PARAM_EXPOSUREMETERINGMODE_T_MMAL_PARAM_EXPOSUREMETERINGMODE_BACKLIT : MMAL_PARAM_EXPOSUREMETERINGMODE_T = 2 ; pub const MMAL_PARAM_EXPOSUREMETERINGMODE_T_MMAL_PARAM_EXPOSUREMETERINGMODE_MATRIX : MMAL_PARAM_EXPOSUREMETERINGMODE_T = 3 ; pub const MMAL_PARAM_EXPOSUREMETERINGMODE_T_MMAL_PARAM_EXPOSUREMETERINGMODE_MAX : MMAL_PARAM_EXPOSUREMETERINGMODE_T = 2147483647 ; pub type MMAL_PARAM_EXPOSUREMETERINGMODE_T = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_EXPOSUREMETERINGMODE_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < metering mode
 pub value : MMAL_PARAM_EXPOSUREMETERINGMODE_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_EXPOSUREMETERINGMODE_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_EXPOSUREMETERINGMODE_T > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_EXPOSUREMETERINGMODE_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_EXPOSUREMETERINGMODE_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_EXPOSUREMETERINGMODE_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_EXPOSUREMETERINGMODE_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_EXPOSUREMETERINGMODE_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_EXPOSUREMETERINGMODE_T > ( ) ) ) . value as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_EXPOSUREMETERINGMODE_T ) , "::" , stringify ! ( value ) ) ) ; } pub const MMAL_PARAM_AWBMODE_T_MMAL_PARAM_AWBMODE_OFF : MMAL_PARAM_AWBMODE_T = 0 ; pub const MMAL_PARAM_AWBMODE_T_MMAL_PARAM_AWBMODE_AUTO : MMAL_PARAM_AWBMODE_T = 1 ; pub const MMAL_PARAM_AWBMODE_T_MMAL_PARAM_AWBMODE_SUNLIGHT : MMAL_PARAM_AWBMODE_T = 2 ; pub const MMAL_PARAM_AWBMODE_T_MMAL_PARAM_AWBMODE_CLOUDY : MMAL_PARAM_AWBMODE_T = 3 ; pub const MMAL_PARAM_AWBMODE_T_MMAL_PARAM_AWBMODE_SHADE : MMAL_PARAM_AWBMODE_T = 4 ; pub const MMAL_PARAM_AWBMODE_T_MMAL_PARAM_AWBMODE_TUNGSTEN : MMAL_PARAM_AWBMODE_T = 5 ; pub const MMAL_PARAM_AWBMODE_T_MMAL_PARAM_AWBMODE_FLUORESCENT : MMAL_PARAM_AWBMODE_T = 6 ; pub const MMAL_PARAM_AWBMODE_T_MMAL_PARAM_AWBMODE_INCANDESCENT : MMAL_PARAM_AWBMODE_T = 7 ; pub const MMAL_PARAM_AWBMODE_T_MMAL_PARAM_AWBMODE_FLASH : MMAL_PARAM_AWBMODE_T = 8 ; pub const MMAL_PARAM_AWBMODE_T_MMAL_PARAM_AWBMODE_HORIZON : MMAL_PARAM_AWBMODE_T = 9 ; pub const MMAL_PARAM_AWBMODE_T_MMAL_PARAM_AWBMODE_MAX : MMAL_PARAM_AWBMODE_T = 2147483647 ; pub type MMAL_PARAM_AWBMODE_T = u32 ; /// AWB parameter type.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_AWBMODE_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < AWB mode
 pub value : MMAL_PARAM_AWBMODE_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_AWBMODE_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_AWBMODE_T > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_AWBMODE_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_AWBMODE_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_AWBMODE_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_AWBMODE_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_AWBMODE_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_AWBMODE_T > ( ) ) ) . value as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_AWBMODE_T ) , "::" , stringify ! ( value ) ) ) ; } pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_NONE : MMAL_PARAM_IMAGEFX_T = 0 ; pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_NEGATIVE : MMAL_PARAM_IMAGEFX_T = 1 ; pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_SOLARIZE : MMAL_PARAM_IMAGEFX_T = 2 ; pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_POSTERIZE : MMAL_PARAM_IMAGEFX_T = 3 ; pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_WHITEBOARD : MMAL_PARAM_IMAGEFX_T = 4 ; pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_BLACKBOARD : MMAL_PARAM_IMAGEFX_T = 5 ; pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_SKETCH : MMAL_PARAM_IMAGEFX_T = 6 ; pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_DENOISE : MMAL_PARAM_IMAGEFX_T = 7 ; pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_EMBOSS : MMAL_PARAM_IMAGEFX_T = 8 ; pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_OILPAINT : MMAL_PARAM_IMAGEFX_T = 9 ; pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_HATCH : MMAL_PARAM_IMAGEFX_T = 10 ; pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_GPEN : MMAL_PARAM_IMAGEFX_T = 11 ; pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_PASTEL : MMAL_PARAM_IMAGEFX_T = 12 ; pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_WATERCOLOUR : MMAL_PARAM_IMAGEFX_T = 13 ; pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_FILM : MMAL_PARAM_IMAGEFX_T = 14 ; pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_BLUR : MMAL_PARAM_IMAGEFX_T = 15 ; pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_SATURATION : MMAL_PARAM_IMAGEFX_T = 16 ; pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_COLOURSWAP : MMAL_PARAM_IMAGEFX_T = 17 ; pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_WASHEDOUT : MMAL_PARAM_IMAGEFX_T = 18 ; pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_POSTERISE : MMAL_PARAM_IMAGEFX_T = 19 ; pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_COLOURPOINT : MMAL_PARAM_IMAGEFX_T = 20 ; pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_COLOURBALANCE : MMAL_PARAM_IMAGEFX_T = 21 ; pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_CARTOON : MMAL_PARAM_IMAGEFX_T = 22 ; pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_DEINTERLACE_DOUBLE : MMAL_PARAM_IMAGEFX_T = 23 ; pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_DEINTERLACE_ADV : MMAL_PARAM_IMAGEFX_T = 24 ; pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_DEINTERLACE_FAST : MMAL_PARAM_IMAGEFX_T = 25 ; pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_MAX : MMAL_PARAM_IMAGEFX_T = 2147483647 ; pub type MMAL_PARAM_IMAGEFX_T = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_IMAGEFX_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < Image effect mode
 pub value : MMAL_PARAM_IMAGEFX_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_IMAGEFX_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_IMAGEFX_T > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_IMAGEFX_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_IMAGEFX_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_IMAGEFX_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_IMAGEFX_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_IMAGEFX_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_IMAGEFX_T > ( ) ) ) . value as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_IMAGEFX_T ) , "::" , stringify ! ( value ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_IMAGEFX_PARAMETERS_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < Image effect mode
 pub effect : MMAL_PARAM_IMAGEFX_T , /// < Number of used elements in
 pub num_effect_params : u32 , /// < Array of parameters
 pub effect_parameter : [ u32 ; 6usize ] , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_IMAGEFX_PARAMETERS_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_IMAGEFX_PARAMETERS_T > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_IMAGEFX_PARAMETERS_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_IMAGEFX_PARAMETERS_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_IMAGEFX_PARAMETERS_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_IMAGEFX_PARAMETERS_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_IMAGEFX_PARAMETERS_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_IMAGEFX_PARAMETERS_T > ( ) ) ) . effect as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_IMAGEFX_PARAMETERS_T ) , "::" , stringify ! ( effect ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_IMAGEFX_PARAMETERS_T > ( ) ) ) . num_effect_params as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_IMAGEFX_PARAMETERS_T ) , "::" , stringify ! ( num_effect_params ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_IMAGEFX_PARAMETERS_T > ( ) ) ) . effect_parameter as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_IMAGEFX_PARAMETERS_T ) , "::" , stringify ! ( effect_parameter ) ) ) ; } /// Colour effect parameter type
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_COLOURFX_T { pub hdr : MMAL_PARAMETER_HEADER_T , pub enable : i32 , pub u : u32 , pub v : u32 , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_COLOURFX_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_COLOURFX_T > ( ) , 20usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_COLOURFX_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_COLOURFX_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_COLOURFX_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_COLOURFX_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_COLOURFX_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_COLOURFX_T > ( ) ) ) . enable as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_COLOURFX_T ) , "::" , stringify ! ( enable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_COLOURFX_T > ( ) ) ) . u as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_COLOURFX_T ) , "::" , stringify ! ( u ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_COLOURFX_T > ( ) ) ) . v as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_COLOURFX_T ) , "::" , stringify ! ( v ) ) ) ; } pub const MMAL_CAMERA_STC_MODE_T_MMAL_PARAM_STC_MODE_OFF : MMAL_CAMERA_STC_MODE_T = 0 ; pub const MMAL_CAMERA_STC_MODE_T_MMAL_PARAM_STC_MODE_RAW : MMAL_CAMERA_STC_MODE_T = 1 ; pub const MMAL_CAMERA_STC_MODE_T_MMAL_PARAM_STC_MODE_COOKED : MMAL_CAMERA_STC_MODE_T = 2 ; pub const MMAL_CAMERA_STC_MODE_T_MMAL_PARAM_STC_MODE_MAX : MMAL_CAMERA_STC_MODE_T = 2147483647 ; pub type MMAL_CAMERA_STC_MODE_T = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_CAMERA_STC_MODE_T { pub hdr : MMAL_PARAMETER_HEADER_T , pub value : MMAL_CAMERA_STC_MODE_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_STC_MODE_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_CAMERA_STC_MODE_T > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_CAMERA_STC_MODE_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_CAMERA_STC_MODE_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_CAMERA_STC_MODE_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_STC_MODE_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_STC_MODE_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_STC_MODE_T > ( ) ) ) . value as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_STC_MODE_T ) , "::" , stringify ! ( value ) ) ) ; } pub const MMAL_PARAM_FLICKERAVOID_T_MMAL_PARAM_FLICKERAVOID_OFF : MMAL_PARAM_FLICKERAVOID_T = 0 ; pub const MMAL_PARAM_FLICKERAVOID_T_MMAL_PARAM_FLICKERAVOID_AUTO : MMAL_PARAM_FLICKERAVOID_T = 1 ; pub const MMAL_PARAM_FLICKERAVOID_T_MMAL_PARAM_FLICKERAVOID_50HZ : MMAL_PARAM_FLICKERAVOID_T = 2 ; pub const MMAL_PARAM_FLICKERAVOID_T_MMAL_PARAM_FLICKERAVOID_60HZ : MMAL_PARAM_FLICKERAVOID_T = 3 ; pub const MMAL_PARAM_FLICKERAVOID_T_MMAL_PARAM_FLICKERAVOID_MAX : MMAL_PARAM_FLICKERAVOID_T = 2147483647 ; pub type MMAL_PARAM_FLICKERAVOID_T = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_FLICKERAVOID_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < Flicker avoidance mode
 pub value : MMAL_PARAM_FLICKERAVOID_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_FLICKERAVOID_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_FLICKERAVOID_T > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_FLICKERAVOID_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_FLICKERAVOID_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_FLICKERAVOID_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FLICKERAVOID_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FLICKERAVOID_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FLICKERAVOID_T > ( ) ) ) . value as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FLICKERAVOID_T ) , "::" , stringify ! ( value ) ) ) ; } pub const MMAL_PARAM_FLASH_T_MMAL_PARAM_FLASH_OFF : MMAL_PARAM_FLASH_T = 0 ; pub const MMAL_PARAM_FLASH_T_MMAL_PARAM_FLASH_AUTO : MMAL_PARAM_FLASH_T = 1 ; pub const MMAL_PARAM_FLASH_T_MMAL_PARAM_FLASH_ON : MMAL_PARAM_FLASH_T = 2 ; pub const MMAL_PARAM_FLASH_T_MMAL_PARAM_FLASH_REDEYE : MMAL_PARAM_FLASH_T = 3 ; pub const MMAL_PARAM_FLASH_T_MMAL_PARAM_FLASH_FILLIN : MMAL_PARAM_FLASH_T = 4 ; pub const MMAL_PARAM_FLASH_T_MMAL_PARAM_FLASH_TORCH : MMAL_PARAM_FLASH_T = 5 ; pub const MMAL_PARAM_FLASH_T_MMAL_PARAM_FLASH_MAX : MMAL_PARAM_FLASH_T = 2147483647 ; pub type MMAL_PARAM_FLASH_T = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_FLASH_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < Flash mode
 pub value : MMAL_PARAM_FLASH_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_FLASH_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_FLASH_T > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_FLASH_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_FLASH_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_FLASH_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FLASH_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FLASH_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FLASH_T > ( ) ) ) . value as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FLASH_T ) , "::" , stringify ! ( value ) ) ) ; } pub const MMAL_PARAM_REDEYE_T_MMAL_PARAM_REDEYE_OFF : MMAL_PARAM_REDEYE_T = 0 ; pub const MMAL_PARAM_REDEYE_T_MMAL_PARAM_REDEYE_ON : MMAL_PARAM_REDEYE_T = 1 ; pub const MMAL_PARAM_REDEYE_T_MMAL_PARAM_REDEYE_SIMPLE : MMAL_PARAM_REDEYE_T = 2 ; pub const MMAL_PARAM_REDEYE_T_MMAL_PARAM_REDEYE_MAX : MMAL_PARAM_REDEYE_T = 2147483647 ; pub type MMAL_PARAM_REDEYE_T = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_REDEYE_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < Red eye reduction mode
 pub value : MMAL_PARAM_REDEYE_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_REDEYE_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_REDEYE_T > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_REDEYE_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_REDEYE_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_REDEYE_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_REDEYE_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_REDEYE_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_REDEYE_T > ( ) ) ) . value as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_REDEYE_T ) , "::" , stringify ! ( value ) ) ) ; } pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_AUTO : MMAL_PARAM_FOCUS_T = 0 ; pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_AUTO_NEAR : MMAL_PARAM_FOCUS_T = 1 ; pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_AUTO_MACRO : MMAL_PARAM_FOCUS_T = 2 ; pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_CAF : MMAL_PARAM_FOCUS_T = 3 ; pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_CAF_NEAR : MMAL_PARAM_FOCUS_T = 4 ; pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_FIXED_INFINITY : MMAL_PARAM_FOCUS_T = 5 ; pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_FIXED_HYPERFOCAL : MMAL_PARAM_FOCUS_T = 6 ; pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_FIXED_NEAR : MMAL_PARAM_FOCUS_T = 7 ; pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_FIXED_MACRO : MMAL_PARAM_FOCUS_T = 8 ; pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_EDOF : MMAL_PARAM_FOCUS_T = 9 ; pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_CAF_MACRO : MMAL_PARAM_FOCUS_T = 10 ; pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_CAF_FAST : MMAL_PARAM_FOCUS_T = 11 ; pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_CAF_NEAR_FAST : MMAL_PARAM_FOCUS_T = 12 ; pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_CAF_MACRO_FAST : MMAL_PARAM_FOCUS_T = 13 ; pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_FIXED_CURRENT : MMAL_PARAM_FOCUS_T = 14 ; pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_MAX : MMAL_PARAM_FOCUS_T = 2147483647 ; pub type MMAL_PARAM_FOCUS_T = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_FOCUS_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < Focus mode
 pub value : MMAL_PARAM_FOCUS_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_FOCUS_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_FOCUS_T > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_FOCUS_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_FOCUS_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_FOCUS_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FOCUS_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FOCUS_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FOCUS_T > ( ) ) ) . value as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FOCUS_T ) , "::" , stringify ! ( value ) ) ) ; } pub const MMAL_PARAM_CAPTURE_STATUS_T_MMAL_PARAM_CAPTURE_STATUS_NOT_CAPTURING : MMAL_PARAM_CAPTURE_STATUS_T = 0 ; pub const MMAL_PARAM_CAPTURE_STATUS_T_MMAL_PARAM_CAPTURE_STATUS_CAPTURE_STARTED : MMAL_PARAM_CAPTURE_STATUS_T = 1 ; pub const MMAL_PARAM_CAPTURE_STATUS_T_MMAL_PARAM_CAPTURE_STATUS_CAPTURE_ENDED : MMAL_PARAM_CAPTURE_STATUS_T = 2 ; pub const MMAL_PARAM_CAPTURE_STATUS_T_MMAL_PARAM_CAPTURE_STATUS_MAX : MMAL_PARAM_CAPTURE_STATUS_T = 2147483647 ; pub type MMAL_PARAM_CAPTURE_STATUS_T = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_CAPTURE_STATUS_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < Capture status
 pub status : MMAL_PARAM_CAPTURE_STATUS_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_CAPTURE_STATUS_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_CAPTURE_STATUS_T > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_CAPTURE_STATUS_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_CAPTURE_STATUS_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_CAPTURE_STATUS_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAPTURE_STATUS_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAPTURE_STATUS_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAPTURE_STATUS_T > ( ) ) ) . status as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAPTURE_STATUS_T ) , "::" , stringify ! ( status ) ) ) ; } pub const MMAL_PARAM_FOCUS_STATUS_T_MMAL_PARAM_FOCUS_STATUS_OFF : MMAL_PARAM_FOCUS_STATUS_T = 0 ; pub const MMAL_PARAM_FOCUS_STATUS_T_MMAL_PARAM_FOCUS_STATUS_REQUEST : MMAL_PARAM_FOCUS_STATUS_T = 1 ; pub const MMAL_PARAM_FOCUS_STATUS_T_MMAL_PARAM_FOCUS_STATUS_REACHED : MMAL_PARAM_FOCUS_STATUS_T = 2 ; pub const MMAL_PARAM_FOCUS_STATUS_T_MMAL_PARAM_FOCUS_STATUS_UNABLE_TO_REACH : MMAL_PARAM_FOCUS_STATUS_T = 3 ; pub const MMAL_PARAM_FOCUS_STATUS_T_MMAL_PARAM_FOCUS_STATUS_LOST : MMAL_PARAM_FOCUS_STATUS_T = 4 ; pub const MMAL_PARAM_FOCUS_STATUS_T_MMAL_PARAM_FOCUS_STATUS_CAF_MOVING : MMAL_PARAM_FOCUS_STATUS_T = 5 ; pub const MMAL_PARAM_FOCUS_STATUS_T_MMAL_PARAM_FOCUS_STATUS_CAF_SUCCESS : MMAL_PARAM_FOCUS_STATUS_T = 6 ; pub const MMAL_PARAM_FOCUS_STATUS_T_MMAL_PARAM_FOCUS_STATUS_CAF_FAILED : MMAL_PARAM_FOCUS_STATUS_T = 7 ; pub const MMAL_PARAM_FOCUS_STATUS_T_MMAL_PARAM_FOCUS_STATUS_MANUAL_MOVING : MMAL_PARAM_FOCUS_STATUS_T = 8 ; pub const MMAL_PARAM_FOCUS_STATUS_T_MMAL_PARAM_FOCUS_STATUS_MANUAL_REACHED : MMAL_PARAM_FOCUS_STATUS_T = 9 ; pub const MMAL_PARAM_FOCUS_STATUS_T_MMAL_PARAM_FOCUS_STATUS_CAF_WATCHING : MMAL_PARAM_FOCUS_STATUS_T = 10 ; pub const MMAL_PARAM_FOCUS_STATUS_T_MMAL_PARAM_FOCUS_STATUS_CAF_SCENE_CHANGED : MMAL_PARAM_FOCUS_STATUS_T = 11 ; pub const MMAL_PARAM_FOCUS_STATUS_T_MMAL_PARAM_FOCUS_STATUS_MAX : MMAL_PARAM_FOCUS_STATUS_T = 2147483647 ; pub type MMAL_PARAM_FOCUS_STATUS_T = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_FOCUS_STATUS_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < Focus status
 pub status : MMAL_PARAM_FOCUS_STATUS_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_FOCUS_STATUS_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_FOCUS_STATUS_T > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_FOCUS_STATUS_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_FOCUS_STATUS_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_FOCUS_STATUS_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FOCUS_STATUS_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FOCUS_STATUS_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FOCUS_STATUS_T > ( ) ) ) . status as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FOCUS_STATUS_T ) , "::" , stringify ! ( status ) ) ) ; } pub const MMAL_PARAM_FACE_TRACK_MODE_T_MMAL_PARAM_FACE_DETECT_NONE : MMAL_PARAM_FACE_TRACK_MODE_T = 0 ; pub const MMAL_PARAM_FACE_TRACK_MODE_T_MMAL_PARAM_FACE_DETECT_ON : MMAL_PARAM_FACE_TRACK_MODE_T = 1 ; pub const MMAL_PARAM_FACE_TRACK_MODE_T_MMAL_PARAM_FACE_DETECT_MAX : MMAL_PARAM_FACE_TRACK_MODE_T = 2147483647 ; pub type MMAL_PARAM_FACE_TRACK_MODE_T = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_FACE_TRACK_T { pub hdr : MMAL_PARAMETER_HEADER_T , pub mode : MMAL_PARAM_FACE_TRACK_MODE_T , pub maxRegions : u32 , pub frames : u32 , pub quality : u32 , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_FACE_TRACK_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_FACE_TRACK_T > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_FACE_TRACK_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_FACE_TRACK_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_FACE_TRACK_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FACE_TRACK_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FACE_TRACK_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FACE_TRACK_T > ( ) ) ) . mode as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FACE_TRACK_T ) , "::" , stringify ! ( mode ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FACE_TRACK_T > ( ) ) ) . maxRegions as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FACE_TRACK_T ) , "::" , stringify ! ( maxRegions ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FACE_TRACK_T > ( ) ) ) . frames as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FACE_TRACK_T ) , "::" , stringify ! ( frames ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FACE_TRACK_T > ( ) ) ) . quality as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FACE_TRACK_T ) , "::" , stringify ! ( quality ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_FACE_TRACK_FACE_T { /// < Face ID. Should remain the same whilst the face is detected to remain in the scene
 pub face_id : i32 , /// < Confidence of the face detection. Range 1-100 (1=unsure, 100=positive).
 pub score : i32 , /// < Rectangle around the whole face
 pub face_rect : MMAL_RECT_T , /// < Rectangle around the eyes ([0] = left eye, [1] = right eye)
 pub eye_rect : [ MMAL_RECT_T ; 2usize ] , /// < Rectangle around the mouth
 pub mouth_rect : MMAL_RECT_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_FACE_TRACK_FACE_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_FACE_TRACK_FACE_T > ( ) , 72usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_FACE_TRACK_FACE_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_FACE_TRACK_FACE_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_FACE_TRACK_FACE_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FACE_TRACK_FACE_T > ( ) ) ) . face_id as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FACE_TRACK_FACE_T ) , "::" , stringify ! ( face_id ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FACE_TRACK_FACE_T > ( ) ) ) . score as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FACE_TRACK_FACE_T ) , "::" , stringify ! ( score ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FACE_TRACK_FACE_T > ( ) ) ) . face_rect as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FACE_TRACK_FACE_T ) , "::" , stringify ! ( face_rect ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FACE_TRACK_FACE_T > ( ) ) ) . eye_rect as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FACE_TRACK_FACE_T ) , "::" , stringify ! ( eye_rect ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FACE_TRACK_FACE_T > ( ) ) ) . mouth_rect as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FACE_TRACK_FACE_T ) , "::" , stringify ! ( mouth_rect ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_FACE_TRACK_RESULTS_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < Number of faces detected
 pub num_faces : u32 , /// < Width of the frame on which the faces were detected (allows scaling)
 pub frame_width : u32 , /// < Height of the frame on which the faces were detected (allows scaling)
 pub frame_height : u32 , /// < Face information (variable length array
 pub faces : [ MMAL_PARAMETER_FACE_TRACK_FACE_T ; 1usize ] , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_FACE_TRACK_RESULTS_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_FACE_TRACK_RESULTS_T > ( ) , 92usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_FACE_TRACK_RESULTS_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_FACE_TRACK_RESULTS_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_FACE_TRACK_RESULTS_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FACE_TRACK_RESULTS_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FACE_TRACK_RESULTS_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FACE_TRACK_RESULTS_T > ( ) ) ) . num_faces as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FACE_TRACK_RESULTS_T ) , "::" , stringify ! ( num_faces ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FACE_TRACK_RESULTS_T > ( ) ) ) . frame_width as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FACE_TRACK_RESULTS_T ) , "::" , stringify ! ( frame_width ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FACE_TRACK_RESULTS_T > ( ) ) ) . frame_height as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FACE_TRACK_RESULTS_T ) , "::" , stringify ! ( frame_height ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FACE_TRACK_RESULTS_T > ( ) ) ) . faces as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FACE_TRACK_RESULTS_T ) , "::" , stringify ! ( faces ) ) ) ; } pub mod MMAL_PARAMETER_CAMERA_CONFIG_TIMESTAMP_MODE_T { pub type Type = u32 ; pub const MMAL_PARAM_TIMESTAMP_MODE_ZERO : Type = 0 ; pub const MMAL_PARAM_TIMESTAMP_MODE_RAW_STC : Type = 1 ; pub const MMAL_PARAM_TIMESTAMP_MODE_RESET_STC : Type = 2 ; pub const MMAL_PARAM_TIMESTAMP_MODE_MAX : Type = 2147483647 ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_CAMERA_CONFIG_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < Max size of stills capture
 pub max_stills_w : u32 , pub max_stills_h : u32 , /// < Allow YUV422 stills capture
 pub stills_yuv422 : u32 , /// < Continuous or one shot stills captures.
 pub one_shot_stills : u32 , /// < Max size of the preview or video capture frames
 pub max_preview_video_w : u32 , pub max_preview_video_h : u32 , pub num_preview_video_frames : u32 , /// < Sets the height of the circular buffer for stills capture.
 pub stills_capture_circular_buffer_height : u32 , /// < Allows preview/encode to resume as fast as possible after the stills input frame
    /// has been received, and then processes the still frame in the background
    /// whilst preview/encode has resumed.
    /// Actual mode is controlled by MMAL_PARAMETER_CAPTURE_MODE.
 pub fast_preview_resume : u32 , pub use_stc_timestamp : MMAL_PARAMETER_CAMERA_CONFIG_TIMESTAMP_MODE_T::Type , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_CONFIG_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_CAMERA_CONFIG_T > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_CAMERA_CONFIG_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_CAMERA_CONFIG_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_CAMERA_CONFIG_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_CONFIG_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_CONFIG_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_CONFIG_T > ( ) ) ) . max_stills_w as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_CONFIG_T ) , "::" , stringify ! ( max_stills_w ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_CONFIG_T > ( ) ) ) . max_stills_h as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_CONFIG_T ) , "::" , stringify ! ( max_stills_h ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_CONFIG_T > ( ) ) ) . stills_yuv422 as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_CONFIG_T ) , "::" , stringify ! ( stills_yuv422 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_CONFIG_T > ( ) ) ) . one_shot_stills as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_CONFIG_T ) , "::" , stringify ! ( one_shot_stills ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_CONFIG_T > ( ) ) ) . max_preview_video_w as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_CONFIG_T ) , "::" , stringify ! ( max_preview_video_w ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_CONFIG_T > ( ) ) ) . max_preview_video_h as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_CONFIG_T ) , "::" , stringify ! ( max_preview_video_h ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_CONFIG_T > ( ) ) ) . num_preview_video_frames as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_CONFIG_T ) , "::" , stringify ! ( num_preview_video_frames ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_CONFIG_T > ( ) ) ) . stills_capture_circular_buffer_height as * const _ as usize } , 36usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_CONFIG_T ) , "::" , stringify ! ( stills_capture_circular_buffer_height ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_CONFIG_T > ( ) ) ) . fast_preview_resume as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_CONFIG_T ) , "::" , stringify ! ( fast_preview_resume ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_CONFIG_T > ( ) ) ) . use_stc_timestamp as * const _ as usize } , 44usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_CONFIG_T ) , "::" , stringify ! ( use_stc_timestamp ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_CAMERA_INFO_CAMERA_T { pub port_id : u32 , pub max_width : u32 , pub max_height : u32 , pub lens_present : MMAL_BOOL_T , pub camera_name : [ u8 ; 16usize ] , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_INFO_CAMERA_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_CAMERA_INFO_CAMERA_T > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_CAMERA_INFO_CAMERA_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_CAMERA_INFO_CAMERA_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_CAMERA_INFO_CAMERA_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_INFO_CAMERA_T > ( ) ) ) . port_id as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_INFO_CAMERA_T ) , "::" , stringify ! ( port_id ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_INFO_CAMERA_T > ( ) ) ) . max_width as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_INFO_CAMERA_T ) , "::" , stringify ! ( max_width ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_INFO_CAMERA_T > ( ) ) ) . max_height as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_INFO_CAMERA_T ) , "::" , stringify ! ( max_height ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_INFO_CAMERA_T > ( ) ) ) . lens_present as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_INFO_CAMERA_T ) , "::" , stringify ! ( lens_present ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_INFO_CAMERA_T > ( ) ) ) . camera_name as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_INFO_CAMERA_T ) , "::" , stringify ! ( camera_name ) ) ) ; } pub const MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T_MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_XENON : MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T = 0 ; pub const MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T_MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_LED : MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T = 1 ; pub const MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T_MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_OTHER : MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T = 2 ; pub const MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T_MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_MAX : MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T = 2147483647 ; pub type MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_CAMERA_INFO_FLASH_T { pub flash_type : MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_INFO_FLASH_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_CAMERA_INFO_FLASH_T > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_CAMERA_INFO_FLASH_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_CAMERA_INFO_FLASH_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_CAMERA_INFO_FLASH_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_INFO_FLASH_T > ( ) ) ) . flash_type as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_INFO_FLASH_T ) , "::" , stringify ! ( flash_type ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_CAMERA_INFO_T { pub hdr : MMAL_PARAMETER_HEADER_T , pub num_cameras : u32 , pub num_flashes : u32 , pub cameras : [ MMAL_PARAMETER_CAMERA_INFO_CAMERA_T ; 4usize ] , pub flashes : [ MMAL_PARAMETER_CAMERA_INFO_FLASH_T ; 2usize ] , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_INFO_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_CAMERA_INFO_T > ( ) , 152usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_CAMERA_INFO_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_CAMERA_INFO_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_CAMERA_INFO_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_INFO_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_INFO_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_INFO_T > ( ) ) ) . num_cameras as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_INFO_T ) , "::" , stringify ! ( num_cameras ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_INFO_T > ( ) ) ) . num_flashes as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_INFO_T ) , "::" , stringify ! ( num_flashes ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_INFO_T > ( ) ) ) . cameras as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_INFO_T ) , "::" , stringify ! ( cameras ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_INFO_T > ( ) ) ) . flashes as * const _ as usize } , 144usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_INFO_T ) , "::" , stringify ! ( flashes ) ) ) ; } pub const MMAL_PARAMETER_CAPTUREMODE_MODE_T_MMAL_PARAM_CAPTUREMODE_WAIT_FOR_END : MMAL_PARAMETER_CAPTUREMODE_MODE_T = 0 ; pub const MMAL_PARAMETER_CAPTUREMODE_MODE_T_MMAL_PARAM_CAPTUREMODE_WAIT_FOR_END_AND_HOLD : MMAL_PARAMETER_CAPTUREMODE_MODE_T = 1 ; pub const MMAL_PARAMETER_CAPTUREMODE_MODE_T_MMAL_PARAM_CAPTUREMODE_RESUME_VF_IMMEDIATELY : MMAL_PARAMETER_CAPTUREMODE_MODE_T = 2 ; pub type MMAL_PARAMETER_CAPTUREMODE_MODE_T = u32 ; /// Stills capture mode control.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_CAPTUREMODE_T { pub hdr : MMAL_PARAMETER_HEADER_T , pub mode : MMAL_PARAMETER_CAPTUREMODE_MODE_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_CAPTUREMODE_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_CAPTUREMODE_T > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_CAPTUREMODE_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_CAPTUREMODE_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_CAPTUREMODE_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAPTUREMODE_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAPTUREMODE_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAPTUREMODE_T > ( ) ) ) . mode as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAPTUREMODE_T ) , "::" , stringify ! ( mode ) ) ) ; } pub const MMAL_PARAMETER_FOCUS_REGION_TYPE_T_MMAL_PARAMETER_FOCUS_REGION_TYPE_NORMAL : MMAL_PARAMETER_FOCUS_REGION_TYPE_T = 0 ; pub const MMAL_PARAMETER_FOCUS_REGION_TYPE_T_MMAL_PARAMETER_FOCUS_REGION_TYPE_FACE : MMAL_PARAMETER_FOCUS_REGION_TYPE_T = 1 ; pub const MMAL_PARAMETER_FOCUS_REGION_TYPE_T_MMAL_PARAMETER_FOCUS_REGION_TYPE_MAX : MMAL_PARAMETER_FOCUS_REGION_TYPE_T = 2 ; pub type MMAL_PARAMETER_FOCUS_REGION_TYPE_T = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_FOCUS_REGION_T { /// < Focus rectangle as 0P16 fixed point values.
 pub rect : MMAL_RECT_T , /// < Region weighting.
 pub weight : u32 , /// < Mask for multi-stage regions
 pub mask : u32 , /// < Region type
 pub type_ : MMAL_PARAMETER_FOCUS_REGION_TYPE_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_FOCUS_REGION_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_FOCUS_REGION_T > ( ) , 28usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_FOCUS_REGION_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_FOCUS_REGION_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_FOCUS_REGION_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FOCUS_REGION_T > ( ) ) ) . rect as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FOCUS_REGION_T ) , "::" , stringify ! ( rect ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FOCUS_REGION_T > ( ) ) ) . weight as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FOCUS_REGION_T ) , "::" , stringify ! ( weight ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FOCUS_REGION_T > ( ) ) ) . mask as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FOCUS_REGION_T ) , "::" , stringify ! ( mask ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FOCUS_REGION_T > ( ) ) ) . type_ as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FOCUS_REGION_T ) , "::" , stringify ! ( type_ ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_FOCUS_REGIONS_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < Number of regions defined
 pub num_regions : u32 , /// < If region is within tolerance of a face, adopt face rect instead of defined region
 pub lock_to_faces : MMAL_BOOL_T , /// < Variable number of regions
 pub regions : [ MMAL_PARAMETER_FOCUS_REGION_T ; 1usize ] , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_FOCUS_REGIONS_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_FOCUS_REGIONS_T > ( ) , 44usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_FOCUS_REGIONS_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_FOCUS_REGIONS_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_FOCUS_REGIONS_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FOCUS_REGIONS_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FOCUS_REGIONS_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FOCUS_REGIONS_T > ( ) ) ) . num_regions as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FOCUS_REGIONS_T ) , "::" , stringify ! ( num_regions ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FOCUS_REGIONS_T > ( ) ) ) . lock_to_faces as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FOCUS_REGIONS_T ) , "::" , stringify ! ( lock_to_faces ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FOCUS_REGIONS_T > ( ) ) ) . regions as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FOCUS_REGIONS_T ) , "::" , stringify ! ( regions ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_INPUT_CROP_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < Crop rectangle as 16P16 fixed point values
 pub rect : MMAL_RECT_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_INPUT_CROP_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_INPUT_CROP_T > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_INPUT_CROP_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_INPUT_CROP_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_INPUT_CROP_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_INPUT_CROP_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_INPUT_CROP_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_INPUT_CROP_T > ( ) ) ) . rect as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_INPUT_CROP_T ) , "::" , stringify ! ( rect ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_SENSOR_INFORMATION_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < Lens f-number
 pub f_number : MMAL_RATIONAL_T , /// < Lens focal length
 pub focal_length : MMAL_RATIONAL_T , /// < Sensor reported model id
 pub model_id : u32 , /// < Sensor reported manufacturer id
 pub manufacturer_id : u32 , /// < Sensor reported revision
 pub revision : u32 , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_SENSOR_INFORMATION_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_SENSOR_INFORMATION_T > ( ) , 36usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_SENSOR_INFORMATION_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_SENSOR_INFORMATION_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_SENSOR_INFORMATION_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_SENSOR_INFORMATION_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_SENSOR_INFORMATION_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_SENSOR_INFORMATION_T > ( ) ) ) . f_number as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_SENSOR_INFORMATION_T ) , "::" , stringify ! ( f_number ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_SENSOR_INFORMATION_T > ( ) ) ) . focal_length as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_SENSOR_INFORMATION_T ) , "::" , stringify ! ( focal_length ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_SENSOR_INFORMATION_T > ( ) ) ) . model_id as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_SENSOR_INFORMATION_T ) , "::" , stringify ! ( model_id ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_SENSOR_INFORMATION_T > ( ) ) ) . manufacturer_id as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_SENSOR_INFORMATION_T ) , "::" , stringify ! ( manufacturer_id ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_SENSOR_INFORMATION_T > ( ) ) ) . revision as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_SENSOR_INFORMATION_T ) , "::" , stringify ! ( revision ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_FLASH_SELECT_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < Flash type to use
 pub flash_type : MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_FLASH_SELECT_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_FLASH_SELECT_T > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_FLASH_SELECT_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_FLASH_SELECT_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_FLASH_SELECT_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FLASH_SELECT_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FLASH_SELECT_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FLASH_SELECT_T > ( ) ) ) . flash_type as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FLASH_SELECT_T ) , "::" , stringify ! ( flash_type ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_FIELD_OF_VIEW_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < Horizontal field of view
 pub fov_h : MMAL_RATIONAL_T , /// < Vertical field of view
 pub fov_v : MMAL_RATIONAL_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_FIELD_OF_VIEW_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_FIELD_OF_VIEW_T > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_FIELD_OF_VIEW_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_FIELD_OF_VIEW_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_FIELD_OF_VIEW_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FIELD_OF_VIEW_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FIELD_OF_VIEW_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FIELD_OF_VIEW_T > ( ) ) ) . fov_h as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FIELD_OF_VIEW_T ) , "::" , stringify ! ( fov_h ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FIELD_OF_VIEW_T > ( ) ) ) . fov_v as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FIELD_OF_VIEW_T ) , "::" , stringify ! ( fov_v ) ) ) ; } pub const MMAL_PARAMETER_DRC_STRENGTH_T_MMAL_PARAMETER_DRC_STRENGTH_OFF : MMAL_PARAMETER_DRC_STRENGTH_T = 0 ; pub const MMAL_PARAMETER_DRC_STRENGTH_T_MMAL_PARAMETER_DRC_STRENGTH_LOW : MMAL_PARAMETER_DRC_STRENGTH_T = 1 ; pub const MMAL_PARAMETER_DRC_STRENGTH_T_MMAL_PARAMETER_DRC_STRENGTH_MEDIUM : MMAL_PARAMETER_DRC_STRENGTH_T = 2 ; pub const MMAL_PARAMETER_DRC_STRENGTH_T_MMAL_PARAMETER_DRC_STRENGTH_HIGH : MMAL_PARAMETER_DRC_STRENGTH_T = 3 ; pub const MMAL_PARAMETER_DRC_STRENGTH_T_MMAL_PARAMETER_DRC_STRENGTH_MAX : MMAL_PARAMETER_DRC_STRENGTH_T = 2147483647 ; pub type MMAL_PARAMETER_DRC_STRENGTH_T = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_DRC_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < DRC strength
 pub strength : MMAL_PARAMETER_DRC_STRENGTH_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_DRC_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_DRC_T > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_DRC_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_DRC_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_DRC_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_DRC_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_DRC_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_DRC_T > ( ) ) ) . strength as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_DRC_T ) , "::" , stringify ! ( strength ) ) ) ; } pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_FACETRACKING : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 0 ; pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_REDEYE_REDUCTION : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 1 ; pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_VIDEO_STABILISATION : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 2 ; pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_WRITE_RAW : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 3 ; pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_VIDEO_DENOISE : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 4 ; pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_STILLS_DENOISE : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 5 ; pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_TEMPORAL_DENOISE : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 6 ; pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_ANTISHAKE : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 7 ; pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_IMAGE_EFFECTS : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 8 ; pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_DYNAMIC_RANGE_COMPRESSION : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 9 ; pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_FACE_RECOGNITION : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 10 ; pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_FACE_BEAUTIFICATION : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 11 ; pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_SCENE_DETECTION : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 12 ; pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_HIGH_DYNAMIC_RANGE : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 13 ; pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_MAX : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 2147483647 ; pub type MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_ALGORITHM_CONTROL_T { pub hdr : MMAL_PARAMETER_HEADER_T , pub algorithm : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T , pub enabled : MMAL_BOOL_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_ALGORITHM_CONTROL_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_ALGORITHM_CONTROL_T > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_ALGORITHM_CONTROL_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_ALGORITHM_CONTROL_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_ALGORITHM_CONTROL_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_ALGORITHM_CONTROL_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_ALGORITHM_CONTROL_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_ALGORITHM_CONTROL_T > ( ) ) ) . algorithm as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_ALGORITHM_CONTROL_T ) , "::" , stringify ! ( algorithm ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_ALGORITHM_CONTROL_T > ( ) ) ) . enabled as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_ALGORITHM_CONTROL_T ) , "::" , stringify ! ( enabled ) ) ) ; } pub const MMAL_PARAM_CAMERA_USE_CASE_T_MMAL_PARAM_CAMERA_USE_CASE_UNKNOWN : MMAL_PARAM_CAMERA_USE_CASE_T = 0 ; pub const MMAL_PARAM_CAMERA_USE_CASE_T_MMAL_PARAM_CAMERA_USE_CASE_STILLS_CAPTURE : MMAL_PARAM_CAMERA_USE_CASE_T = 1 ; pub const MMAL_PARAM_CAMERA_USE_CASE_T_MMAL_PARAM_CAMERA_USE_CASE_VIDEO_CAPTURE : MMAL_PARAM_CAMERA_USE_CASE_T = 2 ; pub const MMAL_PARAM_CAMERA_USE_CASE_T_MMAL_PARAM_CAMERA_USE_CASE_MAX : MMAL_PARAM_CAMERA_USE_CASE_T = 2147483647 ; pub type MMAL_PARAM_CAMERA_USE_CASE_T = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_CAMERA_USE_CASE_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < Use case
 pub use_case : MMAL_PARAM_CAMERA_USE_CASE_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_USE_CASE_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_CAMERA_USE_CASE_T > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_CAMERA_USE_CASE_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_CAMERA_USE_CASE_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_CAMERA_USE_CASE_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_USE_CASE_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_USE_CASE_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_USE_CASE_T > ( ) ) ) . use_case as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_USE_CASE_T ) , "::" , stringify ! ( use_case ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_FPS_RANGE_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < Low end of the permitted framerate range
 pub fps_low : MMAL_RATIONAL_T , /// < High end of the permitted framerate range
 pub fps_high : MMAL_RATIONAL_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_FPS_RANGE_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_FPS_RANGE_T > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_FPS_RANGE_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_FPS_RANGE_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_FPS_RANGE_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FPS_RANGE_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FPS_RANGE_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FPS_RANGE_T > ( ) ) ) . fps_low as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FPS_RANGE_T ) , "::" , stringify ! ( fps_low ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FPS_RANGE_T > ( ) ) ) . fps_high as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FPS_RANGE_T ) , "::" , stringify ! ( fps_high ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_ZEROSHUTTERLAG_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < Select zero shutter lag mode from sensor
 pub zero_shutter_lag_mode : MMAL_BOOL_T , /// < Activate full zero shutter lag mode and
    /// use the last preview raw image for the stills capture
 pub concurrent_capture : MMAL_BOOL_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_ZEROSHUTTERLAG_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_ZEROSHUTTERLAG_T > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_ZEROSHUTTERLAG_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_ZEROSHUTTERLAG_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_ZEROSHUTTERLAG_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_ZEROSHUTTERLAG_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_ZEROSHUTTERLAG_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_ZEROSHUTTERLAG_T > ( ) ) ) . zero_shutter_lag_mode as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_ZEROSHUTTERLAG_T ) , "::" , stringify ! ( zero_shutter_lag_mode ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_ZEROSHUTTERLAG_T > ( ) ) ) . concurrent_capture as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_ZEROSHUTTERLAG_T ) , "::" , stringify ! ( concurrent_capture ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_AWB_GAINS_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < Red gain
 pub r_gain : MMAL_RATIONAL_T , /// < Blue gain
 pub b_gain : MMAL_RATIONAL_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_AWB_GAINS_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_AWB_GAINS_T > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_AWB_GAINS_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_AWB_GAINS_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_AWB_GAINS_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_AWB_GAINS_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_AWB_GAINS_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_AWB_GAINS_T > ( ) ) ) . r_gain as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_AWB_GAINS_T ) , "::" , stringify ! ( r_gain ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_AWB_GAINS_T > ( ) ) ) . b_gain as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_AWB_GAINS_T ) , "::" , stringify ! ( b_gain ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_CAMERA_SETTINGS_T { pub hdr : MMAL_PARAMETER_HEADER_T , pub exposure : u32 , pub analog_gain : MMAL_RATIONAL_T , pub digital_gain : MMAL_RATIONAL_T , pub awb_red_gain : MMAL_RATIONAL_T , pub awb_blue_gain : MMAL_RATIONAL_T , pub focus_position : u32 , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_SETTINGS_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_CAMERA_SETTINGS_T > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_CAMERA_SETTINGS_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_CAMERA_SETTINGS_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_CAMERA_SETTINGS_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_SETTINGS_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_SETTINGS_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_SETTINGS_T > ( ) ) ) . exposure as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_SETTINGS_T ) , "::" , stringify ! ( exposure ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_SETTINGS_T > ( ) ) ) . analog_gain as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_SETTINGS_T ) , "::" , stringify ! ( analog_gain ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_SETTINGS_T > ( ) ) ) . digital_gain as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_SETTINGS_T ) , "::" , stringify ! ( digital_gain ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_SETTINGS_T > ( ) ) ) . awb_red_gain as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_SETTINGS_T ) , "::" , stringify ! ( awb_red_gain ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_SETTINGS_T > ( ) ) ) . awb_blue_gain as * const _ as usize } , 36usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_SETTINGS_T ) , "::" , stringify ! ( awb_blue_gain ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_SETTINGS_T > ( ) ) ) . focus_position as * const _ as usize } , 44usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_SETTINGS_T ) , "::" , stringify ! ( focus_position ) ) ) ; } pub const MMAL_PARAM_PRIVACY_INDICATOR_T_MMAL_PARAMETER_PRIVACY_INDICATOR_OFF : MMAL_PARAM_PRIVACY_INDICATOR_T = 0 ; pub const MMAL_PARAM_PRIVACY_INDICATOR_T_MMAL_PARAMETER_PRIVACY_INDICATOR_ON : MMAL_PARAM_PRIVACY_INDICATOR_T = 1 ; pub const MMAL_PARAM_PRIVACY_INDICATOR_T_MMAL_PARAMETER_PRIVACY_INDICATOR_FORCE_ON : MMAL_PARAM_PRIVACY_INDICATOR_T = 2 ; pub const MMAL_PARAM_PRIVACY_INDICATOR_T_MMAL_PARAMETER_PRIVACY_INDICATOR_MAX : MMAL_PARAM_PRIVACY_INDICATOR_T = 2147483647 ; pub type MMAL_PARAM_PRIVACY_INDICATOR_T = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_PRIVACY_INDICATOR_T { pub hdr : MMAL_PARAMETER_HEADER_T , pub mode : MMAL_PARAM_PRIVACY_INDICATOR_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_PRIVACY_INDICATOR_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_PRIVACY_INDICATOR_T > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_PRIVACY_INDICATOR_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_PRIVACY_INDICATOR_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_PRIVACY_INDICATOR_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_PRIVACY_INDICATOR_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_PRIVACY_INDICATOR_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_PRIVACY_INDICATOR_T > ( ) ) ) . mode as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_PRIVACY_INDICATOR_T ) , "::" , stringify ! ( mode ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_CAMERA_ANNOTATE_T { pub hdr : MMAL_PARAMETER_HEADER_T , pub enable : MMAL_BOOL_T , pub text : [ :: std :: os :: raw :: c_char ; 32usize ] , pub show_shutter : MMAL_BOOL_T , pub show_analog_gain : MMAL_BOOL_T , pub show_lens : MMAL_BOOL_T , pub show_caf : MMAL_BOOL_T , pub show_motion : MMAL_BOOL_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_ANNOTATE_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_CAMERA_ANNOTATE_T > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_CAMERA_ANNOTATE_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_ANNOTATE_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_ANNOTATE_T > ( ) ) ) . enable as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_T ) , "::" , stringify ! ( enable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_ANNOTATE_T > ( ) ) ) . text as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_T ) , "::" , stringify ! ( text ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_ANNOTATE_T > ( ) ) ) . show_shutter as * const _ as usize } , 44usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_T ) , "::" , stringify ! ( show_shutter ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_ANNOTATE_T > ( ) ) ) . show_analog_gain as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_T ) , "::" , stringify ! ( show_analog_gain ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_ANNOTATE_T > ( ) ) ) . show_lens as * const _ as usize } , 52usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_T ) , "::" , stringify ! ( show_lens ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_ANNOTATE_T > ( ) ) ) . show_caf as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_T ) , "::" , stringify ! ( show_caf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_ANNOTATE_T > ( ) ) ) . show_motion as * const _ as usize } , 60usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_T ) , "::" , stringify ! ( show_motion ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T { pub hdr : MMAL_PARAMETER_HEADER_T , pub enable : MMAL_BOOL_T , pub show_shutter : MMAL_BOOL_T , pub show_analog_gain : MMAL_BOOL_T , pub show_lens : MMAL_BOOL_T , pub show_caf : MMAL_BOOL_T , pub show_motion : MMAL_BOOL_T , pub show_frame_num : MMAL_BOOL_T , pub black_text_background : MMAL_BOOL_T , pub text : [ :: std :: os :: raw :: c_char ; 256usize ] , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T > ( ) , 296usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T > ( ) ) ) . enable as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T ) , "::" , stringify ! ( enable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T > ( ) ) ) . show_shutter as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T ) , "::" , stringify ! ( show_shutter ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T > ( ) ) ) . show_analog_gain as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T ) , "::" , stringify ! ( show_analog_gain ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T > ( ) ) ) . show_lens as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T ) , "::" , stringify ! ( show_lens ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T > ( ) ) ) . show_caf as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T ) , "::" , stringify ! ( show_caf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T > ( ) ) ) . show_motion as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T ) , "::" , stringify ! ( show_motion ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T > ( ) ) ) . show_frame_num as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T ) , "::" , stringify ! ( show_frame_num ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T > ( ) ) ) . black_text_background as * const _ as usize } , 36usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T ) , "::" , stringify ! ( black_text_background ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T > ( ) ) ) . text as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T ) , "::" , stringify ! ( text ) ) ) ; } impl :: std :: fmt :: Debug for MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T { fn fmt ( & self , f : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { write ! ( f , "MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T {{ hdr: {:?}, enable: {:?}, show_shutter: {:?}, show_analog_gain: {:?}, show_lens: {:?}, show_caf: {:?}, show_motion: {:?}, show_frame_num: {:?}, black_text_background: {:?}, text: [{}] }}" , self . hdr , self . enable , self . show_shutter , self . show_analog_gain , self . show_lens , self . show_caf , self . show_motion , self . show_frame_num , self . black_text_background , self . text . iter ( ) . enumerate ( ) . map ( | ( i , v ) | format ! ( "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: < String > ( ) ) } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T { pub hdr : MMAL_PARAMETER_HEADER_T , pub enable : MMAL_BOOL_T , pub show_shutter : MMAL_BOOL_T , pub show_analog_gain : MMAL_BOOL_T , pub show_lens : MMAL_BOOL_T , pub show_caf : MMAL_BOOL_T , pub show_motion : MMAL_BOOL_T , pub show_frame_num : MMAL_BOOL_T , pub enable_text_background : MMAL_BOOL_T , pub custom_background_colour : MMAL_BOOL_T , pub custom_background_Y : u8 , pub custom_background_U : u8 , pub custom_background_V : u8 , pub dummy1 : u8 , pub custom_text_colour : MMAL_BOOL_T , pub custom_text_Y : u8 , pub custom_text_U : u8 , pub custom_text_V : u8 , pub text_size : u8 , pub text : [ :: std :: os :: raw :: c_char ; 256usize ] , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T > ( ) , 312usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T > ( ) ) ) . enable as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T ) , "::" , stringify ! ( enable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T > ( ) ) ) . show_shutter as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T ) , "::" , stringify ! ( show_shutter ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T > ( ) ) ) . show_analog_gain as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T ) , "::" , stringify ! ( show_analog_gain ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T > ( ) ) ) . show_lens as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T ) , "::" , stringify ! ( show_lens ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T > ( ) ) ) . show_caf as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T ) , "::" , stringify ! ( show_caf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T > ( ) ) ) . show_motion as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T ) , "::" , stringify ! ( show_motion ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T > ( ) ) ) . show_frame_num as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T ) , "::" , stringify ! ( show_frame_num ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T > ( ) ) ) . enable_text_background as * const _ as usize } , 36usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T ) , "::" , stringify ! ( enable_text_background ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T > ( ) ) ) . custom_background_colour as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T ) , "::" , stringify ! ( custom_background_colour ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T > ( ) ) ) . custom_background_Y as * const _ as usize } , 44usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T ) , "::" , stringify ! ( custom_background_Y ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T > ( ) ) ) . custom_background_U as * const _ as usize } , 45usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T ) , "::" , stringify ! ( custom_background_U ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T > ( ) ) ) . custom_background_V as * const _ as usize } , 46usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T ) , "::" , stringify ! ( custom_background_V ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T > ( ) ) ) . dummy1 as * const _ as usize } , 47usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T ) , "::" , stringify ! ( dummy1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T > ( ) ) ) . custom_text_colour as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T ) , "::" , stringify ! ( custom_text_colour ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T > ( ) ) ) . custom_text_Y as * const _ as usize } , 52usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T ) , "::" , stringify ! ( custom_text_Y ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T > ( ) ) ) . custom_text_U as * const _ as usize } , 53usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T ) , "::" , stringify ! ( custom_text_U ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T > ( ) ) ) . custom_text_V as * const _ as usize } , 54usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T ) , "::" , stringify ! ( custom_text_V ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T > ( ) ) ) . text_size as * const _ as usize } , 55usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T ) , "::" , stringify ! ( text_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T > ( ) ) ) . text as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T ) , "::" , stringify ! ( text ) ) ) ; } impl :: std :: fmt :: Debug for MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T { fn fmt ( & self , f : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { write ! ( f , "MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T {{ hdr: {:?}, enable: {:?}, show_shutter: {:?}, show_analog_gain: {:?}, show_lens: {:?}, show_caf: {:?}, show_motion: {:?}, show_frame_num: {:?}, enable_text_background: {:?}, custom_background_colour: {:?}, custom_background_Y: {:?}, custom_background_U: {:?}, custom_background_V: {:?}, dummy1: {:?}, custom_text_colour: {:?}, custom_text_Y: {:?}, custom_text_U: {:?}, custom_text_V: {:?}, text_size: {:?}, text: [{}] }}" , self . hdr , self . enable , self . show_shutter , self . show_analog_gain , self . show_lens , self . show_caf , self . show_motion , self . show_frame_num , self . enable_text_background , self . custom_background_colour , self . custom_background_Y , self . custom_background_U , self . custom_background_V , self . dummy1 , self . custom_text_colour , self . custom_text_Y , self . custom_text_U , self . custom_text_V , self . text_size , self . text . iter ( ) . enumerate ( ) . map ( | ( i , v ) | format ! ( "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: < String > ( ) ) } } pub const MMAL_STEREOSCOPIC_MODE_T_MMAL_STEREOSCOPIC_MODE_NONE : MMAL_STEREOSCOPIC_MODE_T = 0 ; pub const MMAL_STEREOSCOPIC_MODE_T_MMAL_STEREOSCOPIC_MODE_SIDE_BY_SIDE : MMAL_STEREOSCOPIC_MODE_T = 1 ; pub const MMAL_STEREOSCOPIC_MODE_T_MMAL_STEREOSCOPIC_MODE_TOP_BOTTOM : MMAL_STEREOSCOPIC_MODE_T = 2 ; pub const MMAL_STEREOSCOPIC_MODE_T_MMAL_STEREOSCOPIC_MODE_MAX : MMAL_STEREOSCOPIC_MODE_T = 2147483647 ; pub type MMAL_STEREOSCOPIC_MODE_T = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_STEREOSCOPIC_MODE_T { pub hdr : MMAL_PARAMETER_HEADER_T , pub mode : MMAL_STEREOSCOPIC_MODE_T , pub decimate : MMAL_BOOL_T , pub swap_eyes : MMAL_BOOL_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_STEREOSCOPIC_MODE_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_STEREOSCOPIC_MODE_T > ( ) , 20usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_STEREOSCOPIC_MODE_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_STEREOSCOPIC_MODE_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_STEREOSCOPIC_MODE_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_STEREOSCOPIC_MODE_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_STEREOSCOPIC_MODE_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_STEREOSCOPIC_MODE_T > ( ) ) ) . mode as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_STEREOSCOPIC_MODE_T ) , "::" , stringify ! ( mode ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_STEREOSCOPIC_MODE_T > ( ) ) ) . decimate as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_STEREOSCOPIC_MODE_T ) , "::" , stringify ! ( decimate ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_STEREOSCOPIC_MODE_T > ( ) ) ) . swap_eyes as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_STEREOSCOPIC_MODE_T ) , "::" , stringify ! ( swap_eyes ) ) ) ; } pub const MMAL_CAMERA_INTERFACE_T_MMAL_CAMERA_INTERFACE_CSI2 : MMAL_CAMERA_INTERFACE_T = 0 ; pub const MMAL_CAMERA_INTERFACE_T_MMAL_CAMERA_INTERFACE_CCP2 : MMAL_CAMERA_INTERFACE_T = 1 ; pub const MMAL_CAMERA_INTERFACE_T_MMAL_CAMERA_INTERFACE_CPI : MMAL_CAMERA_INTERFACE_T = 2 ; pub const MMAL_CAMERA_INTERFACE_T_MMAL_CAMERA_INTERFACE_MAX : MMAL_CAMERA_INTERFACE_T = 2147483647 ; pub type MMAL_CAMERA_INTERFACE_T = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_CAMERA_INTERFACE_T { pub hdr : MMAL_PARAMETER_HEADER_T , pub mode : MMAL_CAMERA_INTERFACE_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_INTERFACE_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_CAMERA_INTERFACE_T > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_CAMERA_INTERFACE_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_CAMERA_INTERFACE_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_CAMERA_INTERFACE_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_INTERFACE_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_INTERFACE_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_INTERFACE_T > ( ) ) ) . mode as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_INTERFACE_T ) , "::" , stringify ! ( mode ) ) ) ; } pub const MMAL_CAMERA_CLOCKING_MODE_T_MMAL_CAMERA_CLOCKING_MODE_STROBE : MMAL_CAMERA_CLOCKING_MODE_T = 0 ; pub const MMAL_CAMERA_CLOCKING_MODE_T_MMAL_CAMERA_CLOCKING_MODE_CLOCK : MMAL_CAMERA_CLOCKING_MODE_T = 1 ; pub const MMAL_CAMERA_CLOCKING_MODE_T_MMAL_CAMERA_CLOCKING_MODE_MAX : MMAL_CAMERA_CLOCKING_MODE_T = 2147483647 ; pub type MMAL_CAMERA_CLOCKING_MODE_T = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_CAMERA_CLOCKING_MODE_T { pub hdr : MMAL_PARAMETER_HEADER_T , pub mode : MMAL_CAMERA_CLOCKING_MODE_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_CLOCKING_MODE_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_CAMERA_CLOCKING_MODE_T > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_CAMERA_CLOCKING_MODE_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_CAMERA_CLOCKING_MODE_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_CAMERA_CLOCKING_MODE_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_CLOCKING_MODE_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_CLOCKING_MODE_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_CLOCKING_MODE_T > ( ) ) ) . mode as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_CLOCKING_MODE_T ) , "::" , stringify ! ( mode ) ) ) ; } pub const MMAL_CAMERA_RX_CONFIG_DECODE_MMAL_CAMERA_RX_CONFIG_DECODE_NONE : MMAL_CAMERA_RX_CONFIG_DECODE = 0 ; pub const MMAL_CAMERA_RX_CONFIG_DECODE_MMAL_CAMERA_RX_CONFIG_DECODE_DPCM8TO10 : MMAL_CAMERA_RX_CONFIG_DECODE = 1 ; pub const MMAL_CAMERA_RX_CONFIG_DECODE_MMAL_CAMERA_RX_CONFIG_DECODE_DPCM7TO10 : MMAL_CAMERA_RX_CONFIG_DECODE = 2 ; pub const MMAL_CAMERA_RX_CONFIG_DECODE_MMAL_CAMERA_RX_CONFIG_DECODE_DPCM6TO10 : MMAL_CAMERA_RX_CONFIG_DECODE = 3 ; pub const MMAL_CAMERA_RX_CONFIG_DECODE_MMAL_CAMERA_RX_CONFIG_DECODE_DPCM8TO12 : MMAL_CAMERA_RX_CONFIG_DECODE = 4 ; pub const MMAL_CAMERA_RX_CONFIG_DECODE_MMAL_CAMERA_RX_CONFIG_DECODE_DPCM7TO12 : MMAL_CAMERA_RX_CONFIG_DECODE = 5 ; pub const MMAL_CAMERA_RX_CONFIG_DECODE_MMAL_CAMERA_RX_CONFIG_DECODE_DPCM6TO12 : MMAL_CAMERA_RX_CONFIG_DECODE = 6 ; pub const MMAL_CAMERA_RX_CONFIG_DECODE_MMAL_CAMERA_RX_CONFIG_DECODE_DPCM10TO14 : MMAL_CAMERA_RX_CONFIG_DECODE = 7 ; pub const MMAL_CAMERA_RX_CONFIG_DECODE_MMAL_CAMERA_RX_CONFIG_DECODE_DPCM8TO14 : MMAL_CAMERA_RX_CONFIG_DECODE = 8 ; pub const MMAL_CAMERA_RX_CONFIG_DECODE_MMAL_CAMERA_RX_CONFIG_DECODE_DPCM12TO16 : MMAL_CAMERA_RX_CONFIG_DECODE = 9 ; pub const MMAL_CAMERA_RX_CONFIG_DECODE_MMAL_CAMERA_RX_CONFIG_DECODE_DPCM10TO16 : MMAL_CAMERA_RX_CONFIG_DECODE = 10 ; pub const MMAL_CAMERA_RX_CONFIG_DECODE_MMAL_CAMERA_RX_CONFIG_DECODE_DPCM8TO16 : MMAL_CAMERA_RX_CONFIG_DECODE = 11 ; pub const MMAL_CAMERA_RX_CONFIG_DECODE_MMAL_CAMERA_RX_CONFIG_DECODE_MAX : MMAL_CAMERA_RX_CONFIG_DECODE = 2147483647 ; pub type MMAL_CAMERA_RX_CONFIG_DECODE = u32 ; pub const MMAL_CAMERA_RX_CONFIG_ENCODE_MMAL_CAMERA_RX_CONFIG_ENCODE_NONE : MMAL_CAMERA_RX_CONFIG_ENCODE = 0 ; pub const MMAL_CAMERA_RX_CONFIG_ENCODE_MMAL_CAMERA_RX_CONFIG_ENCODE_DPCM10TO8 : MMAL_CAMERA_RX_CONFIG_ENCODE = 1 ; pub const MMAL_CAMERA_RX_CONFIG_ENCODE_MMAL_CAMERA_RX_CONFIG_ENCODE_DPCM12TO8 : MMAL_CAMERA_RX_CONFIG_ENCODE = 2 ; pub const MMAL_CAMERA_RX_CONFIG_ENCODE_MMAL_CAMERA_RX_CONFIG_ENCODE_DPCM14TO8 : MMAL_CAMERA_RX_CONFIG_ENCODE = 3 ; pub const MMAL_CAMERA_RX_CONFIG_ENCODE_MMAL_CAMERA_RX_CONFIG_ENCODE_MAX : MMAL_CAMERA_RX_CONFIG_ENCODE = 2147483647 ; pub type MMAL_CAMERA_RX_CONFIG_ENCODE = u32 ; pub const MMAL_CAMERA_RX_CONFIG_UNPACK_MMAL_CAMERA_RX_CONFIG_UNPACK_NONE : MMAL_CAMERA_RX_CONFIG_UNPACK = 0 ; pub const MMAL_CAMERA_RX_CONFIG_UNPACK_MMAL_CAMERA_RX_CONFIG_UNPACK_6 : MMAL_CAMERA_RX_CONFIG_UNPACK = 1 ; pub const MMAL_CAMERA_RX_CONFIG_UNPACK_MMAL_CAMERA_RX_CONFIG_UNPACK_7 : MMAL_CAMERA_RX_CONFIG_UNPACK = 2 ; pub const MMAL_CAMERA_RX_CONFIG_UNPACK_MMAL_CAMERA_RX_CONFIG_UNPACK_8 : MMAL_CAMERA_RX_CONFIG_UNPACK = 3 ; pub const MMAL_CAMERA_RX_CONFIG_UNPACK_MMAL_CAMERA_RX_CONFIG_UNPACK_10 : MMAL_CAMERA_RX_CONFIG_UNPACK = 4 ; pub const MMAL_CAMERA_RX_CONFIG_UNPACK_MMAL_CAMERA_RX_CONFIG_UNPACK_12 : MMAL_CAMERA_RX_CONFIG_UNPACK = 5 ; pub const MMAL_CAMERA_RX_CONFIG_UNPACK_MMAL_CAMERA_RX_CONFIG_UNPACK_14 : MMAL_CAMERA_RX_CONFIG_UNPACK = 6 ; pub const MMAL_CAMERA_RX_CONFIG_UNPACK_MMAL_CAMERA_RX_CONFIG_UNPACK_16 : MMAL_CAMERA_RX_CONFIG_UNPACK = 7 ; pub const MMAL_CAMERA_RX_CONFIG_UNPACK_MMAL_CAMERA_RX_CONFIG_UNPACK_MAX : MMAL_CAMERA_RX_CONFIG_UNPACK = 2147483647 ; pub type MMAL_CAMERA_RX_CONFIG_UNPACK = u32 ; pub const MMAL_CAMERA_RX_CONFIG_PACK_MMAL_CAMERA_RX_CONFIG_PACK_NONE : MMAL_CAMERA_RX_CONFIG_PACK = 0 ; pub const MMAL_CAMERA_RX_CONFIG_PACK_MMAL_CAMERA_RX_CONFIG_PACK_8 : MMAL_CAMERA_RX_CONFIG_PACK = 1 ; pub const MMAL_CAMERA_RX_CONFIG_PACK_MMAL_CAMERA_RX_CONFIG_PACK_10 : MMAL_CAMERA_RX_CONFIG_PACK = 2 ; pub const MMAL_CAMERA_RX_CONFIG_PACK_MMAL_CAMERA_RX_CONFIG_PACK_12 : MMAL_CAMERA_RX_CONFIG_PACK = 3 ; pub const MMAL_CAMERA_RX_CONFIG_PACK_MMAL_CAMERA_RX_CONFIG_PACK_14 : MMAL_CAMERA_RX_CONFIG_PACK = 4 ; pub const MMAL_CAMERA_RX_CONFIG_PACK_MMAL_CAMERA_RX_CONFIG_PACK_16 : MMAL_CAMERA_RX_CONFIG_PACK = 5 ; pub const MMAL_CAMERA_RX_CONFIG_PACK_MMAL_CAMERA_RX_CONFIG_PACK_RAW10 : MMAL_CAMERA_RX_CONFIG_PACK = 6 ; pub const MMAL_CAMERA_RX_CONFIG_PACK_MMAL_CAMERA_RX_CONFIG_PACK_RAW12 : MMAL_CAMERA_RX_CONFIG_PACK = 7 ; pub const MMAL_CAMERA_RX_CONFIG_PACK_MMAL_CAMERA_RX_CONFIG_PACK_MAX : MMAL_CAMERA_RX_CONFIG_PACK = 2147483647 ; pub type MMAL_CAMERA_RX_CONFIG_PACK = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_CAMERA_RX_CONFIG_T { pub hdr : MMAL_PARAMETER_HEADER_T , pub decode : MMAL_CAMERA_RX_CONFIG_DECODE , pub encode : MMAL_CAMERA_RX_CONFIG_ENCODE , pub unpack : MMAL_CAMERA_RX_CONFIG_UNPACK , pub pack : MMAL_CAMERA_RX_CONFIG_PACK , pub data_lanes : u32 , pub encode_block_length : u32 , pub embedded_data_lines : u32 , pub image_id : u32 , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_RX_CONFIG_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_CAMERA_RX_CONFIG_T > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_CAMERA_RX_CONFIG_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_CAMERA_RX_CONFIG_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_CAMERA_RX_CONFIG_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_RX_CONFIG_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_RX_CONFIG_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_RX_CONFIG_T > ( ) ) ) . decode as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_RX_CONFIG_T ) , "::" , stringify ! ( decode ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_RX_CONFIG_T > ( ) ) ) . encode as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_RX_CONFIG_T ) , "::" , stringify ! ( encode ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_RX_CONFIG_T > ( ) ) ) . unpack as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_RX_CONFIG_T ) , "::" , stringify ! ( unpack ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_RX_CONFIG_T > ( ) ) ) . pack as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_RX_CONFIG_T ) , "::" , stringify ! ( pack ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_RX_CONFIG_T > ( ) ) ) . data_lanes as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_RX_CONFIG_T ) , "::" , stringify ! ( data_lanes ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_RX_CONFIG_T > ( ) ) ) . encode_block_length as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_RX_CONFIG_T ) , "::" , stringify ! ( encode_block_length ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_RX_CONFIG_T > ( ) ) ) . embedded_data_lines as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_RX_CONFIG_T ) , "::" , stringify ! ( embedded_data_lines ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_RX_CONFIG_T > ( ) ) ) . image_id as * const _ as usize } , 36usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_RX_CONFIG_T ) , "::" , stringify ! ( image_id ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_CAMERA_RX_TIMING_T { pub hdr : MMAL_PARAMETER_HEADER_T , pub timing1 : u32 , pub timing2 : u32 , pub timing3 : u32 , pub timing4 : u32 , pub timing5 : u32 , pub term1 : u32 , pub term2 : u32 , pub cpi_timing1 : u32 , pub cpi_timing2 : u32 , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_RX_TIMING_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_CAMERA_RX_TIMING_T > ( ) , 44usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_CAMERA_RX_TIMING_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_CAMERA_RX_TIMING_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_CAMERA_RX_TIMING_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_RX_TIMING_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_RX_TIMING_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_RX_TIMING_T > ( ) ) ) . timing1 as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_RX_TIMING_T ) , "::" , stringify ! ( timing1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_RX_TIMING_T > ( ) ) ) . timing2 as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_RX_TIMING_T ) , "::" , stringify ! ( timing2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_RX_TIMING_T > ( ) ) ) . timing3 as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_RX_TIMING_T ) , "::" , stringify ! ( timing3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_RX_TIMING_T > ( ) ) ) . timing4 as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_RX_TIMING_T ) , "::" , stringify ! ( timing4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_RX_TIMING_T > ( ) ) ) . timing5 as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_RX_TIMING_T ) , "::" , stringify ! ( timing5 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_RX_TIMING_T > ( ) ) ) . term1 as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_RX_TIMING_T ) , "::" , stringify ! ( term1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_RX_TIMING_T > ( ) ) ) . term2 as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_RX_TIMING_T ) , "::" , stringify ! ( term2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_RX_TIMING_T > ( ) ) ) . cpi_timing1 as * const _ as usize } , 36usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_RX_TIMING_T ) , "::" , stringify ! ( cpi_timing1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CAMERA_RX_TIMING_T > ( ) ) ) . cpi_timing2 as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CAMERA_RX_TIMING_T ) , "::" , stringify ! ( cpi_timing2 ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_LENS_SHADING_T { pub hdr : MMAL_PARAMETER_HEADER_T , pub enabled : MMAL_BOOL_T , pub grid_cell_size : u32 , pub grid_width : u32 , pub grid_stride : u32 , pub grid_height : u32 , pub mem_handle_table : u32 , pub ref_transform : u32 , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_LENS_SHADING_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_LENS_SHADING_T > ( ) , 36usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_LENS_SHADING_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_LENS_SHADING_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_LENS_SHADING_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_LENS_SHADING_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_LENS_SHADING_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_LENS_SHADING_T > ( ) ) ) . enabled as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_LENS_SHADING_T ) , "::" , stringify ! ( enabled ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_LENS_SHADING_T > ( ) ) ) . grid_cell_size as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_LENS_SHADING_T ) , "::" , stringify ! ( grid_cell_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_LENS_SHADING_T > ( ) ) ) . grid_width as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_LENS_SHADING_T ) , "::" , stringify ! ( grid_width ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_LENS_SHADING_T > ( ) ) ) . grid_stride as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_LENS_SHADING_T ) , "::" , stringify ! ( grid_stride ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_LENS_SHADING_T > ( ) ) ) . grid_height as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_LENS_SHADING_T ) , "::" , stringify ! ( grid_height ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_LENS_SHADING_T > ( ) ) ) . mem_handle_table as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_LENS_SHADING_T ) , "::" , stringify ! ( mem_handle_table ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_LENS_SHADING_T > ( ) ) ) . ref_transform as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_LENS_SHADING_T ) , "::" , stringify ! ( ref_transform ) ) ) ; } pub const MMAL_RESIZEMODE_T_MMAL_RESIZE_NONE : MMAL_RESIZEMODE_T = 0 ; pub const MMAL_RESIZEMODE_T_MMAL_RESIZE_CROP : MMAL_RESIZEMODE_T = 1 ; pub const MMAL_RESIZEMODE_T_MMAL_RESIZE_BOX : MMAL_RESIZEMODE_T = 2 ; pub const MMAL_RESIZEMODE_T_MMAL_RESIZE_BYTES : MMAL_RESIZEMODE_T = 3 ; pub const MMAL_RESIZEMODE_T_MMAL_RESIZE_DUMMY : MMAL_RESIZEMODE_T = 2147483647 ; pub type MMAL_RESIZEMODE_T = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_RESIZE_T { pub hdr : MMAL_PARAMETER_HEADER_T , pub mode : MMAL_RESIZEMODE_T , pub max_width : u32 , pub max_height : u32 , pub max_bytes : u32 , pub preserve_aspect_ratio : MMAL_BOOL_T , pub allow_upscaling : MMAL_BOOL_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_RESIZE_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_RESIZE_T > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_RESIZE_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_RESIZE_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_RESIZE_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_RESIZE_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_RESIZE_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_RESIZE_T > ( ) ) ) . mode as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_RESIZE_T ) , "::" , stringify ! ( mode ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_RESIZE_T > ( ) ) ) . max_width as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_RESIZE_T ) , "::" , stringify ! ( max_width ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_RESIZE_T > ( ) ) ) . max_height as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_RESIZE_T ) , "::" , stringify ! ( max_height ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_RESIZE_T > ( ) ) ) . max_bytes as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_RESIZE_T ) , "::" , stringify ! ( max_bytes ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_RESIZE_T > ( ) ) ) . preserve_aspect_ratio as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_RESIZE_T ) , "::" , stringify ! ( preserve_aspect_ratio ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_RESIZE_T > ( ) ) ) . allow_upscaling as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_RESIZE_T ) , "::" , stringify ! ( allow_upscaling ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_CROP_T { pub hdr : MMAL_PARAMETER_HEADER_T , pub rect : MMAL_RECT_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_CROP_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_CROP_T > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_CROP_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_CROP_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_CROP_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CROP_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CROP_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CROP_T > ( ) ) ) . rect as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CROP_T ) , "::" , stringify ! ( rect ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_CCM_T { pub ccm : [ [ MMAL_RATIONAL_T ; 3usize ] ; 3usize ] , pub offsets : [ i32 ; 3usize ] , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_CCM_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_CCM_T > ( ) , 84usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_CCM_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_CCM_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_CCM_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CCM_T > ( ) ) ) . ccm as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CCM_T ) , "::" , stringify ! ( ccm ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CCM_T > ( ) ) ) . offsets as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CCM_T ) , "::" , stringify ! ( offsets ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_CUSTOM_CCM_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < Enable the custom CCM.
 pub enable : MMAL_BOOL_T , /// < CCM to be used.
 pub ccm : MMAL_PARAMETER_CCM_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_CUSTOM_CCM_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_CUSTOM_CCM_T > ( ) , 96usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_CUSTOM_CCM_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_CUSTOM_CCM_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_CUSTOM_CCM_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CUSTOM_CCM_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CUSTOM_CCM_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CUSTOM_CCM_T > ( ) ) ) . enable as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CUSTOM_CCM_T ) , "::" , stringify ! ( enable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CUSTOM_CCM_T > ( ) ) ) . ccm as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CUSTOM_CCM_T ) , "::" , stringify ! ( ccm ) ) ) ; } pub const MMAL_PARAMETER_DISPLAYREGION : _bindgen_ty_25 = 131072 ; pub const MMAL_PARAMETER_SUPPORTED_PROFILES : _bindgen_ty_25 = 131073 ; pub const MMAL_PARAMETER_PROFILE : _bindgen_ty_25 = 131074 ; pub const MMAL_PARAMETER_INTRAPERIOD : _bindgen_ty_25 = 131075 ; pub const MMAL_PARAMETER_RATECONTROL : _bindgen_ty_25 = 131076 ; pub const MMAL_PARAMETER_NALUNITFORMAT : _bindgen_ty_25 = 131077 ; pub const MMAL_PARAMETER_MINIMISE_FRAGMENTATION : _bindgen_ty_25 = 131078 ; pub const MMAL_PARAMETER_MB_ROWS_PER_SLICE : _bindgen_ty_25 = 131079 ; pub const MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION : _bindgen_ty_25 = 131080 ; pub const MMAL_PARAMETER_VIDEO_EEDE_ENABLE : _bindgen_ty_25 = 131081 ; pub const MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE : _bindgen_ty_25 = 131082 ; pub const MMAL_PARAMETER_VIDEO_REQUEST_I_FRAME : _bindgen_ty_25 = 131083 ; pub const MMAL_PARAMETER_VIDEO_INTRA_REFRESH : _bindgen_ty_25 = 131084 ; pub const MMAL_PARAMETER_VIDEO_IMMUTABLE_INPUT : _bindgen_ty_25 = 131085 ; pub const MMAL_PARAMETER_VIDEO_BIT_RATE : _bindgen_ty_25 = 131086 ; pub const MMAL_PARAMETER_VIDEO_FRAME_RATE : _bindgen_ty_25 = 131087 ; pub const MMAL_PARAMETER_VIDEO_ENCODE_MIN_QUANT : _bindgen_ty_25 = 131088 ; pub const MMAL_PARAMETER_VIDEO_ENCODE_MAX_QUANT : _bindgen_ty_25 = 131089 ; pub const MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL : _bindgen_ty_25 = 131090 ; pub const MMAL_PARAMETER_EXTRA_BUFFERS : _bindgen_ty_25 = 131091 ; pub const MMAL_PARAMETER_VIDEO_ALIGN_HORIZ : _bindgen_ty_25 = 131092 ; pub const MMAL_PARAMETER_VIDEO_ALIGN_VERT : _bindgen_ty_25 = 131093 ; pub const MMAL_PARAMETER_VIDEO_DROPPABLE_PFRAMES : _bindgen_ty_25 = 131094 ; pub const MMAL_PARAMETER_VIDEO_ENCODE_INITIAL_QUANT : _bindgen_ty_25 = 131095 ; pub const MMAL_PARAMETER_VIDEO_ENCODE_QP_P : _bindgen_ty_25 = 131096 ; pub const MMAL_PARAMETER_VIDEO_ENCODE_RC_SLICE_DQUANT : _bindgen_ty_25 = 131097 ; pub const MMAL_PARAMETER_VIDEO_ENCODE_FRAME_LIMIT_BITS : _bindgen_ty_25 = 131098 ; pub const MMAL_PARAMETER_VIDEO_ENCODE_PEAK_RATE : _bindgen_ty_25 = 131099 ; pub const MMAL_PARAMETER_VIDEO_ENCODE_H264_DISABLE_CABAC : _bindgen_ty_25 = 131100 ; pub const MMAL_PARAMETER_VIDEO_ENCODE_H264_LOW_LATENCY : _bindgen_ty_25 = 131101 ; pub const MMAL_PARAMETER_VIDEO_ENCODE_H264_AU_DELIMITERS : _bindgen_ty_25 = 131102 ; pub const MMAL_PARAMETER_VIDEO_ENCODE_H264_DEBLOCK_IDC : _bindgen_ty_25 = 131103 ; pub const MMAL_PARAMETER_VIDEO_ENCODE_H264_MB_INTRA_MODE : _bindgen_ty_25 = 131104 ; pub const MMAL_PARAMETER_VIDEO_ENCODE_HEADER_ON_OPEN : _bindgen_ty_25 = 131105 ; pub const MMAL_PARAMETER_VIDEO_ENCODE_PRECODE_FOR_QP : _bindgen_ty_25 = 131106 ; pub const MMAL_PARAMETER_VIDEO_DRM_INIT_INFO : _bindgen_ty_25 = 131107 ; pub const MMAL_PARAMETER_VIDEO_TIMESTAMP_FIFO : _bindgen_ty_25 = 131108 ; pub const MMAL_PARAMETER_VIDEO_DECODE_ERROR_CONCEALMENT : _bindgen_ty_25 = 131109 ; pub const MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER : _bindgen_ty_25 = 131110 ; pub const MMAL_PARAMETER_VIDEO_DECODE_CONFIG_VD3 : _bindgen_ty_25 = 131111 ; pub const MMAL_PARAMETER_VIDEO_ENCODE_H264_VCL_HRD_PARAMETERS : _bindgen_ty_25 = 131112 ; pub const MMAL_PARAMETER_VIDEO_ENCODE_H264_LOW_DELAY_HRD_FLAG : _bindgen_ty_25 = 131113 ; pub const MMAL_PARAMETER_VIDEO_ENCODE_INLINE_HEADER : _bindgen_ty_25 = 131114 ; pub const MMAL_PARAMETER_VIDEO_ENCODE_SEI_ENABLE : _bindgen_ty_25 = 131115 ; pub const MMAL_PARAMETER_VIDEO_ENCODE_INLINE_VECTORS : _bindgen_ty_25 = 131116 ; pub const MMAL_PARAMETER_VIDEO_RENDER_STATS : _bindgen_ty_25 = 131117 ; pub const MMAL_PARAMETER_VIDEO_INTERLACE_TYPE : _bindgen_ty_25 = 131118 ; pub const MMAL_PARAMETER_VIDEO_INTERPOLATE_TIMESTAMPS : _bindgen_ty_25 = 131119 ; pub const MMAL_PARAMETER_VIDEO_ENCODE_SPS_TIMING : _bindgen_ty_25 = 131120 ; pub const MMAL_PARAMETER_VIDEO_MAX_NUM_CALLBACKS : _bindgen_ty_25 = 131121 ; pub const MMAL_PARAMETER_VIDEO_SOURCE_PATTERN : _bindgen_ty_25 = 131122 ; pub const MMAL_PARAMETER_VIDEO_ENCODE_SEPARATE_NAL_BUFS : _bindgen_ty_25 = 131123 ; pub const MMAL_PARAMETER_VIDEO_DROPPABLE_PFRAME_LENGTH : _bindgen_ty_25 = 131124 ; pub type _bindgen_ty_25 = u32 ; pub const MMAL_DISPLAYTRANSFORM_T_MMAL_DISPLAY_ROT0 : MMAL_DISPLAYTRANSFORM_T = 0 ; pub const MMAL_DISPLAYTRANSFORM_T_MMAL_DISPLAY_MIRROR_ROT0 : MMAL_DISPLAYTRANSFORM_T = 1 ; pub const MMAL_DISPLAYTRANSFORM_T_MMAL_DISPLAY_MIRROR_ROT180 : MMAL_DISPLAYTRANSFORM_T = 2 ; pub const MMAL_DISPLAYTRANSFORM_T_MMAL_DISPLAY_ROT180 : MMAL_DISPLAYTRANSFORM_T = 3 ; pub const MMAL_DISPLAYTRANSFORM_T_MMAL_DISPLAY_MIRROR_ROT90 : MMAL_DISPLAYTRANSFORM_T = 4 ; pub const MMAL_DISPLAYTRANSFORM_T_MMAL_DISPLAY_ROT270 : MMAL_DISPLAYTRANSFORM_T = 5 ; pub const MMAL_DISPLAYTRANSFORM_T_MMAL_DISPLAY_ROT90 : MMAL_DISPLAYTRANSFORM_T = 6 ; pub const MMAL_DISPLAYTRANSFORM_T_MMAL_DISPLAY_MIRROR_ROT270 : MMAL_DISPLAYTRANSFORM_T = 7 ; pub const MMAL_DISPLAYTRANSFORM_T_MMAL_DISPLAY_DUMMY : MMAL_DISPLAYTRANSFORM_T = 2147483647 ; pub type MMAL_DISPLAYTRANSFORM_T = u32 ; pub const MMAL_DISPLAYMODE_T_MMAL_DISPLAY_MODE_FILL : MMAL_DISPLAYMODE_T = 0 ; pub const MMAL_DISPLAYMODE_T_MMAL_DISPLAY_MODE_LETTERBOX : MMAL_DISPLAYMODE_T = 1 ; pub const MMAL_DISPLAYMODE_T_MMAL_DISPLAY_MODE_STEREO_LEFT_TO_LEFT : MMAL_DISPLAYMODE_T = 2 ; pub const MMAL_DISPLAYMODE_T_MMAL_DISPLAY_MODE_STEREO_TOP_TO_TOP : MMAL_DISPLAYMODE_T = 3 ; pub const MMAL_DISPLAYMODE_T_MMAL_DISPLAY_MODE_STEREO_LEFT_TO_TOP : MMAL_DISPLAYMODE_T = 4 ; pub const MMAL_DISPLAYMODE_T_MMAL_DISPLAY_MODE_STEREO_TOP_TO_LEFT : MMAL_DISPLAYMODE_T = 5 ; pub const MMAL_DISPLAYMODE_T_MMAL_DISPLAY_MODE_DUMMY : MMAL_DISPLAYMODE_T = 2147483647 ; pub type MMAL_DISPLAYMODE_T = u32 ; pub const MMAL_DISPLAYSET_T_MMAL_DISPLAY_SET_NONE : MMAL_DISPLAYSET_T = 0 ; pub const MMAL_DISPLAYSET_T_MMAL_DISPLAY_SET_NUM : MMAL_DISPLAYSET_T = 1 ; pub const MMAL_DISPLAYSET_T_MMAL_DISPLAY_SET_FULLSCREEN : MMAL_DISPLAYSET_T = 2 ; pub const MMAL_DISPLAYSET_T_MMAL_DISPLAY_SET_TRANSFORM : MMAL_DISPLAYSET_T = 4 ; pub const MMAL_DISPLAYSET_T_MMAL_DISPLAY_SET_DEST_RECT : MMAL_DISPLAYSET_T = 8 ; pub const MMAL_DISPLAYSET_T_MMAL_DISPLAY_SET_SRC_RECT : MMAL_DISPLAYSET_T = 16 ; pub const MMAL_DISPLAYSET_T_MMAL_DISPLAY_SET_MODE : MMAL_DISPLAYSET_T = 32 ; pub const MMAL_DISPLAYSET_T_MMAL_DISPLAY_SET_PIXEL : MMAL_DISPLAYSET_T = 64 ; pub const MMAL_DISPLAYSET_T_MMAL_DISPLAY_SET_NOASPECT : MMAL_DISPLAYSET_T = 128 ; pub const MMAL_DISPLAYSET_T_MMAL_DISPLAY_SET_LAYER : MMAL_DISPLAYSET_T = 256 ; pub const MMAL_DISPLAYSET_T_MMAL_DISPLAY_SET_COPYPROTECT : MMAL_DISPLAYSET_T = 512 ; pub const MMAL_DISPLAYSET_T_MMAL_DISPLAY_SET_ALPHA : MMAL_DISPLAYSET_T = 1024 ; pub const MMAL_DISPLAYSET_T_MMAL_DISPLAY_SET_DUMMY : MMAL_DISPLAYSET_T = 2147483647 ; pub type MMAL_DISPLAYSET_T = u32 ; /// This config sets the output display device, as well as the region used
/// on the output display, any display transformation, and some flags to
/// indicate how to scale the image.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_DISPLAYREGION_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// Bitfield that indicates which fields are set and should be used. All
    /// other fields will maintain their current value.
    /// \ref MMAL_DISPLAYSET_T defines the bits that can be combined.
 pub set : u32 , /// Describes the display output device, with 0 typically being a directly
    /// connected LCD display.  The actual values will depend on the hardware.
    /// Code using hard-wired numbers (e.g. 2) is certain to fail.
 pub display_num : u32 , /// Indicates that we are using the full device screen area, rather than
    /// a window of the display.  If zero, then dest_rect is used to specify a
    /// region of the display to use.
 pub fullscreen : MMAL_BOOL_T , /// Indicates any rotation or flipping used to map frames onto the natural
    /// display orientation.
 pub transform : MMAL_DISPLAYTRANSFORM_T , /// Where to display the frame within the screen, if fullscreen is zero.
 pub dest_rect : MMAL_RECT_T , /// Indicates which area of the frame to display. If all values are zero,
    /// the whole frame will be used.
 pub src_rect : MMAL_RECT_T , /// If set to non-zero, indicates that any display scaling should disregard
    /// the aspect ratio of the frame region being displayed.
 pub noaspect : MMAL_BOOL_T , /// Indicates how the image should be scaled to fit the display. \code
    /// MMAL_DISPLAY_MODE_FILL \endcode indicates that the image should fill the
    /// screen by potentially cropping the frames.  Setting \code mode \endcode
    /// to \code MMAL_DISPLAY_MODE_LETTERBOX \endcode indicates that all the source
    /// region should be displayed and black bars added if necessary.
 pub mode : MMAL_DISPLAYMODE_T , /// If non-zero, defines the width of a source pixel relative to \code pixel_y
    /// \endcode.  If zero, then pixels default to being square.
 pub pixel_x : u32 , /// If non-zero, defines the height of a source pixel relative to \code pixel_x
    /// \endcode.  If zero, then pixels default to being square.
 pub pixel_y : u32 , /// Sets the relative depth of the images, with greater values being in front
    /// of smaller values.
 pub layer : i32 , /// Set to non-zero to ensure copy protection is used on output.
 pub copyprotect_required : MMAL_BOOL_T , /// Level of opacity of the layer, where zero is fully transparent and
    /// 255 is fully opaque.
 pub alpha : u32 , } # [ test ] fn bindgen_test_layout_MMAL_DISPLAYREGION_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_DISPLAYREGION_T > ( ) , 84usize , concat ! ( "Size of: " , stringify ! ( MMAL_DISPLAYREGION_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_DISPLAYREGION_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_DISPLAYREGION_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_DISPLAYREGION_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_DISPLAYREGION_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_DISPLAYREGION_T > ( ) ) ) . set as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_DISPLAYREGION_T ) , "::" , stringify ! ( set ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_DISPLAYREGION_T > ( ) ) ) . display_num as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_DISPLAYREGION_T ) , "::" , stringify ! ( display_num ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_DISPLAYREGION_T > ( ) ) ) . fullscreen as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_DISPLAYREGION_T ) , "::" , stringify ! ( fullscreen ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_DISPLAYREGION_T > ( ) ) ) . transform as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_DISPLAYREGION_T ) , "::" , stringify ! ( transform ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_DISPLAYREGION_T > ( ) ) ) . dest_rect as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_DISPLAYREGION_T ) , "::" , stringify ! ( dest_rect ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_DISPLAYREGION_T > ( ) ) ) . src_rect as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_DISPLAYREGION_T ) , "::" , stringify ! ( src_rect ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_DISPLAYREGION_T > ( ) ) ) . noaspect as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_DISPLAYREGION_T ) , "::" , stringify ! ( noaspect ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_DISPLAYREGION_T > ( ) ) ) . mode as * const _ as usize } , 60usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_DISPLAYREGION_T ) , "::" , stringify ! ( mode ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_DISPLAYREGION_T > ( ) ) ) . pixel_x as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_DISPLAYREGION_T ) , "::" , stringify ! ( pixel_x ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_DISPLAYREGION_T > ( ) ) ) . pixel_y as * const _ as usize } , 68usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_DISPLAYREGION_T ) , "::" , stringify ! ( pixel_y ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_DISPLAYREGION_T > ( ) ) ) . layer as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_DISPLAYREGION_T ) , "::" , stringify ! ( layer ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_DISPLAYREGION_T > ( ) ) ) . copyprotect_required as * const _ as usize } , 76usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_DISPLAYREGION_T ) , "::" , stringify ! ( copyprotect_required ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_DISPLAYREGION_T > ( ) ) ) . alpha as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_DISPLAYREGION_T ) , "::" , stringify ! ( alpha ) ) ) ; } pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H263_BASELINE : MMAL_VIDEO_PROFILE_T = 0 ; pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H263_H320CODING : MMAL_VIDEO_PROFILE_T = 1 ; pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H263_BACKWARDCOMPATIBLE : MMAL_VIDEO_PROFILE_T = 2 ; pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H263_ISWV2 : MMAL_VIDEO_PROFILE_T = 3 ; pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H263_ISWV3 : MMAL_VIDEO_PROFILE_T = 4 ; pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H263_HIGHCOMPRESSION : MMAL_VIDEO_PROFILE_T = 5 ; pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H263_INTERNET : MMAL_VIDEO_PROFILE_T = 6 ; pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H263_INTERLACE : MMAL_VIDEO_PROFILE_T = 7 ; pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H263_HIGHLATENCY : MMAL_VIDEO_PROFILE_T = 8 ; pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_SIMPLE : MMAL_VIDEO_PROFILE_T = 9 ; pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_SIMPLESCALABLE : MMAL_VIDEO_PROFILE_T = 10 ; pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_CORE : MMAL_VIDEO_PROFILE_T = 11 ; pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_MAIN : MMAL_VIDEO_PROFILE_T = 12 ; pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_NBIT : MMAL_VIDEO_PROFILE_T = 13 ; pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_SCALABLETEXTURE : MMAL_VIDEO_PROFILE_T = 14 ; pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_SIMPLEFACE : MMAL_VIDEO_PROFILE_T = 15 ; pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_SIMPLEFBA : MMAL_VIDEO_PROFILE_T = 16 ; pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_BASICANIMATED : MMAL_VIDEO_PROFILE_T = 17 ; pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_HYBRID : MMAL_VIDEO_PROFILE_T = 18 ; pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_ADVANCEDREALTIME : MMAL_VIDEO_PROFILE_T = 19 ; pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_CORESCALABLE : MMAL_VIDEO_PROFILE_T = 20 ; pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_ADVANCEDCODING : MMAL_VIDEO_PROFILE_T = 21 ; pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_ADVANCEDCORE : MMAL_VIDEO_PROFILE_T = 22 ; pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_ADVANCEDSCALABLE : MMAL_VIDEO_PROFILE_T = 23 ; pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_ADVANCEDSIMPLE : MMAL_VIDEO_PROFILE_T = 24 ; pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H264_BASELINE : MMAL_VIDEO_PROFILE_T = 25 ; pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H264_MAIN : MMAL_VIDEO_PROFILE_T = 26 ; pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H264_EXTENDED : MMAL_VIDEO_PROFILE_T = 27 ; pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H264_HIGH : MMAL_VIDEO_PROFILE_T = 28 ; pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H264_HIGH10 : MMAL_VIDEO_PROFILE_T = 29 ; pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H264_HIGH422 : MMAL_VIDEO_PROFILE_T = 30 ; pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H264_HIGH444 : MMAL_VIDEO_PROFILE_T = 31 ; pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H264_CONSTRAINED_BASELINE : MMAL_VIDEO_PROFILE_T = 32 ; pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_DUMMY : MMAL_VIDEO_PROFILE_T = 2147483647 ; pub type MMAL_VIDEO_PROFILE_T = u32 ; pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H263_10 : MMAL_VIDEO_LEVEL_T = 0 ; pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H263_20 : MMAL_VIDEO_LEVEL_T = 1 ; pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H263_30 : MMAL_VIDEO_LEVEL_T = 2 ; pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H263_40 : MMAL_VIDEO_LEVEL_T = 3 ; pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H263_45 : MMAL_VIDEO_LEVEL_T = 4 ; pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H263_50 : MMAL_VIDEO_LEVEL_T = 5 ; pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H263_60 : MMAL_VIDEO_LEVEL_T = 6 ; pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H263_70 : MMAL_VIDEO_LEVEL_T = 7 ; pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_MP4V_0 : MMAL_VIDEO_LEVEL_T = 8 ; pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_MP4V_0b : MMAL_VIDEO_LEVEL_T = 9 ; pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_MP4V_1 : MMAL_VIDEO_LEVEL_T = 10 ; pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_MP4V_2 : MMAL_VIDEO_LEVEL_T = 11 ; pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_MP4V_3 : MMAL_VIDEO_LEVEL_T = 12 ; pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_MP4V_4 : MMAL_VIDEO_LEVEL_T = 13 ; pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_MP4V_4a : MMAL_VIDEO_LEVEL_T = 14 ; pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_MP4V_5 : MMAL_VIDEO_LEVEL_T = 15 ; pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_MP4V_6 : MMAL_VIDEO_LEVEL_T = 16 ; pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_1 : MMAL_VIDEO_LEVEL_T = 17 ; pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_1b : MMAL_VIDEO_LEVEL_T = 18 ; pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_11 : MMAL_VIDEO_LEVEL_T = 19 ; pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_12 : MMAL_VIDEO_LEVEL_T = 20 ; pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_13 : MMAL_VIDEO_LEVEL_T = 21 ; pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_2 : MMAL_VIDEO_LEVEL_T = 22 ; pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_21 : MMAL_VIDEO_LEVEL_T = 23 ; pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_22 : MMAL_VIDEO_LEVEL_T = 24 ; pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_3 : MMAL_VIDEO_LEVEL_T = 25 ; pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_31 : MMAL_VIDEO_LEVEL_T = 26 ; pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_32 : MMAL_VIDEO_LEVEL_T = 27 ; pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_4 : MMAL_VIDEO_LEVEL_T = 28 ; pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_41 : MMAL_VIDEO_LEVEL_T = 29 ; pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_42 : MMAL_VIDEO_LEVEL_T = 30 ; pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_5 : MMAL_VIDEO_LEVEL_T = 31 ; pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_51 : MMAL_VIDEO_LEVEL_T = 32 ; pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_DUMMY : MMAL_VIDEO_LEVEL_T = 2147483647 ; pub type MMAL_VIDEO_LEVEL_T = u32 ; /// Video profile and level setting.
/// This is a variable length structure when querying the supported profiles and
/// levels. To get more than one, pass a structure with more profile/level pairs.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_VIDEO_PROFILE_T { pub hdr : MMAL_PARAMETER_HEADER_T , pub profile : [ MMAL_PARAMETER_VIDEO_PROFILE_T__bindgen_ty_1 ; 1usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_VIDEO_PROFILE_T__bindgen_ty_1 { pub profile : MMAL_VIDEO_PROFILE_T , pub level : MMAL_VIDEO_LEVEL_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_PROFILE_T__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_VIDEO_PROFILE_T__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_VIDEO_PROFILE_T__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_VIDEO_PROFILE_T__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_VIDEO_PROFILE_T__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_PROFILE_T__bindgen_ty_1 > ( ) ) ) . profile as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_PROFILE_T__bindgen_ty_1 ) , "::" , stringify ! ( profile ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_PROFILE_T__bindgen_ty_1 > ( ) ) ) . level as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_PROFILE_T__bindgen_ty_1 ) , "::" , stringify ! ( level ) ) ) ; } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_PROFILE_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_VIDEO_PROFILE_T > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_VIDEO_PROFILE_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_VIDEO_PROFILE_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_VIDEO_PROFILE_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_PROFILE_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_PROFILE_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_PROFILE_T > ( ) ) ) . profile as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_PROFILE_T ) , "::" , stringify ! ( profile ) ) ) ; } pub const MMAL_VIDEO_RATECONTROL_T_MMAL_VIDEO_RATECONTROL_DEFAULT : MMAL_VIDEO_RATECONTROL_T = 0 ; pub const MMAL_VIDEO_RATECONTROL_T_MMAL_VIDEO_RATECONTROL_VARIABLE : MMAL_VIDEO_RATECONTROL_T = 1 ; pub const MMAL_VIDEO_RATECONTROL_T_MMAL_VIDEO_RATECONTROL_CONSTANT : MMAL_VIDEO_RATECONTROL_T = 2 ; pub const MMAL_VIDEO_RATECONTROL_T_MMAL_VIDEO_RATECONTROL_VARIABLE_SKIP_FRAMES : MMAL_VIDEO_RATECONTROL_T = 3 ; pub const MMAL_VIDEO_RATECONTROL_T_MMAL_VIDEO_RATECONTROL_CONSTANT_SKIP_FRAMES : MMAL_VIDEO_RATECONTROL_T = 4 ; pub const MMAL_VIDEO_RATECONTROL_T_MMAL_VIDEO_RATECONTROL_DUMMY : MMAL_VIDEO_RATECONTROL_T = 2147483647 ; pub type MMAL_VIDEO_RATECONTROL_T = u32 ; pub const MMAL_VIDEO_INTRA_REFRESH_T_MMAL_VIDEO_INTRA_REFRESH_CYCLIC : MMAL_VIDEO_INTRA_REFRESH_T = 0 ; pub const MMAL_VIDEO_INTRA_REFRESH_T_MMAL_VIDEO_INTRA_REFRESH_ADAPTIVE : MMAL_VIDEO_INTRA_REFRESH_T = 1 ; pub const MMAL_VIDEO_INTRA_REFRESH_T_MMAL_VIDEO_INTRA_REFRESH_BOTH : MMAL_VIDEO_INTRA_REFRESH_T = 2 ; pub const MMAL_VIDEO_INTRA_REFRESH_T_MMAL_VIDEO_INTRA_REFRESH_KHRONOSEXTENSIONS : MMAL_VIDEO_INTRA_REFRESH_T = 1862270976 ; pub const MMAL_VIDEO_INTRA_REFRESH_T_MMAL_VIDEO_INTRA_REFRESH_VENDORSTARTUNUSED : MMAL_VIDEO_INTRA_REFRESH_T = 2130706432 ; pub const MMAL_VIDEO_INTRA_REFRESH_T_MMAL_VIDEO_INTRA_REFRESH_CYCLIC_MROWS : MMAL_VIDEO_INTRA_REFRESH_T = 2130706433 ; pub const MMAL_VIDEO_INTRA_REFRESH_T_MMAL_VIDEO_INTRA_REFRESH_PSEUDO_RAND : MMAL_VIDEO_INTRA_REFRESH_T = 2130706434 ; pub const MMAL_VIDEO_INTRA_REFRESH_T_MMAL_VIDEO_INTRA_REFRESH_MAX : MMAL_VIDEO_INTRA_REFRESH_T = 2130706435 ; pub const MMAL_VIDEO_INTRA_REFRESH_T_MMAL_VIDEO_INTRA_REFRESH_DUMMY : MMAL_VIDEO_INTRA_REFRESH_T = 2147483647 ; pub type MMAL_VIDEO_INTRA_REFRESH_T = u32 ; pub const MMAL_VIDEO_ENCODE_RC_MODEL_T_MMAL_VIDEO_ENCODER_RC_MODEL_DEFAULT : MMAL_VIDEO_ENCODE_RC_MODEL_T = 0 ; pub const MMAL_VIDEO_ENCODE_RC_MODEL_T_MMAL_VIDEO_ENCODER_RC_MODEL_JVT : MMAL_VIDEO_ENCODE_RC_MODEL_T = 0 ; pub const MMAL_VIDEO_ENCODE_RC_MODEL_T_MMAL_VIDEO_ENCODER_RC_MODEL_VOWIFI : MMAL_VIDEO_ENCODE_RC_MODEL_T = 1 ; pub const MMAL_VIDEO_ENCODE_RC_MODEL_T_MMAL_VIDEO_ENCODER_RC_MODEL_CBR : MMAL_VIDEO_ENCODE_RC_MODEL_T = 2 ; pub const MMAL_VIDEO_ENCODE_RC_MODEL_T_MMAL_VIDEO_ENCODER_RC_MODEL_LAST : MMAL_VIDEO_ENCODE_RC_MODEL_T = 3 ; pub const MMAL_VIDEO_ENCODE_RC_MODEL_T_MMAL_VIDEO_ENCODER_RC_MODEL_DUMMY : MMAL_VIDEO_ENCODE_RC_MODEL_T = 2147483647 ; pub type MMAL_VIDEO_ENCODE_RC_MODEL_T = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL_T { pub hdr : MMAL_PARAMETER_HEADER_T , pub rc_model : MMAL_VIDEO_ENCODE_RC_MODEL_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL_T > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL_T > ( ) ) ) . rc_model as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL_T ) , "::" , stringify ! ( rc_model ) ) ) ; } /// Video rate control setting
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_VIDEO_RATECONTROL_T { pub hdr : MMAL_PARAMETER_HEADER_T , pub control : MMAL_VIDEO_RATECONTROL_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_RATECONTROL_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_VIDEO_RATECONTROL_T > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_VIDEO_RATECONTROL_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_VIDEO_RATECONTROL_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_VIDEO_RATECONTROL_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_RATECONTROL_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_RATECONTROL_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_RATECONTROL_T > ( ) ) ) . control as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_RATECONTROL_T ) , "::" , stringify ! ( control ) ) ) ; } pub const MMAL_VIDEO_ENCODE_H264_MB_INTRA_MODES_T_MMAL_VIDEO_ENCODER_H264_MB_4x4_INTRA : MMAL_VIDEO_ENCODE_H264_MB_INTRA_MODES_T = 1 ; pub const MMAL_VIDEO_ENCODE_H264_MB_INTRA_MODES_T_MMAL_VIDEO_ENCODER_H264_MB_8x8_INTRA : MMAL_VIDEO_ENCODE_H264_MB_INTRA_MODES_T = 2 ; pub const MMAL_VIDEO_ENCODE_H264_MB_INTRA_MODES_T_MMAL_VIDEO_ENCODER_H264_MB_16x16_INTRA : MMAL_VIDEO_ENCODE_H264_MB_INTRA_MODES_T = 4 ; pub const MMAL_VIDEO_ENCODE_H264_MB_INTRA_MODES_T_MMAL_VIDEO_ENCODER_H264_MB_INTRA_DUMMY : MMAL_VIDEO_ENCODE_H264_MB_INTRA_MODES_T = 2147483647 ; pub type MMAL_VIDEO_ENCODE_H264_MB_INTRA_MODES_T = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_VIDEO_ENCODER_H264_MB_INTRA_MODES_T { pub hdr : MMAL_PARAMETER_HEADER_T , pub mb_mode : MMAL_VIDEO_ENCODE_H264_MB_INTRA_MODES_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_ENCODER_H264_MB_INTRA_MODES_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_VIDEO_ENCODER_H264_MB_INTRA_MODES_T > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_VIDEO_ENCODER_H264_MB_INTRA_MODES_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_VIDEO_ENCODER_H264_MB_INTRA_MODES_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_VIDEO_ENCODER_H264_MB_INTRA_MODES_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_ENCODER_H264_MB_INTRA_MODES_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_ENCODER_H264_MB_INTRA_MODES_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_ENCODER_H264_MB_INTRA_MODES_T > ( ) ) ) . mb_mode as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_ENCODER_H264_MB_INTRA_MODES_T ) , "::" , stringify ! ( mb_mode ) ) ) ; } pub const MMAL_VIDEO_NALUNITFORMAT_T_MMAL_VIDEO_NALUNITFORMAT_STARTCODES : MMAL_VIDEO_NALUNITFORMAT_T = 1 ; pub const MMAL_VIDEO_NALUNITFORMAT_T_MMAL_VIDEO_NALUNITFORMAT_NALUNITPERBUFFER : MMAL_VIDEO_NALUNITFORMAT_T = 2 ; pub const MMAL_VIDEO_NALUNITFORMAT_T_MMAL_VIDEO_NALUNITFORMAT_ONEBYTEINTERLEAVELENGTH : MMAL_VIDEO_NALUNITFORMAT_T = 4 ; pub const MMAL_VIDEO_NALUNITFORMAT_T_MMAL_VIDEO_NALUNITFORMAT_TWOBYTEINTERLEAVELENGTH : MMAL_VIDEO_NALUNITFORMAT_T = 8 ; pub const MMAL_VIDEO_NALUNITFORMAT_T_MMAL_VIDEO_NALUNITFORMAT_FOURBYTEINTERLEAVELENGTH : MMAL_VIDEO_NALUNITFORMAT_T = 16 ; pub const MMAL_VIDEO_NALUNITFORMAT_T_MMAL_VIDEO_NALUNITFORMAT_DUMMY : MMAL_VIDEO_NALUNITFORMAT_T = 2147483647 ; pub type MMAL_VIDEO_NALUNITFORMAT_T = u32 ; /// NAL unit format setting
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_VIDEO_NALUNITFORMAT_T { pub hdr : MMAL_PARAMETER_HEADER_T , pub format : MMAL_VIDEO_NALUNITFORMAT_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_NALUNITFORMAT_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_VIDEO_NALUNITFORMAT_T > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_VIDEO_NALUNITFORMAT_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_VIDEO_NALUNITFORMAT_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_VIDEO_NALUNITFORMAT_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_NALUNITFORMAT_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_NALUNITFORMAT_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_NALUNITFORMAT_T > ( ) ) ) . format as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_NALUNITFORMAT_T ) , "::" , stringify ! ( format ) ) ) ; } /// H264 Only: Overrides for max macro-blocks per second, max framesize,
/// and max bitrates. This overrides the default maximums for the configured level.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T { pub hdr : MMAL_PARAMETER_HEADER_T , pub custom_max_mbps : u32 , pub custom_max_fs : u32 , pub custom_max_br_and_cpb : u32 , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T > ( ) , 20usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T > ( ) ) ) . custom_max_mbps as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T ) , "::" , stringify ! ( custom_max_mbps ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T > ( ) ) ) . custom_max_fs as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T ) , "::" , stringify ! ( custom_max_fs ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T > ( ) ) ) . custom_max_br_and_cpb as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T ) , "::" , stringify ! ( custom_max_br_and_cpb ) ) ) ; } /// H264 Only: Overrides for max macro-blocks per second, max framesize,
/// and max bitrates. This overrides the default maximums for the configured level.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T { pub hdr : MMAL_PARAMETER_HEADER_T , pub refresh_mode : MMAL_VIDEO_INTRA_REFRESH_T , pub air_mbs : u32 , pub air_ref : u32 , pub cir_mbs : u32 , pub pir_mbs : u32 , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T > ( ) , 28usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T > ( ) ) ) . refresh_mode as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T ) , "::" , stringify ! ( refresh_mode ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T > ( ) ) ) . air_mbs as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T ) , "::" , stringify ! ( air_mbs ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T > ( ) ) ) . air_ref as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T ) , "::" , stringify ! ( air_ref ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T > ( ) ) ) . cir_mbs as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T ) , "::" , stringify ! ( cir_mbs ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T > ( ) ) ) . pir_mbs as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T ) , "::" , stringify ! ( pir_mbs ) ) ) ; } /// Structure for enabling EEDE, we keep it like this for now, there could be extra fields in the future
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_VIDEO_EEDE_ENABLE_T { pub hdr : MMAL_PARAMETER_HEADER_T , pub enable : u32 , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_EEDE_ENABLE_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_VIDEO_EEDE_ENABLE_T > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_VIDEO_EEDE_ENABLE_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_VIDEO_EEDE_ENABLE_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_VIDEO_EEDE_ENABLE_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_EEDE_ENABLE_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_EEDE_ENABLE_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_EEDE_ENABLE_T > ( ) ) ) . enable as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_EEDE_ENABLE_T ) , "::" , stringify ! ( enable ) ) ) ; } /// Structure for setting lossrate for EEDE, we keep it like this for now, there could be extra fields in the future
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE_T { pub hdr : MMAL_PARAMETER_HEADER_T , pub loss_rate : u32 , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE_T > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE_T > ( ) ) ) . loss_rate as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE_T ) , "::" , stringify ! ( loss_rate ) ) ) ; } /// Structure for setting initial DRM parameters
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T { pub hdr : MMAL_PARAMETER_HEADER_T , pub current_time : u32 , pub ticks_per_sec : u32 , pub lhs : [ u8 ; 32usize ] , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T > ( ) ) ) . current_time as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T ) , "::" , stringify ! ( current_time ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T > ( ) ) ) . ticks_per_sec as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T ) , "::" , stringify ! ( ticks_per_sec ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T > ( ) ) ) . lhs as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T ) , "::" , stringify ! ( lhs ) ) ) ; } /// Structure for requesting a hardware-protected memory buffer
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < Input. Zero size means internal video decoder buffer,
    /// mem_handle and phys_addr not returned in this case
 pub size_wanted : u32 , /// < Input. 1 = protect, 0 = unprotect
 pub protect : u32 , /// < Output. Handle for protected buffer
 pub mem_handle : u32 , /// < Output. Physical memory address of protected buffer
 pub phys_addr : * mut :: std :: os :: raw :: c_void , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T > ( ) ) ) . size_wanted as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T ) , "::" , stringify ! ( size_wanted ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T > ( ) ) ) . protect as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T ) , "::" , stringify ! ( protect ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T > ( ) ) ) . mem_handle as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T ) , "::" , stringify ! ( mem_handle ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T > ( ) ) ) . phys_addr as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T ) , "::" , stringify ! ( phys_addr ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_VIDEO_RENDER_STATS_T { pub hdr : MMAL_PARAMETER_HEADER_T , pub valid : MMAL_BOOL_T , pub match_ : u32 , pub period : u32 , pub phase : u32 , pub pixel_clock_nominal : u32 , pub pixel_clock : u32 , pub hvs_status : u32 , pub dummy : [ u32 ; 2usize ] , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_RENDER_STATS_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_VIDEO_RENDER_STATS_T > ( ) , 44usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_VIDEO_RENDER_STATS_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_VIDEO_RENDER_STATS_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_VIDEO_RENDER_STATS_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_RENDER_STATS_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_RENDER_STATS_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_RENDER_STATS_T > ( ) ) ) . valid as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_RENDER_STATS_T ) , "::" , stringify ! ( valid ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_RENDER_STATS_T > ( ) ) ) . match_ as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_RENDER_STATS_T ) , "::" , stringify ! ( match_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_RENDER_STATS_T > ( ) ) ) . period as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_RENDER_STATS_T ) , "::" , stringify ! ( period ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_RENDER_STATS_T > ( ) ) ) . phase as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_RENDER_STATS_T ) , "::" , stringify ! ( phase ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_RENDER_STATS_T > ( ) ) ) . pixel_clock_nominal as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_RENDER_STATS_T ) , "::" , stringify ! ( pixel_clock_nominal ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_RENDER_STATS_T > ( ) ) ) . pixel_clock as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_RENDER_STATS_T ) , "::" , stringify ! ( pixel_clock ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_RENDER_STATS_T > ( ) ) ) . hvs_status as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_RENDER_STATS_T ) , "::" , stringify ! ( hvs_status ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_RENDER_STATS_T > ( ) ) ) . dummy as * const _ as usize } , 36usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_RENDER_STATS_T ) , "::" , stringify ! ( dummy ) ) ) ; } pub const MMAL_INTERLACETYPE_T_MMAL_InterlaceProgressive : MMAL_INTERLACETYPE_T = 0 ; pub const MMAL_INTERLACETYPE_T_MMAL_InterlaceFieldSingleUpperFirst : MMAL_INTERLACETYPE_T = 1 ; pub const MMAL_INTERLACETYPE_T_MMAL_InterlaceFieldSingleLowerFirst : MMAL_INTERLACETYPE_T = 2 ; pub const MMAL_INTERLACETYPE_T_MMAL_InterlaceFieldsInterleavedUpperFirst : MMAL_INTERLACETYPE_T = 3 ; pub const MMAL_INTERLACETYPE_T_MMAL_InterlaceFieldsInterleavedLowerFirst : MMAL_INTERLACETYPE_T = 4 ; pub const MMAL_INTERLACETYPE_T_MMAL_InterlaceMixed : MMAL_INTERLACETYPE_T = 5 ; pub const MMAL_INTERLACETYPE_T_MMAL_InterlaceKhronosExtensions : MMAL_INTERLACETYPE_T = 1862270976 ; pub const MMAL_INTERLACETYPE_T_MMAL_InterlaceVendorStartUnused : MMAL_INTERLACETYPE_T = 2130706432 ; pub const MMAL_INTERLACETYPE_T_MMAL_InterlaceMax : MMAL_INTERLACETYPE_T = 2147483647 ; pub type MMAL_INTERLACETYPE_T = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < The interlace type of the content
 pub eMode : MMAL_INTERLACETYPE_T , /// < Whether to repeat the first field
 pub bRepeatFirstField : MMAL_BOOL_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T > ( ) ) ) . eMode as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T ) , "::" , stringify ! ( eMode ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T > ( ) ) ) . bRepeatFirstField as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T ) , "::" , stringify ! ( bRepeatFirstField ) ) ) ; } pub const MMAL_SOURCE_PATTERN_T_MMAL_VIDEO_SOURCE_PATTERN_WHITE : MMAL_SOURCE_PATTERN_T = 0 ; pub const MMAL_SOURCE_PATTERN_T_MMAL_VIDEO_SOURCE_PATTERN_BLACK : MMAL_SOURCE_PATTERN_T = 1 ; pub const MMAL_SOURCE_PATTERN_T_MMAL_VIDEO_SOURCE_PATTERN_DIAGONAL : MMAL_SOURCE_PATTERN_T = 2 ; pub const MMAL_SOURCE_PATTERN_T_MMAL_VIDEO_SOURCE_PATTERN_NOISE : MMAL_SOURCE_PATTERN_T = 3 ; pub const MMAL_SOURCE_PATTERN_T_MMAL_VIDEO_SOURCE_PATTERN_RANDOM : MMAL_SOURCE_PATTERN_T = 4 ; pub const MMAL_SOURCE_PATTERN_T_MMAL_VIDEO_SOURCE_PATTERN_COLOUR : MMAL_SOURCE_PATTERN_T = 5 ; pub const MMAL_SOURCE_PATTERN_T_MMAL_VIDEO_SOURCE_PATTERN_BLOCKS : MMAL_SOURCE_PATTERN_T = 6 ; pub const MMAL_SOURCE_PATTERN_T_MMAL_VIDEO_SOURCE_PATTERN_SWIRLY : MMAL_SOURCE_PATTERN_T = 7 ; pub const MMAL_SOURCE_PATTERN_T_MMAL_VIDEO_SOURCE_PATTERN_DUMMY : MMAL_SOURCE_PATTERN_T = 2147483647 ; pub type MMAL_SOURCE_PATTERN_T = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T { pub hdr : MMAL_PARAMETER_HEADER_T , pub pattern : MMAL_SOURCE_PATTERN_T , /// < Colour for PATTERN_COLOUR mode
 pub param : u32 , /// < Number of frames to produce. 0 for continuous.
 pub framecount : u32 , /// < Framerate used when determining buffer timestamps
 pub framerate : MMAL_RATIONAL_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T > ( ) , 28usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T > ( ) ) ) . pattern as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T ) , "::" , stringify ! ( pattern ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T > ( ) ) ) . param as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T ) , "::" , stringify ! ( param ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T > ( ) ) ) . framecount as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T ) , "::" , stringify ! ( framecount ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T > ( ) ) ) . framerate as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T ) , "::" , stringify ! ( framerate ) ) ) ; } pub const MMAL_PARAMETER_AUDIO_DESTINATION : _bindgen_ty_26 = 196608 ; pub const MMAL_PARAMETER_AUDIO_LATENCY_TARGET : _bindgen_ty_26 = 196609 ; pub const MMAL_PARAMETER_AUDIO_SOURCE : _bindgen_ty_26 = 196610 ; pub const MMAL_PARAMETER_AUDIO_PASSTHROUGH : _bindgen_ty_26 = 196611 ; pub type _bindgen_ty_26 = u32 ; /// Audio latency target to maintain.
/// These settings are used to adjust the clock speed in order
/// to match the measured audio latency to a specified value.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < whether this mode is enabled
 pub enable : MMAL_BOOL_T , /// < number of latency samples to filter on, good value: 1
 pub filter : u32 , /// < target latency (microseconds)
 pub target : u32 , /// < shift for storing latency values, good value: 7
 pub shift : u32 , /// < multiplier for speed changes, in 24.8 format, good value: 256-512
 pub speed_factor : i32 , /// < divider for comparing latency versus gradiant, good value: 300
 pub inter_factor : i32 , /// < limit for speed change before nSpeedFactor is applied, good value: 100
 pub adj_cap : i32 , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T > ( ) , 36usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T > ( ) ) ) . enable as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T ) , "::" , stringify ! ( enable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T > ( ) ) ) . filter as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T ) , "::" , stringify ! ( filter ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T > ( ) ) ) . target as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T ) , "::" , stringify ! ( target ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T > ( ) ) ) . shift as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T ) , "::" , stringify ! ( shift ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T > ( ) ) ) . speed_factor as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T ) , "::" , stringify ! ( speed_factor ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T > ( ) ) ) . inter_factor as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T ) , "::" , stringify ! ( inter_factor ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T > ( ) ) ) . adj_cap as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T ) , "::" , stringify ! ( adj_cap ) ) ) ; } /// Thresholds used when updating a clock's media-time
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_CLOCK_UPDATE_THRESHOLD_T { /// Time differences below this threshold are ignored (microseconds)
 pub threshold_lower : i64 , /// Time differences above this threshold reset media-time (microseconds)
 pub threshold_upper : i64 , } # [ test ] fn bindgen_test_layout_MMAL_CLOCK_UPDATE_THRESHOLD_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_CLOCK_UPDATE_THRESHOLD_T > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( MMAL_CLOCK_UPDATE_THRESHOLD_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_CLOCK_UPDATE_THRESHOLD_T > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( MMAL_CLOCK_UPDATE_THRESHOLD_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CLOCK_UPDATE_THRESHOLD_T > ( ) ) ) . threshold_lower as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CLOCK_UPDATE_THRESHOLD_T ) , "::" , stringify ! ( threshold_lower ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CLOCK_UPDATE_THRESHOLD_T > ( ) ) ) . threshold_upper as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CLOCK_UPDATE_THRESHOLD_T ) , "::" , stringify ! ( threshold_upper ) ) ) ; } /// Threshold for detecting a discontinuity in media-time
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_CLOCK_DISCONT_THRESHOLD_T { /// Threshold after which backward jumps in media-time are treated as a
    /// discontinuity (microseconds)
 pub threshold : i64 , /// Duration in microseconds for which a discontinuity applies (wall-time)
 pub duration : i64 , } # [ test ] fn bindgen_test_layout_MMAL_CLOCK_DISCONT_THRESHOLD_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_CLOCK_DISCONT_THRESHOLD_T > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( MMAL_CLOCK_DISCONT_THRESHOLD_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_CLOCK_DISCONT_THRESHOLD_T > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( MMAL_CLOCK_DISCONT_THRESHOLD_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CLOCK_DISCONT_THRESHOLD_T > ( ) ) ) . threshold as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CLOCK_DISCONT_THRESHOLD_T ) , "::" , stringify ! ( threshold ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CLOCK_DISCONT_THRESHOLD_T > ( ) ) ) . duration as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CLOCK_DISCONT_THRESHOLD_T ) , "::" , stringify ! ( duration ) ) ) ; } /// Threshold applied to client callback requests
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_CLOCK_REQUEST_THRESHOLD_T { /// Frames with a media-time difference (compared to current media-time)
    /// above this threshold are dropped (microseconds)
 pub threshold : i64 , /// Enable/disable the request threshold
 pub threshold_enable : MMAL_BOOL_T , } # [ test ] fn bindgen_test_layout_MMAL_CLOCK_REQUEST_THRESHOLD_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_CLOCK_REQUEST_THRESHOLD_T > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( MMAL_CLOCK_REQUEST_THRESHOLD_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_CLOCK_REQUEST_THRESHOLD_T > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( MMAL_CLOCK_REQUEST_THRESHOLD_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CLOCK_REQUEST_THRESHOLD_T > ( ) ) ) . threshold as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CLOCK_REQUEST_THRESHOLD_T ) , "::" , stringify ! ( threshold ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CLOCK_REQUEST_THRESHOLD_T > ( ) ) ) . threshold_enable as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CLOCK_REQUEST_THRESHOLD_T ) , "::" , stringify ! ( threshold_enable ) ) ) ; } /// Structure for passing buffer information to a clock port
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_CLOCK_BUFFER_INFO_T { pub time_stamp : i64 , pub arrival_time : u32 , } # [ test ] fn bindgen_test_layout_MMAL_CLOCK_BUFFER_INFO_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_CLOCK_BUFFER_INFO_T > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( MMAL_CLOCK_BUFFER_INFO_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_CLOCK_BUFFER_INFO_T > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( MMAL_CLOCK_BUFFER_INFO_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CLOCK_BUFFER_INFO_T > ( ) ) ) . time_stamp as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CLOCK_BUFFER_INFO_T ) , "::" , stringify ! ( time_stamp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CLOCK_BUFFER_INFO_T > ( ) ) ) . arrival_time as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CLOCK_BUFFER_INFO_T ) , "::" , stringify ! ( arrival_time ) ) ) ; } /// Clock latency settings used by the clock component
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_CLOCK_LATENCY_T { /// < target latency (microseconds)
 pub target : i64 , /// < duration of one attack period (microseconds)
 pub attack_period : i64 , /// < amount by which media-time will be adjusted
    /// every attack_period (microseconds)
 pub attack_rate : i64 , } # [ test ] fn bindgen_test_layout_MMAL_CLOCK_LATENCY_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_CLOCK_LATENCY_T > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( MMAL_CLOCK_LATENCY_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_CLOCK_LATENCY_T > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( MMAL_CLOCK_LATENCY_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CLOCK_LATENCY_T > ( ) ) ) . target as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CLOCK_LATENCY_T ) , "::" , stringify ! ( target ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CLOCK_LATENCY_T > ( ) ) ) . attack_period as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CLOCK_LATENCY_T ) , "::" , stringify ! ( attack_period ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CLOCK_LATENCY_T > ( ) ) ) . attack_rate as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CLOCK_LATENCY_T ) , "::" , stringify ! ( attack_rate ) ) ) ; } /// Clock event used to pass data between clock ports and a client.
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct MMAL_CLOCK_EVENT_T { /// 4cc event id
 pub id : u32 , /// 4cc event magic
 pub magic : u32 , /// buffer associated with this event (can be NULL)
 pub buffer : * mut MMAL_BUFFER_HEADER_T , /// pad to 64-bit boundary
 pub padding0 : u32 , pub data : MMAL_CLOCK_EVENT_T__bindgen_ty_1 , /// pad to 64-bit boundary
 pub padding1 : u64 , } /// additional event data (type-specific)
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union MMAL_CLOCK_EVENT_T__bindgen_ty_1 { /// used either for clock reference or clock state
 pub enable : MMAL_BOOL_T , /// new clock scale
 pub scale : MMAL_RATIONAL_T , /// new media-time
 pub media_time : i64 , /// media-time update threshold
 pub update_threshold : MMAL_CLOCK_UPDATE_THRESHOLD_T , /// media-time discontinuity threshold
 pub discont_threshold : MMAL_CLOCK_DISCONT_THRESHOLD_T , /// client callback request threshold
 pub request_threshold : MMAL_CLOCK_REQUEST_THRESHOLD_T , /// input/output buffer information
 pub buffer : MMAL_CLOCK_BUFFER_INFO_T , /// clock latency setting
 pub latency : MMAL_CLOCK_LATENCY_T , _bindgen_union_align : [ u64 ; 3usize ] , } # [ test ] fn bindgen_test_layout_MMAL_CLOCK_EVENT_T__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_CLOCK_EVENT_T__bindgen_ty_1 > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( MMAL_CLOCK_EVENT_T__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_CLOCK_EVENT_T__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( MMAL_CLOCK_EVENT_T__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CLOCK_EVENT_T__bindgen_ty_1 > ( ) ) ) . enable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CLOCK_EVENT_T__bindgen_ty_1 ) , "::" , stringify ! ( enable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CLOCK_EVENT_T__bindgen_ty_1 > ( ) ) ) . scale as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CLOCK_EVENT_T__bindgen_ty_1 ) , "::" , stringify ! ( scale ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CLOCK_EVENT_T__bindgen_ty_1 > ( ) ) ) . media_time as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CLOCK_EVENT_T__bindgen_ty_1 ) , "::" , stringify ! ( media_time ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CLOCK_EVENT_T__bindgen_ty_1 > ( ) ) ) . update_threshold as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CLOCK_EVENT_T__bindgen_ty_1 ) , "::" , stringify ! ( update_threshold ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CLOCK_EVENT_T__bindgen_ty_1 > ( ) ) ) . discont_threshold as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CLOCK_EVENT_T__bindgen_ty_1 ) , "::" , stringify ! ( discont_threshold ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CLOCK_EVENT_T__bindgen_ty_1 > ( ) ) ) . request_threshold as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CLOCK_EVENT_T__bindgen_ty_1 ) , "::" , stringify ! ( request_threshold ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CLOCK_EVENT_T__bindgen_ty_1 > ( ) ) ) . buffer as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CLOCK_EVENT_T__bindgen_ty_1 ) , "::" , stringify ! ( buffer ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CLOCK_EVENT_T__bindgen_ty_1 > ( ) ) ) . latency as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CLOCK_EVENT_T__bindgen_ty_1 ) , "::" , stringify ! ( latency ) ) ) ; } impl :: std :: fmt :: Debug for MMAL_CLOCK_EVENT_T__bindgen_ty_1 { fn fmt ( & self , f : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { write ! ( f , "MMAL_CLOCK_EVENT_T__bindgen_ty_1 {{ union }}" ) } } # [ test ] fn bindgen_test_layout_MMAL_CLOCK_EVENT_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_CLOCK_EVENT_T > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( MMAL_CLOCK_EVENT_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_CLOCK_EVENT_T > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( MMAL_CLOCK_EVENT_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CLOCK_EVENT_T > ( ) ) ) . id as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CLOCK_EVENT_T ) , "::" , stringify ! ( id ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CLOCK_EVENT_T > ( ) ) ) . magic as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CLOCK_EVENT_T ) , "::" , stringify ! ( magic ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CLOCK_EVENT_T > ( ) ) ) . buffer as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CLOCK_EVENT_T ) , "::" , stringify ! ( buffer ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CLOCK_EVENT_T > ( ) ) ) . padding0 as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CLOCK_EVENT_T ) , "::" , stringify ! ( padding0 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CLOCK_EVENT_T > ( ) ) ) . data as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CLOCK_EVENT_T ) , "::" , stringify ! ( data ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CLOCK_EVENT_T > ( ) ) ) . padding1 as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CLOCK_EVENT_T ) , "::" , stringify ! ( padding1 ) ) ) ; } impl :: std :: fmt :: Debug for MMAL_CLOCK_EVENT_T { fn fmt ( & self , f : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { write ! ( f , "MMAL_CLOCK_EVENT_T {{ id: {:?}, magic: {:?}, buffer: {:?}, padding0: {:?}, data: {:?}, padding1: {:?} }}" , self . id , self . magic , self . buffer , self . padding0 , self . data , self . padding1 ) } } pub const MMAL_PARAMETER_CLOCK_REFERENCE : _bindgen_ty_27 = 262144 ; pub const MMAL_PARAMETER_CLOCK_ACTIVE : _bindgen_ty_27 = 262145 ; pub const MMAL_PARAMETER_CLOCK_SCALE : _bindgen_ty_27 = 262146 ; pub const MMAL_PARAMETER_CLOCK_TIME : _bindgen_ty_27 = 262147 ; pub const MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD : _bindgen_ty_27 = 262148 ; pub const MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD : _bindgen_ty_27 = 262149 ; pub const MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD : _bindgen_ty_27 = 262150 ; pub const MMAL_PARAMETER_CLOCK_ENABLE_BUFFER_INFO : _bindgen_ty_27 = 262151 ; pub const MMAL_PARAMETER_CLOCK_FRAME_RATE : _bindgen_ty_27 = 262152 ; pub const MMAL_PARAMETER_CLOCK_LATENCY : _bindgen_ty_27 = 262153 ; pub type _bindgen_ty_27 = u32 ; /// Media-time update thresholds
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T { pub hdr : MMAL_PARAMETER_HEADER_T , pub value : MMAL_CLOCK_UPDATE_THRESHOLD_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T > ( ) ) ) . value as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T ) , "::" , stringify ! ( value ) ) ) ; } /// Media-time discontinuity settings
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T { pub hdr : MMAL_PARAMETER_HEADER_T , pub value : MMAL_CLOCK_DISCONT_THRESHOLD_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T > ( ) ) ) . value as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T ) , "::" , stringify ! ( value ) ) ) ; } /// Media-time future frame drop settings
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T { pub hdr : MMAL_PARAMETER_HEADER_T , pub value : MMAL_CLOCK_REQUEST_THRESHOLD_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T > ( ) ) ) . value as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T ) , "::" , stringify ! ( value ) ) ) ; } /// Clock latency parameter
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_CLOCK_LATENCY_T { pub hdr : MMAL_PARAMETER_HEADER_T , pub value : MMAL_CLOCK_LATENCY_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_CLOCK_LATENCY_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_CLOCK_LATENCY_T > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_CLOCK_LATENCY_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_CLOCK_LATENCY_T > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_CLOCK_LATENCY_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CLOCK_LATENCY_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CLOCK_LATENCY_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CLOCK_LATENCY_T > ( ) ) ) . value as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CLOCK_LATENCY_T ) , "::" , stringify ! ( value ) ) ) ; } /// Generic unsigned 64-bit integer parameter type.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_UINT64_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < Parameter value
 pub value : u64 , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_UINT64_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_UINT64_T > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_UINT64_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_UINT64_T > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_UINT64_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_UINT64_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_UINT64_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_UINT64_T > ( ) ) ) . value as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_UINT64_T ) , "::" , stringify ! ( value ) ) ) ; } /// Generic signed 64-bit integer parameter type.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_INT64_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < Parameter value
 pub value : i64 , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_INT64_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_INT64_T > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_INT64_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_INT64_T > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_INT64_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_INT64_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_INT64_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_INT64_T > ( ) ) ) . value as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_INT64_T ) , "::" , stringify ! ( value ) ) ) ; } /// Generic unsigned 32-bit integer parameter type.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_UINT32_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < Parameter value
 pub value : u32 , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_UINT32_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_UINT32_T > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_UINT32_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_UINT32_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_UINT32_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_UINT32_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_UINT32_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_UINT32_T > ( ) ) ) . value as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_UINT32_T ) , "::" , stringify ! ( value ) ) ) ; } /// Generic signed 32-bit integer parameter type.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_INT32_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < Parameter value
 pub value : i32 , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_INT32_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_INT32_T > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_INT32_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_INT32_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_INT32_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_INT32_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_INT32_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_INT32_T > ( ) ) ) . value as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_INT32_T ) , "::" , stringify ! ( value ) ) ) ; } /// Generic rational parameter type.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_RATIONAL_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < Parameter value
 pub value : MMAL_RATIONAL_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_RATIONAL_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_RATIONAL_T > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_RATIONAL_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_RATIONAL_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_RATIONAL_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_RATIONAL_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_RATIONAL_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_RATIONAL_T > ( ) ) ) . value as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_RATIONAL_T ) , "::" , stringify ! ( value ) ) ) ; } /// Generic boolean parameter type.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_BOOLEAN_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < Parameter value
 pub enable : MMAL_BOOL_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_BOOLEAN_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_BOOLEAN_T > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_BOOLEAN_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_BOOLEAN_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_BOOLEAN_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_BOOLEAN_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_BOOLEAN_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_BOOLEAN_T > ( ) ) ) . enable as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_BOOLEAN_T ) , "::" , stringify ! ( enable ) ) ) ; } /// Generic string parameter type.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_STRING_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < Null-terminated string
 pub str : [ :: std :: os :: raw :: c_char ; 1usize ] , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_STRING_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_STRING_T > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_STRING_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_STRING_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_STRING_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_STRING_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_STRING_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_STRING_T > ( ) ) ) . str as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_STRING_T ) , "::" , stringify ! ( str ) ) ) ; } /// Generic array of bytes parameter type.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_BYTES_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < Array of bytes
 pub data : [ u8 ; 1usize ] , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_BYTES_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_BYTES_T > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_BYTES_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_BYTES_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_BYTES_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_BYTES_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_BYTES_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_BYTES_T > ( ) ) ) . data as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_BYTES_T ) , "::" , stringify ! ( data ) ) ) ; } /// Generic two-dimensional scaling factor type.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_SCALEFACTOR_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < Scaling factor in X-axis
 pub scale_x : MMAL_FIXED_16_16_T , /// < Scaling factor in Y-axis
 pub scale_y : MMAL_FIXED_16_16_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_SCALEFACTOR_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_SCALEFACTOR_T > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_SCALEFACTOR_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_SCALEFACTOR_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_SCALEFACTOR_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_SCALEFACTOR_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_SCALEFACTOR_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_SCALEFACTOR_T > ( ) ) ) . scale_x as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_SCALEFACTOR_T ) , "::" , stringify ! ( scale_x ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_SCALEFACTOR_T > ( ) ) ) . scale_y as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_SCALEFACTOR_T ) , "::" , stringify ! ( scale_y ) ) ) ; } pub const MMAL_PARAM_MIRROR_T_MMAL_PARAM_MIRROR_NONE : MMAL_PARAM_MIRROR_T = 0 ; pub const MMAL_PARAM_MIRROR_T_MMAL_PARAM_MIRROR_VERTICAL : MMAL_PARAM_MIRROR_T = 1 ; pub const MMAL_PARAM_MIRROR_T_MMAL_PARAM_MIRROR_HORIZONTAL : MMAL_PARAM_MIRROR_T = 2 ; pub const MMAL_PARAM_MIRROR_T_MMAL_PARAM_MIRROR_BOTH : MMAL_PARAM_MIRROR_T = 3 ; pub type MMAL_PARAM_MIRROR_T = u32 ; /// Generic mirror parameter type
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_MIRROR_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < Mirror mode
 pub value : MMAL_PARAM_MIRROR_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_MIRROR_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_MIRROR_T > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_MIRROR_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_MIRROR_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_MIRROR_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_MIRROR_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_MIRROR_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_MIRROR_T > ( ) ) ) . value as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_MIRROR_T ) , "::" , stringify ! ( value ) ) ) ; } /// URI parameter type.
/// The parameter may hold an arbitrary length, nul-terminated string as long
/// as the size is set appropriately.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_URI_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < URI string (null-terminated)
 pub uri : [ :: std :: os :: raw :: c_char ; 1usize ] , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_URI_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_URI_T > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_URI_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_URI_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_URI_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_URI_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_URI_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_URI_T > ( ) ) ) . uri as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_URI_T ) , "::" , stringify ! ( uri ) ) ) ; } /// Generic encoding parameter type.
/// The parameter may hold more than one encoding by overriding the size to
/// include a bigger array.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_ENCODING_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < Array of FourCC encodings, see \ref MmalEncodings
 pub encoding : [ u32 ; 1usize ] , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_ENCODING_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_ENCODING_T > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_ENCODING_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_ENCODING_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_ENCODING_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_ENCODING_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_ENCODING_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_ENCODING_T > ( ) ) ) . encoding as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_ENCODING_T ) , "::" , stringify ! ( encoding ) ) ) ; } /// Generic frame-rate parameter type.
/// Frame rates are specified as a rational number, using a pair of integers.
/// Since there can be many valid pairs for the same ratio, a frame-rate may
/// not contain exactly the same pairs of values when read back as it was
/// when set.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_FRAME_RATE_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < Frame-rate value
 pub frame_rate : MMAL_RATIONAL_T , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_FRAME_RATE_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_FRAME_RATE_T > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_FRAME_RATE_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_FRAME_RATE_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_FRAME_RATE_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FRAME_RATE_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FRAME_RATE_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_FRAME_RATE_T > ( ) ) ) . frame_rate as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_FRAME_RATE_T ) , "::" , stringify ! ( frame_rate ) ) ) ; } /// Generic configuration-file setup type.
/// Configuration files are transferred in small chunks. The component can
/// save all the chunks into a buffer, then process the entire file later.
/// This parameter initialises a config file to have the given size.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_CONFIGFILE_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < Size of complete file data
 pub file_size : u32 , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_CONFIGFILE_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_CONFIGFILE_T > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_CONFIGFILE_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_CONFIGFILE_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_CONFIGFILE_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CONFIGFILE_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CONFIGFILE_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CONFIGFILE_T > ( ) ) ) . file_size as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CONFIGFILE_T ) , "::" , stringify ! ( file_size ) ) ) ; } /// Generic configuration-file chunk data type.
/// Once a config file has been initialised, this parameter can be used to
/// write an arbitrary chunk of the file data (limited by the maximum MMAL
/// message size).
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PARAMETER_CONFIGFILE_CHUNK_T { pub hdr : MMAL_PARAMETER_HEADER_T , /// < Number of bytes being transferred in this chunk
 pub size : u32 , /// < Offset of this chunk in the file
 pub offset : u32 , /// < Chunk data
 pub data : [ :: std :: os :: raw :: c_char ; 1usize ] , } # [ test ] fn bindgen_test_layout_MMAL_PARAMETER_CONFIGFILE_CHUNK_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PARAMETER_CONFIGFILE_CHUNK_T > ( ) , 20usize , concat ! ( "Size of: " , stringify ! ( MMAL_PARAMETER_CONFIGFILE_CHUNK_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PARAMETER_CONFIGFILE_CHUNK_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PARAMETER_CONFIGFILE_CHUNK_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CONFIGFILE_CHUNK_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CONFIGFILE_CHUNK_T ) , "::" , stringify ! ( hdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CONFIGFILE_CHUNK_T > ( ) ) ) . size as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CONFIGFILE_CHUNK_T ) , "::" , stringify ! ( size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CONFIGFILE_CHUNK_T > ( ) ) ) . offset as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CONFIGFILE_CHUNK_T ) , "::" , stringify ! ( offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PARAMETER_CONFIGFILE_CHUNK_T > ( ) ) ) . data as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PARAMETER_CONFIGFILE_CHUNK_T ) , "::" , stringify ! ( data ) ) ) ; } pub const MMAL_PORT_TYPE_T_MMAL_PORT_TYPE_UNKNOWN : MMAL_PORT_TYPE_T = 0 ; pub const MMAL_PORT_TYPE_T_MMAL_PORT_TYPE_CONTROL : MMAL_PORT_TYPE_T = 1 ; pub const MMAL_PORT_TYPE_T_MMAL_PORT_TYPE_INPUT : MMAL_PORT_TYPE_T = 2 ; pub const MMAL_PORT_TYPE_T_MMAL_PORT_TYPE_OUTPUT : MMAL_PORT_TYPE_T = 3 ; pub const MMAL_PORT_TYPE_T_MMAL_PORT_TYPE_CLOCK : MMAL_PORT_TYPE_T = 4 ; pub const MMAL_PORT_TYPE_T_MMAL_PORT_TYPE_INVALID : MMAL_PORT_TYPE_T = 4294967295 ; pub type MMAL_PORT_TYPE_T = u32 ; /// Definition of a port.
/// A port is the entity that is exposed by components to receive or transmit
/// buffer headers (\ref MMAL_BUFFER_HEADER_T). A port is defined by its
/// \ref MMAL_ES_FORMAT_T.
///
/// It may be possible to override the buffer requirements of a port by using
/// the MMAL_PARAMETER_BUFFER_REQUIREMENTS parameter.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PORT_T { /// < Private member used by the framework
 pub priv_ : * mut MMAL_PORT_PRIVATE_T , /// < Port name. Used for debugging purposes (Read Only)
 pub name : * const :: std :: os :: raw :: c_char , /// < Type of the port (Read Only)
 pub type_ : MMAL_PORT_TYPE_T , /// < Index of the port in its type list (Read Only)
 pub index : u16 , /// < Index of the port in the list of all ports (Read Only)
 pub index_all : u16 , /// < Indicates whether the port is enabled or not (Read Only)
 pub is_enabled : u32 , /// < Format of the elementary stream
 pub format : * mut MMAL_ES_FORMAT_T , /// < Minimum number of buffers the port requires (Read Only).
    /// This is set by the component.
 pub buffer_num_min : u32 , /// < Minimum size of buffers the port requires (Read Only).
    /// This is set by the component.
 pub buffer_size_min : u32 , /// < Minimum alignment requirement for the buffers (Read Only).
    /// A value of zero means no special alignment requirements.
    /// This is set by the component.
 pub buffer_alignment_min : u32 , /// < Number of buffers the port recommends for optimal performance (Read Only).
    /// A value of zero means no special recommendation.
    /// This is set by the component.
 pub buffer_num_recommended : u32 , /// < Size of buffers the port recommends for optimal performance (Read Only).
    /// A value of zero means no special recommendation.
    /// This is set by the component.
 pub buffer_size_recommended : u32 , /// < Actual number of buffers the port will use.
    /// This is set by the client.
 pub buffer_num : u32 , /// < Actual maximum size of the buffers that will be sent
    /// to the port. This is set by the client.
 pub buffer_size : u32 , /// < Component this port belongs to (Read Only)
 pub component : * mut MMAL_COMPONENT_T , /// < Field reserved for use by the client
 pub userdata : * mut MMAL_PORT_USERDATA_T , /// < Flags describing the capabilities of a port (Read Only).
    /// Bitwise combination of \ref portcapabilities "Port capabilities"
    /// values.
 pub capabilities : u32 , } # [ test ] fn bindgen_test_layout_MMAL_PORT_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_PORT_T > ( ) , 96usize , concat ! ( "Size of: " , stringify ! ( MMAL_PORT_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_PORT_T > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( MMAL_PORT_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PORT_T > ( ) ) ) . priv_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PORT_T ) , "::" , stringify ! ( priv_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PORT_T > ( ) ) ) . name as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PORT_T ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PORT_T > ( ) ) ) . type_ as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PORT_T ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PORT_T > ( ) ) ) . index as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PORT_T ) , "::" , stringify ! ( index ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PORT_T > ( ) ) ) . index_all as * const _ as usize } , 22usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PORT_T ) , "::" , stringify ! ( index_all ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PORT_T > ( ) ) ) . is_enabled as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PORT_T ) , "::" , stringify ! ( is_enabled ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PORT_T > ( ) ) ) . format as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PORT_T ) , "::" , stringify ! ( format ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PORT_T > ( ) ) ) . buffer_num_min as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PORT_T ) , "::" , stringify ! ( buffer_num_min ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PORT_T > ( ) ) ) . buffer_size_min as * const _ as usize } , 44usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PORT_T ) , "::" , stringify ! ( buffer_size_min ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PORT_T > ( ) ) ) . buffer_alignment_min as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PORT_T ) , "::" , stringify ! ( buffer_alignment_min ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PORT_T > ( ) ) ) . buffer_num_recommended as * const _ as usize } , 52usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PORT_T ) , "::" , stringify ! ( buffer_num_recommended ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PORT_T > ( ) ) ) . buffer_size_recommended as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PORT_T ) , "::" , stringify ! ( buffer_size_recommended ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PORT_T > ( ) ) ) . buffer_num as * const _ as usize } , 60usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PORT_T ) , "::" , stringify ! ( buffer_num ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PORT_T > ( ) ) ) . buffer_size as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PORT_T ) , "::" , stringify ! ( buffer_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PORT_T > ( ) ) ) . component as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PORT_T ) , "::" , stringify ! ( component ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PORT_T > ( ) ) ) . userdata as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PORT_T ) , "::" , stringify ! ( userdata ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_PORT_T > ( ) ) ) . capabilities as * const _ as usize } , 88usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_PORT_T ) , "::" , stringify ! ( capabilities ) ) ) ; } extern "C" { /// Commit format changes on a port.
///
/// @param port The port for which format changes are to be committed.
/// @return MMAL_SUCCESS on success
 pub fn mmal_port_format_commit ( port : * mut MMAL_PORT_T ) -> MMAL_STATUS_T::Type ; } /// Definition of the callback used by a port to send a \ref MMAL_BUFFER_HEADER_T
/// back to the user.
///
/// @param port The port sending the buffer header.
/// @param buffer The buffer header being sent.
 pub type MMAL_PORT_BH_CB_T = :: std :: option :: Option < unsafe extern "C" fn ( port : * mut MMAL_PORT_T , buffer : * mut MMAL_BUFFER_HEADER_T ) > ; extern "C" { /// Enable processing on a port
///
/// If this port is connected to another, the given callback must be NULL, while for a
/// disconnected port, the callback must be non-NULL.
///
/// If this is a connected output port and is successfully enabled:
/// <ul>
/// <li>The port shall be populated with a pool of buffers, allocated as required, according
/// to the buffer_num and buffer_size values.
/// <li>The input port to which it is connected shall be set to the same buffer
/// configuration and then be enabled. Should that fail, the original port shall be
/// disabled.
/// </ul>
///
/// @param port port to enable
/// @param cb callback use by the port to send a \ref MMAL_BUFFER_HEADER_T back
/// @return MMAL_SUCCESS on success
 pub fn mmal_port_enable ( port : * mut MMAL_PORT_T , cb : MMAL_PORT_BH_CB_T ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Disable processing on a port
///
/// Disabling a port will stop all processing on this port and return all (non-processed)
/// buffer headers to the client.
///
/// If this is a connected output port, the input port to which it is connected shall
/// also be disabled. Any buffer pool shall be released.
///
/// @param port port to disable
/// @return MMAL_SUCCESS on success
 pub fn mmal_port_disable ( port : * mut MMAL_PORT_T ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Ask a port to release all the buffer headers it currently has.
///
/// Flushing a port will ask the port to send all the buffer headers it currently has
/// to the client. Flushing is an asynchronous request and the flush call will
/// return before all the buffer headers are returned to the client.
/// It is up to the client to keep a count on the buffer headers to know when the
/// flush operation has completed.
/// It is also important to note that flushing will also reset the state of the port
/// and any processing which was buffered by the port will be lost.
///
/// \attention Flushing a connected port behaviour TBD.
///
/// @param port The port to flush.
/// @return MMAL_SUCCESS on success
 pub fn mmal_port_flush ( port : * mut MMAL_PORT_T ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Set a parameter on a port.
///
/// @param port The port to which the request is sent.
/// @param param The pointer to the header of the parameter to set.
/// @return MMAL_SUCCESS on success
 pub fn mmal_port_parameter_set ( port : * mut MMAL_PORT_T , param : * const MMAL_PARAMETER_HEADER_T ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Get a parameter from a port.
/// The size field must be set on input to the maximum size of the parameter
/// (including the header) and will be set on output to the actual size of the
/// parameter retrieved.
///
/// \note If MMAL_ENOSPC is returned, the parameter is larger than the size
/// given. The given parameter will have been filled up to its size and then
/// the size field set to the full parameter's size. This can be used to
/// resize the parameter buffer so that a second call should succeed.
///
/// @param port The port to which the request is sent.
/// @param param The pointer to the header of the parameter to get.
/// @return MMAL_SUCCESS on success
 pub fn mmal_port_parameter_get ( port : * mut MMAL_PORT_T , param : * mut MMAL_PARAMETER_HEADER_T ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Send a buffer header to a port.
///
/// @param port The port to which the buffer header is to be sent.
/// @param buffer The buffer header to send.
/// @return MMAL_SUCCESS on success
 pub fn mmal_port_send_buffer ( port : * mut MMAL_PORT_T , buffer : * mut MMAL_BUFFER_HEADER_T ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Connect an output port to an input port.
///
/// When connected and enabled, buffers will automatically progress from the
/// output port to the input port when they become available, and released back
/// to the output port when no longer required by the input port.
///
/// Ports can be given either way around, but one must be an output port and
/// the other must be an input port. Neither can be connected or enabled
/// already. The format of the output port will be applied to the input port
/// on connection.
///
/// @param port One of the ports to connect.
/// @param other_port The other port to connect.
/// @return MMAL_SUCCESS on success.
 pub fn mmal_port_connect ( port : * mut MMAL_PORT_T , other_port : * mut MMAL_PORT_T ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Disconnect a connected port.
///
/// If the port is not connected, an error will be returned. Otherwise, if the
/// ports are enabled, they will be disabled and any buffer pool created will be
/// freed.
///
/// @param port The ports to disconnect.
/// @return MMAL_SUCCESS on success.
 pub fn mmal_port_disconnect ( port : * mut MMAL_PORT_T ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Allocate a payload buffer.
/// This allows a client to allocate memory for a payload buffer based on the preferences
/// of a port. This for instance will allow the port to allocate memory which can be shared
/// between the host processor and videocore.
///
/// See \ref mmal_pool_create_with_allocator().
///
/// @param port         Port responsible for allocating the memory.
/// @param payload_size Size of the payload buffer which will be allocated.
///
/// @return Pointer to the allocated memory.
 pub fn mmal_port_payload_alloc ( port : * mut MMAL_PORT_T , payload_size : u32 ) -> * mut u8 ; } extern "C" { /// Free a payload buffer.
/// This allows a client to free memory allocated by a previous call to \ref mmal_port_payload_alloc.
///
/// See \ref mmal_pool_create_with_allocator().
///
/// @param port         Port responsible for allocating the memory.
/// @param payload      Pointer to the memory to free.
 pub fn mmal_port_payload_free ( port : * mut MMAL_PORT_T , payload : * mut u8 ) ; } extern "C" { /// Get an empty event buffer header from a port
///
/// @param port The port from which to get the event buffer header.
/// @param buffer The address of a buffer header pointer, which will be set on return.
/// @param event The specific event FourCC required. See the \ref MmalEvents "pre-defined events".
/// @return MMAL_SUCCESS on success
 pub fn mmal_port_event_get ( port : * mut MMAL_PORT_T , buffer : * mut * mut MMAL_BUFFER_HEADER_T , event : u32 ) -> MMAL_STATUS_T::Type ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_COMPONENT_PRIVATE_T { _unused : [ u8 ; 0 ] } /// Definition of a component.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_COMPONENT_T { /// Pointer to the private data of the module in use
 pub priv_ : * mut MMAL_COMPONENT_PRIVATE_T , /// Pointer to private data of the client
 pub userdata : * mut MMAL_COMPONENT_USERDATA_T , /// Component name
 pub name : * const :: std :: os :: raw :: c_char , /// Specifies whether the component is enabled or not
 pub is_enabled : u32 , /// All components expose a control port.
    /// The control port is used by clients to set / get parameters that are global to the
    /// component. It is also used to receive events, which again are global to the component.
    /// To be able to receive events, the client needs to enable and register a callback on the
    /// control port.
 pub control : * mut MMAL_PORT_T , /// < Number of input ports
 pub input_num : u32 , /// < Array of input ports
 pub input : * mut * mut MMAL_PORT_T , /// < Number of output ports
 pub output_num : u32 , /// < Array of output ports
 pub output : * mut * mut MMAL_PORT_T , /// < Number of clock ports
 pub clock_num : u32 , /// < Array of clock ports
 pub clock : * mut * mut MMAL_PORT_T , /// < Total number of ports
 pub port_num : u32 , /// < Array of all the ports (control/input/output/clock)
 pub port : * mut * mut MMAL_PORT_T , /// Uniquely identifies the component's instance within the MMAL
    /// context / process. For debugging.
 pub id : u32 , } # [ test ] fn bindgen_test_layout_MMAL_COMPONENT_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_COMPONENT_T > ( ) , 112usize , concat ! ( "Size of: " , stringify ! ( MMAL_COMPONENT_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_COMPONENT_T > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( MMAL_COMPONENT_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_COMPONENT_T > ( ) ) ) . priv_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_COMPONENT_T ) , "::" , stringify ! ( priv_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_COMPONENT_T > ( ) ) ) . userdata as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_COMPONENT_T ) , "::" , stringify ! ( userdata ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_COMPONENT_T > ( ) ) ) . name as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_COMPONENT_T ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_COMPONENT_T > ( ) ) ) . is_enabled as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_COMPONENT_T ) , "::" , stringify ! ( is_enabled ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_COMPONENT_T > ( ) ) ) . control as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_COMPONENT_T ) , "::" , stringify ! ( control ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_COMPONENT_T > ( ) ) ) . input_num as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_COMPONENT_T ) , "::" , stringify ! ( input_num ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_COMPONENT_T > ( ) ) ) . input as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_COMPONENT_T ) , "::" , stringify ! ( input ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_COMPONENT_T > ( ) ) ) . output_num as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_COMPONENT_T ) , "::" , stringify ! ( output_num ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_COMPONENT_T > ( ) ) ) . output as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_COMPONENT_T ) , "::" , stringify ! ( output ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_COMPONENT_T > ( ) ) ) . clock_num as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_COMPONENT_T ) , "::" , stringify ! ( clock_num ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_COMPONENT_T > ( ) ) ) . clock as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_COMPONENT_T ) , "::" , stringify ! ( clock ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_COMPONENT_T > ( ) ) ) . port_num as * const _ as usize } , 88usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_COMPONENT_T ) , "::" , stringify ! ( port_num ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_COMPONENT_T > ( ) ) ) . port as * const _ as usize } , 96usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_COMPONENT_T ) , "::" , stringify ! ( port ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_COMPONENT_T > ( ) ) ) . id as * const _ as usize } , 104usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_COMPONENT_T ) , "::" , stringify ! ( id ) ) ) ; } extern "C" { /// Create an instance of a component.
/// The newly created component will expose ports to the client. All the exposed ports are
/// disabled by default.
/// Note that components are reference counted and creating a component automatically
/// acquires a reference to it (released when \ref mmal_component_destroy is called).
///
/// @param name name of the component to create, e.g. "video_decode"
/// @param component returned component
/// @return MMAL_SUCCESS on success
 pub fn mmal_component_create ( name : * const :: std :: os :: raw :: c_char , component : * mut * mut MMAL_COMPONENT_T ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Acquire a reference on a component.
/// Acquiring a reference on a component will prevent a component from being destroyed until
/// the acquired reference is released (by a call to \ref mmal_component_destroy).
/// References are internally counted so all acquired references need a matching call to
/// release them.
///
/// @param component component to acquire
 pub fn mmal_component_acquire ( component : * mut MMAL_COMPONENT_T ) ; } extern "C" { /// Release a reference on a component
/// Release an acquired reference on a component. Triggers the destruction of the component when
/// the last reference is being released.
/// \note This is in fact an alias of \ref mmal_component_destroy which is added to make client
/// code clearer.
///
/// @param component component to release
/// @return MMAL_SUCCESS on success
 pub fn mmal_component_release ( component : * mut MMAL_COMPONENT_T ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Destroy a previously created component
/// Release an acquired reference on a component. Only actually destroys the component when
/// the last reference is being released.
///
/// @param component component to destroy
/// @return MMAL_SUCCESS on success
 pub fn mmal_component_destroy ( component : * mut MMAL_COMPONENT_T ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Enable processing on a component
/// @param component component to enable
/// @return MMAL_SUCCESS on success
 pub fn mmal_component_enable ( component : * mut MMAL_COMPONENT_T ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Disable processing on a component
/// @param component component to disable
/// @return MMAL_SUCCESS on success
 pub fn mmal_component_disable ( component : * mut MMAL_COMPONENT_T ) -> MMAL_STATUS_T::Type ; } /// Generic metadata type. All metadata structures need to begin with these fields.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_METATDATA_T { /// < Metadata id. This is a FourCC
 pub id : u32 , /// < Size in bytes of the following metadata (not including id and size)
 pub size : u32 , } # [ test ] fn bindgen_test_layout_MMAL_METATDATA_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_METATDATA_T > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( MMAL_METATDATA_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_METATDATA_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_METATDATA_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_METATDATA_T > ( ) ) ) . id as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_METATDATA_T ) , "::" , stringify ! ( id ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_METATDATA_T > ( ) ) ) . size as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_METATDATA_T ) , "::" , stringify ! ( size ) ) ) ; } pub type MMAL_METADATA_T = MMAL_METATDATA_T ; /// Hello World metadata.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_METATDATA_HELLO_WORLD_T { /// < Metadata id. This is a FourCC
 pub id : u32 , /// < Size in bytes of the following metadata (not including id and size)
 pub size : u32 , /// < Metadata value
 pub myvalue : u32 , } # [ test ] fn bindgen_test_layout_MMAL_METATDATA_HELLO_WORLD_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_METATDATA_HELLO_WORLD_T > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( MMAL_METATDATA_HELLO_WORLD_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_METATDATA_HELLO_WORLD_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_METATDATA_HELLO_WORLD_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_METATDATA_HELLO_WORLD_T > ( ) ) ) . id as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_METATDATA_HELLO_WORLD_T ) , "::" , stringify ! ( id ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_METATDATA_HELLO_WORLD_T > ( ) ) ) . size as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_METATDATA_HELLO_WORLD_T ) , "::" , stringify ! ( size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_METATDATA_HELLO_WORLD_T > ( ) ) ) . myvalue as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_METATDATA_HELLO_WORLD_T ) , "::" , stringify ! ( myvalue ) ) ) ; } pub type MMAL_METADATA_HELLO_WORLD_T = MMAL_METATDATA_HELLO_WORLD_T ; extern "C" { /// Get metadata item from buffer header.
/// This will search through all the metadata in the buffer header and return a pointer to the
/// first instance of the requested metadata id.
///
/// @param header buffer header containing the metadata
/// @param id     requested metadata id
///
/// @return Pointer to metadata requested or NULL if not found.
 pub fn mmal_metadata_get ( header : * mut MMAL_BUFFER_HEADER_T , id : u32 ) -> * mut MMAL_METADATA_T ; } extern "C" { /// Set metadata item in buffer header.
/// This will store the metadata item into the buffer header. This operation can fail if not
/// enough memory is available in the data section of the buffer header.
///
/// @param header   buffer header to store the metadata into
/// @param metadata metadata item to store in buffer header
///
/// @return MMAL_SUCCESS on success or MMAL_ENOMEM if not enough memory is available for storing
/// the metadata
 pub fn mmal_metadata_set ( header : * mut MMAL_BUFFER_HEADER_T , metadata : * mut MMAL_METADATA_T ) -> MMAL_STATUS_T::Type ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_QUEUE_T { _unused : [ u8 ; 0 ] } extern "C" { /// Create a queue of MMAL_BUFFER_HEADER_T
///
/// @return Pointer to the newly created queue or NULL on failure.
 pub fn mmal_queue_create ( ) -> * mut MMAL_QUEUE_T ; } extern "C" { /// Put a MMAL_BUFFER_HEADER_T into a queue
///
/// @param queue  Pointer to a queue
/// @param buffer Pointer to the MMAL_BUFFER_HEADER_T to add to the queue
 pub fn mmal_queue_put ( queue : * mut MMAL_QUEUE_T , buffer : * mut MMAL_BUFFER_HEADER_T ) ; } extern "C" { /// Put a MMAL_BUFFER_HEADER_T back at the start of a queue.
/// This is used when a buffer header was removed from the queue but not
/// fully processed and needs to be put back where it was originally taken.
///
/// @param queue  Pointer to a queue
/// @param buffer Pointer to the MMAL_BUFFER_HEADER_T to add to the queue
 pub fn mmal_queue_put_back ( queue : * mut MMAL_QUEUE_T , buffer : * mut MMAL_BUFFER_HEADER_T ) ; } extern "C" { /// Get a MMAL_BUFFER_HEADER_T from a queue
///
/// @param queue  Pointer to a queue
///
/// @return pointer to the next MMAL_BUFFER_HEADER_T or NULL if the queue is empty.
 pub fn mmal_queue_get ( queue : * mut MMAL_QUEUE_T ) -> * mut MMAL_BUFFER_HEADER_T ; } extern "C" { /// Wait for a MMAL_BUFFER_HEADER_T from a queue.
/// This is the same as a get except that this will block until a buffer header is
/// available.
///
/// @param queue  Pointer to a queue
///
/// @return pointer to the next MMAL_BUFFER_HEADER_T.
 pub fn mmal_queue_wait ( queue : * mut MMAL_QUEUE_T ) -> * mut MMAL_BUFFER_HEADER_T ; } extern "C" { /// Wait for a MMAL_BUFFER_HEADER_T from a queue, up to a given timeout.
/// This is the same as a wait, except that it will abort in case of timeout.
///
/// @param queue  Pointer to a queue
/// @param timeout Number of milliseconds to wait before
/// returning if the semaphore can't be acquired.
///
/// @return pointer to the next MMAL_BUFFER_HEADER_T.
 pub fn mmal_queue_timedwait ( queue : * mut MMAL_QUEUE_T , timeout : VCOS_UNSIGNED ) -> * mut MMAL_BUFFER_HEADER_T ; } extern "C" { /// Get the number of MMAL_BUFFER_HEADER_T currently in a queue.
///
/// @param queue  Pointer to a queue
///
/// @return length (in elements) of the queue.
 pub fn mmal_queue_length ( queue : * mut MMAL_QUEUE_T ) -> :: std :: os :: raw :: c_uint ; } extern "C" { /// Destroy a queue of MMAL_BUFFER_HEADER_T.
///
/// @param queue  Pointer to a queue
 pub fn mmal_queue_destroy ( queue : * mut MMAL_QUEUE_T ) ; } /// Definition of a pool
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_POOL_T { /// < Queue used by the pool
 pub queue : * mut MMAL_QUEUE_T , /// < Number of buffer headers in the pool
 pub headers_num : u32 , /// < Array of buffer headers belonging to the pool
 pub header : * mut * mut MMAL_BUFFER_HEADER_T , } # [ test ] fn bindgen_test_layout_MMAL_POOL_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_POOL_T > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( MMAL_POOL_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_POOL_T > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( MMAL_POOL_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_POOL_T > ( ) ) ) . queue as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_POOL_T ) , "::" , stringify ! ( queue ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_POOL_T > ( ) ) ) . headers_num as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_POOL_T ) , "::" , stringify ! ( headers_num ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_POOL_T > ( ) ) ) . header as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_POOL_T ) , "::" , stringify ! ( header ) ) ) ; } /// Allocator alloc prototype
///
/// @param context The context pointer passed in on pool creation.
/// @param size    The size of the allocation required, in bytes.
/// @return The pointer to the newly allocated memory, or NULL on failure.
 pub type mmal_pool_allocator_alloc_t = :: std :: option :: Option < unsafe extern "C" fn ( context : * mut :: std :: os :: raw :: c_void , size : u32 ) -> * mut :: std :: os :: raw :: c_void > ; /// Allocator free prototype
///
/// @param context The context pointer passed in on pool creation.
/// @param mem     The pointer to the memory to be released.
 pub type mmal_pool_allocator_free_t = :: std :: option :: Option < unsafe extern "C" fn ( context : * mut :: std :: os :: raw :: c_void , mem : * mut :: std :: os :: raw :: c_void ) > ; extern "C" { /// Create a pool of MMAL_BUFFER_HEADER_T.
/// After allocation, all allocated buffer headers will have been added to the queue.
///
/// It is valid to create a pool with no buffer headers, or with zero size payload buffers.
/// The mmal_pool_resize() function can be used to increase or decrease the number of buffer
/// headers, or the size of the payload buffers, after creation of the pool.
///
/// The payload buffers may also be allocated independently by the client, and assigned
/// to the buffer headers, but it will be the responsibility of the client to deal with
/// resizing and releasing the memory. It is recommended that mmal_pool_create_with_allocator()
/// is used in this case, supplying allocator function pointers that will be used as
/// necessary by MMAL.
///
/// @param headers      Number of buffer headers to be allocated with the pool.
/// @param payload_size Size of the payload buffer that will be allocated in
/// each of the buffer headers.
/// @return Pointer to the newly created pool or NULL on failure.
 pub fn mmal_pool_create ( headers : :: std :: os :: raw :: c_uint , payload_size : u32 ) -> * mut MMAL_POOL_T ; } extern "C" { /// Create a pool of MMAL_BUFFER_HEADER_T.
/// After allocation, all allocated buffer headers will have been added to the queue.
///
/// It is valid to create a pool with no buffer headers, or with zero size payload buffers.
/// The mmal_pool_resize() function can be used to increase or decrease the number of buffer
/// headers, or the size of the payload buffers, after creation of the pool. The allocators
/// passed during creation shall be used when resizing the payload buffers.
///
/// @param headers      Number of buffer headers to be allocated with the pool.
/// @param payload_size Size of the payload buffer that will be allocated in
/// each of the buffer headers.
/// @param allocator_context Pointer to the context of the allocator.
/// @param allocator_alloc   Function pointer for the alloc call of the allocator.
/// @param allocator_free    Function pointer for the free call of the allocator.
///
/// @return Pointer to the newly created pool or NULL on failure.
 pub fn mmal_pool_create_with_allocator ( headers : :: std :: os :: raw :: c_uint , payload_size : u32 , allocator_context : * mut :: std :: os :: raw :: c_void , allocator_alloc : mmal_pool_allocator_alloc_t , allocator_free : mmal_pool_allocator_free_t ) -> * mut MMAL_POOL_T ; } extern "C" { /// Destroy a pool of MMAL_BUFFER_HEADER_T.
/// This will also deallocate all of the memory which was allocated when creating or
/// resizing the pool.
///
/// If payload buffers have been allocated independently by the client, they should be
/// released prior to calling this function. If the client provided allocator functions,
/// the allocator_free function shall be called for each payload buffer.
///
/// @param pool  Pointer to a pool
 pub fn mmal_pool_destroy ( pool : * mut MMAL_POOL_T ) ; } extern "C" { /// Resize a pool of MMAL_BUFFER_HEADER_T.
/// This allows modifying either the number of allocated buffers, the payload size or both at the
/// same time.
///
/// @param pool         Pointer to the pool
/// @param headers      New number of buffer headers to be allocated in the pool.
/// It is not valid to pass zero for the number of buffers.
/// @param payload_size Size of the payload buffer that will be allocated in
/// each of the buffer headers.
/// If this is set to 0, all payload buffers shall be released.
/// @return MMAL_SUCCESS or an error on failure.
 pub fn mmal_pool_resize ( pool : * mut MMAL_POOL_T , headers : :: std :: os :: raw :: c_uint , payload_size : u32 ) -> MMAL_STATUS_T::Type ; } /// Definition of the callback used by a pool to signal back to the user that a buffer header
/// has been released back to the pool.
///
/// @param pool       Pointer to the pool
/// @param buffer     Buffer header just released
/// @param userdata   User specific data passed in when setting the callback
/// @return True to have the buffer header put back in the pool's queue, false if the buffer
/// header has been taken within the callback.
 pub type MMAL_POOL_BH_CB_T = :: std :: option :: Option < unsafe extern "C" fn ( pool : * mut MMAL_POOL_T , buffer : * mut MMAL_BUFFER_HEADER_T , userdata : * mut :: std :: os :: raw :: c_void ) -> MMAL_BOOL_T > ; extern "C" { /// Set a buffer header release callback to the pool.
/// Each time a buffer header is released to the pool, the callback will be triggered.
///
/// @param pool     Pointer to a pool
/// @param cb       Callback function
/// @param userdata User specific data which will be passed with each callback
 pub fn mmal_pool_callback_set ( pool : * mut MMAL_POOL_T , cb : MMAL_POOL_BH_CB_T , userdata : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { /// Set a pre-release callback for all buffer headers in the pool.
/// Each time a buffer header is about to be released to the pool, the callback
/// will be triggered.
///
/// @param pool     Pointer to the pool
/// @param cb       Pre-release callback function
/// @param userdata User-specific data passed back with each callback
 pub fn mmal_pool_pre_release_callback_set ( pool : * mut MMAL_POOL_T , cb : MMAL_BH_PRE_RELEASE_CB_T , userdata : * mut :: std :: os :: raw :: c_void ) ; } /// End-of-stream event.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_EVENT_END_OF_STREAM_T { /// < Type of port that received the end of stream
 pub port_type : MMAL_PORT_TYPE_T , /// < Index of port that received the end of stream
 pub port_index : u32 , } # [ test ] fn bindgen_test_layout_MMAL_EVENT_END_OF_STREAM_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_EVENT_END_OF_STREAM_T > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( MMAL_EVENT_END_OF_STREAM_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_EVENT_END_OF_STREAM_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_EVENT_END_OF_STREAM_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_EVENT_END_OF_STREAM_T > ( ) ) ) . port_type as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_EVENT_END_OF_STREAM_T ) , "::" , stringify ! ( port_type ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_EVENT_END_OF_STREAM_T > ( ) ) ) . port_index as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_EVENT_END_OF_STREAM_T ) , "::" , stringify ! ( port_index ) ) ) ; } /// Format changed event data.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_EVENT_FORMAT_CHANGED_T { /// < Minimum size of buffers the port requires
 pub buffer_size_min : u32 , /// < Minimum number of buffers the port requires
 pub buffer_num_min : u32 , /// < Size of buffers the port recommends for optimal performance.
    /// A value of zero means no special recommendation.
 pub buffer_size_recommended : u32 , /// < Number of buffers the port recommends for optimal
    /// performance. A value of zero means no special recommendation.
 pub buffer_num_recommended : u32 , /// < New elementary stream format
 pub format : * mut MMAL_ES_FORMAT_T , } # [ test ] fn bindgen_test_layout_MMAL_EVENT_FORMAT_CHANGED_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_EVENT_FORMAT_CHANGED_T > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( MMAL_EVENT_FORMAT_CHANGED_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_EVENT_FORMAT_CHANGED_T > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( MMAL_EVENT_FORMAT_CHANGED_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_EVENT_FORMAT_CHANGED_T > ( ) ) ) . buffer_size_min as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_EVENT_FORMAT_CHANGED_T ) , "::" , stringify ! ( buffer_size_min ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_EVENT_FORMAT_CHANGED_T > ( ) ) ) . buffer_num_min as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_EVENT_FORMAT_CHANGED_T ) , "::" , stringify ! ( buffer_num_min ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_EVENT_FORMAT_CHANGED_T > ( ) ) ) . buffer_size_recommended as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_EVENT_FORMAT_CHANGED_T ) , "::" , stringify ! ( buffer_size_recommended ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_EVENT_FORMAT_CHANGED_T > ( ) ) ) . buffer_num_recommended as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_EVENT_FORMAT_CHANGED_T ) , "::" , stringify ! ( buffer_num_recommended ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_EVENT_FORMAT_CHANGED_T > ( ) ) ) . format as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_EVENT_FORMAT_CHANGED_T ) , "::" , stringify ! ( format ) ) ) ; } /// Parameter changed event data.
/// This is a variable sized event. The full parameter is included in the event
/// data, not just the header. Use the \ref MMAL_PARAMETER_HEADER_T::id field to determine how to
/// cast the structure. The \ref MMAL_PARAMETER_HEADER_T::size field can be used to check validity.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_EVENT_PARAMETER_CHANGED_T { pub hdr : MMAL_PARAMETER_HEADER_T , } # [ test ] fn bindgen_test_layout_MMAL_EVENT_PARAMETER_CHANGED_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_EVENT_PARAMETER_CHANGED_T > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( MMAL_EVENT_PARAMETER_CHANGED_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_EVENT_PARAMETER_CHANGED_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_EVENT_PARAMETER_CHANGED_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_EVENT_PARAMETER_CHANGED_T > ( ) ) ) . hdr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_EVENT_PARAMETER_CHANGED_T ) , "::" , stringify ! ( hdr ) ) ) ; } extern "C" { /// Get a pointer to the \ref MMAL_EVENT_FORMAT_CHANGED_T structure contained in the buffer header.
/// Note that the pointer will point inside the data contained in the buffer header
/// so doesn't need to be freed explicitly.
///
/// @param buffer buffer header containing the MMAL_EVENT_FORMAT_CHANGED event.
/// @return pointer to a MMAL_EVENT_FORMAT_CHANGED_T structure.
 pub fn mmal_event_format_changed_get ( buffer : * mut MMAL_BUFFER_HEADER_T ) -> * mut MMAL_EVENT_FORMAT_CHANGED_T ; } /// Definition of the callback used by a connection to signal back to the client
/// that a buffer header is available either in the pool or in the output queue.
///
/// @param connection Pointer to the connection
 pub type MMAL_CONNECTION_CALLBACK_T = :: std :: option :: Option < unsafe extern "C" fn ( connection : * mut MMAL_CONNECTION_T ) > ; /// Structure describing a connection between 2 ports (1 output and 1 input port)
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_CONNECTION_T { /// < Field reserved for use by the client.
 pub user_data : * mut :: std :: os :: raw :: c_void , /// < Callback set by the client.
 pub callback : MMAL_CONNECTION_CALLBACK_T , /// < Specifies whether the connection is enabled or not (Read Only).
 pub is_enabled : u32 , /// < Flags passed during the create call (Read Only). A bitwise
    /// combination of \ref connectionflags "Connection flags" values.
 pub flags : u32 , /// < Input port used for the connection (Read Only).
 pub in_ : * mut MMAL_PORT_T , /// < Output port used for the connection (Read Only).
 pub out : * mut MMAL_PORT_T , /// < Pool of buffer headers used by the output port (Read Only).
 pub pool : * mut MMAL_POOL_T , /// < Queue for the buffer headers produced by the output port (Read Only).
 pub queue : * mut MMAL_QUEUE_T , /// < Connection name (Read Only). Used for debugging purposes.
 pub name : * const :: std :: os :: raw :: c_char , /// < Time in microseconds taken to setup the connection.
 pub time_setup : i64 , /// < Time in microseconds taken to enable the connection.
 pub time_enable : i64 , /// < Time in microseconds taken to disable the connection.
 pub time_disable : i64 , } # [ test ] fn bindgen_test_layout_MMAL_CONNECTION_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_CONNECTION_T > ( ) , 88usize , concat ! ( "Size of: " , stringify ! ( MMAL_CONNECTION_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_CONNECTION_T > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( MMAL_CONNECTION_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CONNECTION_T > ( ) ) ) . user_data as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CONNECTION_T ) , "::" , stringify ! ( user_data ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CONNECTION_T > ( ) ) ) . callback as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CONNECTION_T ) , "::" , stringify ! ( callback ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CONNECTION_T > ( ) ) ) . is_enabled as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CONNECTION_T ) , "::" , stringify ! ( is_enabled ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CONNECTION_T > ( ) ) ) . flags as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CONNECTION_T ) , "::" , stringify ! ( flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CONNECTION_T > ( ) ) ) . in_ as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CONNECTION_T ) , "::" , stringify ! ( in_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CONNECTION_T > ( ) ) ) . out as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CONNECTION_T ) , "::" , stringify ! ( out ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CONNECTION_T > ( ) ) ) . pool as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CONNECTION_T ) , "::" , stringify ! ( pool ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CONNECTION_T > ( ) ) ) . queue as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CONNECTION_T ) , "::" , stringify ! ( queue ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CONNECTION_T > ( ) ) ) . name as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CONNECTION_T ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CONNECTION_T > ( ) ) ) . time_setup as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CONNECTION_T ) , "::" , stringify ! ( time_setup ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CONNECTION_T > ( ) ) ) . time_enable as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CONNECTION_T ) , "::" , stringify ! ( time_enable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_CONNECTION_T > ( ) ) ) . time_disable as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_CONNECTION_T ) , "::" , stringify ! ( time_disable ) ) ) ; } extern "C" { /// Create a connection between two ports.
/// The connection shall include a pool of buffer headers suitable for the current format of
/// the output port. The format of the input port shall have been set to the same as that of
/// the input port.
/// Note that connections are reference counted and creating a connection automatically
/// acquires a reference to it (released when \ref mmal_connection_destroy is called).
///
/// @param connection The address of a connection pointer that will be set to point to the created
/// connection.
/// @param out        The output port to use for the connection.
/// @param in         The input port to use for the connection.
/// @param flags      The flags specifying which type of connection should be created.
/// A bitwise combination of \ref connectionflags "Connection flags" values.
/// @return MMAL_SUCCESS on success.
 pub fn mmal_connection_create ( connection : * mut * mut MMAL_CONNECTION_T , out : * mut MMAL_PORT_T , in_ : * mut MMAL_PORT_T , flags : u32 ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Acquire a reference on a connection.
/// Acquiring a reference on a connection will prevent a connection from being destroyed until
/// the acquired reference is released (by a call to \ref mmal_connection_destroy).
/// References are internally counted so all acquired references need a matching call to
/// release them.
///
/// @param connection connection to acquire
 pub fn mmal_connection_acquire ( connection : * mut MMAL_CONNECTION_T ) ; } extern "C" { /// Release a reference on a connection
/// Release an acquired reference on a connection. Triggers the destruction of the connection when
/// the last reference is being released.
/// \note This is in fact an alias of \ref mmal_connection_destroy which is added to make client
/// code clearer.
///
/// @param connection connection to release
/// @return MMAL_SUCCESS on success
 pub fn mmal_connection_release ( connection : * mut MMAL_CONNECTION_T ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Destroy a connection.
/// Release an acquired reference on a connection. Only actually destroys the connection when
/// the last reference is being released.
/// The actual destruction of the connection will start by disabling it, if necessary.
/// Any pool, queue, and so on owned by the connection shall then be destroyed.
///
/// @param connection The connection to be destroyed.
/// @return MMAL_SUCCESS on success.
 pub fn mmal_connection_destroy ( connection : * mut MMAL_CONNECTION_T ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Enable a connection.
/// The format of the two ports must have been committed before calling this function,
/// although note that on creation, the connection automatically copies and commits the
/// output port's format to the input port.
///
/// The MMAL_CONNECTION_T::callback field must have been set if the \ref MMAL_CONNECTION_FLAG_TUNNELLING
/// flag was not specified on creation. The client may also set the MMAL_CONNECTION_T::user_data
/// in order to get a pointer passed, via the connection, to the callback.
///
/// @param connection The connection to be enabled.
/// @return MMAL_SUCCESS on success.
 pub fn mmal_connection_enable ( connection : * mut MMAL_CONNECTION_T ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Disable a connection.
///
/// @param connection The connection to be disabled.
/// @return MMAL_SUCCESS on success.
 pub fn mmal_connection_disable ( connection : * mut MMAL_CONNECTION_T ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Apply a format changed event to the connection.
/// This function can be used when the client is processing buffer headers and receives
/// a format changed event (\ref MMAL_EVENT_FORMAT_CHANGED). The connection is
/// reconfigured, changing the format of the ports, the number of buffer headers and
/// the size of the payload buffers as necessary.
///
/// @param connection The connection to which the event shall be applied.
/// @param buffer The buffer containing a format changed event.
/// @return MMAL_SUCCESS on success.
 pub fn mmal_connection_event_format_changed ( connection : * mut MMAL_CONNECTION_T , buffer : * mut MMAL_BUFFER_HEADER_T ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Convert a status to a statically-allocated string.
///
/// @param status The MMAL status code.
/// @return A C string describing the status code.
 pub fn mmal_status_to_string ( status : MMAL_STATUS_T::Type ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { /// Convert stride to pixel width for a given pixel encoding.
///
/// @param encoding The pixel encoding (such as one of the \ref MmalEncodings "pre-defined encodings")
/// @param stride The stride in bytes.
/// @return The width in pixels.
 pub fn mmal_encoding_stride_to_width ( encoding : u32 , stride : u32 ) -> u32 ; } extern "C" { /// Convert pixel width to stride for a given pixel encoding
///
/// @param encoding The pixel encoding (such as one of the \ref MmalEncodings "pre-defined encodings")
/// @param width The width in pixels.
/// @return The stride in bytes.
 pub fn mmal_encoding_width_to_stride ( encoding : u32 , width : u32 ) -> u32 ; } extern "C" { /// Return the 16 line high sliced version of a given pixel encoding
///
/// @param encoding The pixel encoding (such as one of the \ref MmalEncodings "pre-defined encodings")
/// @return The sliced equivalent, or MMAL_ENCODING_UNKNOWN if not supported.
 pub fn mmal_encoding_get_slice_variant ( encoding : u32 ) -> u32 ; } extern "C" { /// Convert a port type to a string.
///
/// @param type The MMAL port type.
/// @return A NULL-terminated string describing the port type.
 pub fn mmal_port_type_to_string ( type_ : MMAL_PORT_TYPE_T ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { /// Get a parameter from a port allocating the required amount of memory
/// for the parameter (i.e. for variable length parameters like URI or arrays).
/// The size field will be set on output to the actual size of the
/// parameter allocated and retrieved.
///
/// The pointer returned must be released by a call to \ref mmal_port_parameter_free().
///
/// @param port port to send request to
/// @param id parameter id
/// @param size initial size hint for allocation (can be 0)
/// @param status status of the parameter get operation (can be 0)
/// @return pointer to the header of the parameter or NULL on failure.
 pub fn mmal_port_parameter_alloc_get ( port : * mut MMAL_PORT_T , id : u32 , size : u32 , status : * mut MMAL_STATUS_T::Type ) -> * mut MMAL_PARAMETER_HEADER_T ; } extern "C" { /// Free a parameter structure previously allocated via
/// \ref mmal_port_parameter_alloc_get().
///
/// @param param pointer to header of the parameter
 pub fn mmal_port_parameter_free ( param : * mut MMAL_PARAMETER_HEADER_T ) ; } extern "C" { /// Copy buffer header metadata from source to destination.
///
/// @param dest The destination buffer header.
/// @param src  The source buffer header.
 pub fn mmal_buffer_header_copy_header ( dest : * mut MMAL_BUFFER_HEADER_T , src : * const MMAL_BUFFER_HEADER_T ) ; } extern "C" { /// Create a pool of MMAL_BUFFER_HEADER_T associated with a specific port.
/// This allows a client to allocate memory for the payload buffers based on the preferences
/// of a port. This for instance will allow the port to allocate memory which can be shared
/// between the host processor and videocore.
/// After allocation, all allocated buffer headers will have been added to the queue.
///
/// It is valid to create a pool with no buffer headers, or with zero size payload buffers.
/// The mmal_pool_resize() function can be used to increase or decrease the number of buffer
/// headers, or the size of the payload buffers, after creation of the pool.
///
/// @param port         Port responsible for creating the pool.
/// @param headers      Number of buffers which will be allocated with the pool.
/// @param payload_size Size of the payload buffer which will be allocated in
/// each of the buffer headers.
/// @return Pointer to the newly created pool or NULL on failure.
 pub fn mmal_port_pool_create ( port : * mut MMAL_PORT_T , headers : :: std :: os :: raw :: c_uint , payload_size : u32 ) -> * mut MMAL_POOL_T ; } extern "C" { /// Destroy a pool of MMAL_BUFFER_HEADER_T associated with a specific port.
/// This will also deallocate all of the memory which was allocated when creating or
/// resizing the pool.
///
/// @param port  Pointer to the port responsible for creating the pool.
/// @param pool  Pointer to the pool to be destroyed.
 pub fn mmal_port_pool_destroy ( port : * mut MMAL_PORT_T , pool : * mut MMAL_POOL_T ) ; } extern "C" { /// Log the content of a \ref MMAL_PORT_T structure.
///
/// @param port  Pointer to the port to dump.
 pub fn mmal_log_dump_port ( port : * mut MMAL_PORT_T ) ; } extern "C" { /// Log the content of a \ref MMAL_ES_FORMAT_T structure.
///
/// @param format  Pointer to the format to dump.
 pub fn mmal_log_dump_format ( format : * mut MMAL_ES_FORMAT_T ) ; } extern "C" { /// Return the nth port.
///
/// @param comp   component to query
/// @param index  port index
/// @param type   port type
///
/// @return port or NULL if not found
 pub fn mmal_util_get_port ( comp : * mut MMAL_COMPONENT_T , type_ : MMAL_PORT_TYPE_T , index : :: std :: os :: raw :: c_uint ) -> * mut MMAL_PORT_T ; } extern "C" { /// Convert a 4cc into a string.
///
/// @param buf    Destination for result
/// @param len    Size of result buffer
/// @param fourcc 4cc to be converted
/// @return converted string (buf)
///
 pub fn mmal_4cc_to_string ( buf : * mut :: std :: os :: raw :: c_char , len : usize , fourcc : u32 ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { /// On FW prior to June 2016, camera and video_splitter
/// had BGR24 and RGB24 support reversed.
/// This is now fixed, and this function will return whether the
/// FW has the fix or not.
///
/// @param port   MMAL port to check (on camera or video_splitter)
/// @return 0 if old firmware, 1 if new.
///
 pub fn mmal_util_rgb_order_fixed ( port : * mut MMAL_PORT_T ) -> :: std :: os :: raw :: c_int ; } extern "C" { /// Helper function to set the value of a boolean parameter.
/// @param port   port on which to set the parameter
/// @param id     parameter id
/// @param value  value to set the parameter to
///
/// @return MMAL_SUCCESS or error
 pub fn mmal_port_parameter_set_boolean ( port : * mut MMAL_PORT_T , id : u32 , value : MMAL_BOOL_T ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Helper function to get the value of a boolean parameter.
/// @param port   port on which to get the parameter
/// @param id     parameter id
/// @param value  pointer to where the value will be returned
///
/// @return MMAL_SUCCESS or error
 pub fn mmal_port_parameter_get_boolean ( port : * mut MMAL_PORT_T , id : u32 , value : * mut MMAL_BOOL_T ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Helper function to set the value of a 64 bits unsigned integer parameter.
/// @param port   port on which to set the parameter
/// @param id     parameter id
/// @param value  value to set the parameter to
///
/// @return MMAL_SUCCESS or error
 pub fn mmal_port_parameter_set_uint64 ( port : * mut MMAL_PORT_T , id : u32 , value : u64 ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Helper function to get the value of a 64 bits unsigned integer parameter.
/// @param port   port on which to get the parameter
/// @param id     parameter id
/// @param value  pointer to where the value will be returned
///
/// @return MMAL_SUCCESS or error
 pub fn mmal_port_parameter_get_uint64 ( port : * mut MMAL_PORT_T , id : u32 , value : * mut u64 ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Helper function to set the value of a 64 bits signed integer parameter.
/// @param port   port on which to set the parameter
/// @param id     parameter id
/// @param value  value to set the parameter to
///
/// @return MMAL_SUCCESS or error
 pub fn mmal_port_parameter_set_int64 ( port : * mut MMAL_PORT_T , id : u32 , value : i64 ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Helper function to get the value of a 64 bits signed integer parameter.
/// @param port   port on which to get the parameter
/// @param id     parameter id
/// @param value  pointer to where the value will be returned
///
/// @return MMAL_SUCCESS or error
 pub fn mmal_port_parameter_get_int64 ( port : * mut MMAL_PORT_T , id : u32 , value : * mut i64 ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Helper function to set the value of a 32 bits unsigned integer parameter.
/// @param port   port on which to set the parameter
/// @param id     parameter id
/// @param value  value to set the parameter to
///
/// @return MMAL_SUCCESS or error
 pub fn mmal_port_parameter_set_uint32 ( port : * mut MMAL_PORT_T , id : u32 , value : u32 ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Helper function to get the value of a 32 bits unsigned integer parameter.
/// @param port   port on which to get the parameter
/// @param id     parameter id
/// @param value  pointer to where the value will be returned
///
/// @return MMAL_SUCCESS or error
 pub fn mmal_port_parameter_get_uint32 ( port : * mut MMAL_PORT_T , id : u32 , value : * mut u32 ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Helper function to set the value of a 32 bits signed integer parameter.
/// @param port   port on which to set the parameter
/// @param id     parameter id
/// @param value  value to set the parameter to
///
/// @return MMAL_SUCCESS or error
 pub fn mmal_port_parameter_set_int32 ( port : * mut MMAL_PORT_T , id : u32 , value : i32 ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Helper function to get the value of a 32 bits signed integer parameter.
/// @param port   port on which to get the parameter
/// @param id     parameter id
/// @param value  pointer to where the value will be returned
///
/// @return MMAL_SUCCESS or error
 pub fn mmal_port_parameter_get_int32 ( port : * mut MMAL_PORT_T , id : u32 , value : * mut i32 ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Helper function to set the value of a rational parameter.
/// @param port   port on which to set the parameter
/// @param id     parameter id
/// @param value  value to set the parameter to
///
/// @return MMAL_SUCCESS or error
 pub fn mmal_port_parameter_set_rational ( port : * mut MMAL_PORT_T , id : u32 , value : MMAL_RATIONAL_T ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Helper function to get the value of a rational parameter.
/// @param port   port on which to get the parameter
/// @param id     parameter id
/// @param value  pointer to where the value will be returned
///
/// @return MMAL_SUCCESS or error
 pub fn mmal_port_parameter_get_rational ( port : * mut MMAL_PORT_T , id : u32 , value : * mut MMAL_RATIONAL_T ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Helper function to set the value of a string parameter.
/// @param port   port on which to set the parameter
/// @param id     parameter id
/// @param value  null-terminated string value
///
/// @return MMAL_SUCCESS or error
 pub fn mmal_port_parameter_set_string ( port : * mut MMAL_PORT_T , id : u32 , value : * const :: std :: os :: raw :: c_char ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Helper function to set the value of an array of bytes parameter.
/// @param port   port on which to set the parameter
/// @param id     parameter id
/// @param data   pointer to the array of bytes
/// @param size   size of the array of bytes
///
/// @return MMAL_SUCCESS or error
 pub fn mmal_port_parameter_set_bytes ( port : * mut MMAL_PORT_T , id : u32 , data : * const u8 , size : :: std :: os :: raw :: c_uint ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Helper function to set a MMAL_PARAMETER_URI_T parameter on a port.
/// @param port   port on which to set the parameter
/// @param uri    URI string
///
/// @return MMAL_SUCCESS or error
 pub fn mmal_util_port_set_uri ( port : * mut MMAL_PORT_T , uri : * const :: std :: os :: raw :: c_char ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Set the display region.
/// @param port   port to configure
/// @param region region
///
/// @return MMAL_SUCCESS or error
 pub fn mmal_util_set_display_region ( port : * mut MMAL_PORT_T , region : * mut MMAL_DISPLAYREGION_T ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Tell the camera to use the STC for timestamps rather than the clock.
///
/// @param port   port to configure
/// @param mode   STC mode to use
/// @return MMAL_SUCCESS or error
 pub fn mmal_util_camera_use_stc_timestamp ( port : * mut MMAL_PORT_T , mode : MMAL_CAMERA_STC_MODE_T ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Get the MMAL core statistics for a given port.
///
/// @param port  port to query
/// @param dir   port direction
/// @param reset reset the stats as well
/// @param stats filled in with results
/// @return MMAL_SUCCESS or error
 pub fn mmal_util_get_core_port_stats ( port : * mut MMAL_PORT_T , dir : MMAL_CORE_STATS_DIR , reset : MMAL_BOOL_T , stats : * mut MMAL_CORE_STATISTICS_T ) -> MMAL_STATUS_T::Type ; } extern "C" { pub fn bcm_host_init ( ) ; } extern "C" { pub fn bcm_host_deinit ( ) ; } extern "C" { pub fn bcm_host_get_peripheral_address ( ) -> :: std :: os :: raw :: c_uint ; } extern "C" { pub fn bcm_host_get_peripheral_size ( ) -> :: std :: os :: raw :: c_uint ; } extern "C" { pub fn bcm_host_get_sdram_address ( ) -> :: std :: os :: raw :: c_uint ; } pub const MMAL_STATS_COMP_STATE_T_MMAL_STATS_COMP_IDLE : MMAL_STATS_COMP_STATE_T = 0 ; pub const MMAL_STATS_COMP_STATE_T_MMAL_STATS_COMP_CREATED : MMAL_STATS_COMP_STATE_T = 1 ; pub const MMAL_STATS_COMP_STATE_T_MMAL_STATS_COMP_DESTROYING : MMAL_STATS_COMP_STATE_T = 2 ; pub const MMAL_STATS_COMP_STATE_T_MMAL_STATS_COMP_DESTROYED : MMAL_STATS_COMP_STATE_T = 3 ; pub const MMAL_STATS_COMP_STATE_T_MMAL_STATS_COMP_UNUSED : MMAL_STATS_COMP_STATE_T = 4294967295 ; pub type MMAL_STATS_COMP_STATE_T = u32 ; /// Per-component statistics collected by the VC adaptation layer.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_VC_COMP_STATS_T { pub comp : * mut MMAL_DRIVER_COMPONENT_T , pub state : MMAL_STATS_COMP_STATE_T , pub pid : u32 , pub pool_mem_alloc_size : u32 , pub name : [ :: std :: os :: raw :: c_char ; 20usize ] , } # [ test ] fn bindgen_test_layout_MMAL_VC_COMP_STATS_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_VC_COMP_STATS_T > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( MMAL_VC_COMP_STATS_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_VC_COMP_STATS_T > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( MMAL_VC_COMP_STATS_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_COMP_STATS_T > ( ) ) ) . comp as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_COMP_STATS_T ) , "::" , stringify ! ( comp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_COMP_STATS_T > ( ) ) ) . state as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_COMP_STATS_T ) , "::" , stringify ! ( state ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_COMP_STATS_T > ( ) ) ) . pid as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_COMP_STATS_T ) , "::" , stringify ! ( pid ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_COMP_STATS_T > ( ) ) ) . pool_mem_alloc_size as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_COMP_STATS_T ) , "::" , stringify ! ( pool_mem_alloc_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_COMP_STATS_T > ( ) ) ) . name as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_COMP_STATS_T ) , "::" , stringify ! ( name ) ) ) ; } /// VC adaptation layer statistics.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_VC_STATS_T { pub buffers : MMAL_VC_STATS_T__bindgen_ty_1 , pub service : MMAL_VC_STATS_T_service , pub commands : MMAL_VC_STATS_T_commands , pub events : MMAL_VC_STATS_T__bindgen_ty_2 , pub components : MMAL_VC_STATS_T__bindgen_ty_3 , pub worker : MMAL_VC_STATS_T__bindgen_ty_4 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_VC_STATS_T__bindgen_ty_1 { /// < Count of data buffers received
 pub rx : u32 , /// < Count of zero-copy data buffers received
 pub rx_zero_copy : u32 , /// < Empty data buffers (to be filled)
 pub rx_empty : u32 , /// < Gave up partway through
 pub rx_fails : u32 , /// < Count of data buffers sent
 pub tx : u32 , /// < Count of zero-copy data buffers sent
 pub tx_zero_copy : u32 , /// < Count of empty data buffers sent
 pub tx_empty : u32 , /// < Gave up partway through
 pub tx_fails : u32 , /// < Messages sent directly in the control message
 pub tx_short_msg : u32 , /// < Messages received directly in the control message
 pub rx_short_msg : u32 , } # [ test ] fn bindgen_test_layout_MMAL_VC_STATS_T__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_VC_STATS_T__bindgen_ty_1 > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( MMAL_VC_STATS_T__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_VC_STATS_T__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_VC_STATS_T__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_STATS_T__bindgen_ty_1 > ( ) ) ) . rx as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_STATS_T__bindgen_ty_1 ) , "::" , stringify ! ( rx ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_STATS_T__bindgen_ty_1 > ( ) ) ) . rx_zero_copy as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_STATS_T__bindgen_ty_1 ) , "::" , stringify ! ( rx_zero_copy ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_STATS_T__bindgen_ty_1 > ( ) ) ) . rx_empty as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_STATS_T__bindgen_ty_1 ) , "::" , stringify ! ( rx_empty ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_STATS_T__bindgen_ty_1 > ( ) ) ) . rx_fails as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_STATS_T__bindgen_ty_1 ) , "::" , stringify ! ( rx_fails ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_STATS_T__bindgen_ty_1 > ( ) ) ) . tx as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_STATS_T__bindgen_ty_1 ) , "::" , stringify ! ( tx ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_STATS_T__bindgen_ty_1 > ( ) ) ) . tx_zero_copy as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_STATS_T__bindgen_ty_1 ) , "::" , stringify ! ( tx_zero_copy ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_STATS_T__bindgen_ty_1 > ( ) ) ) . tx_empty as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_STATS_T__bindgen_ty_1 ) , "::" , stringify ! ( tx_empty ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_STATS_T__bindgen_ty_1 > ( ) ) ) . tx_fails as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_STATS_T__bindgen_ty_1 ) , "::" , stringify ! ( tx_fails ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_STATS_T__bindgen_ty_1 > ( ) ) ) . tx_short_msg as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_STATS_T__bindgen_ty_1 ) , "::" , stringify ! ( tx_short_msg ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_STATS_T__bindgen_ty_1 > ( ) ) ) . rx_short_msg as * const _ as usize } , 36usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_STATS_T__bindgen_ty_1 ) , "::" , stringify ! ( rx_short_msg ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_VC_STATS_T_service { /// < How many services created
 pub created : u32 , /// < How many destroyed
 pub pending_destroy : u32 , /// < How many destroyed
 pub destroyed : u32 , /// < Failures to create a service
 pub failures : u32 , } # [ test ] fn bindgen_test_layout_MMAL_VC_STATS_T_service ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_VC_STATS_T_service > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( MMAL_VC_STATS_T_service ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_VC_STATS_T_service > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_VC_STATS_T_service ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_STATS_T_service > ( ) ) ) . created as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_STATS_T_service ) , "::" , stringify ! ( created ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_STATS_T_service > ( ) ) ) . pending_destroy as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_STATS_T_service ) , "::" , stringify ! ( pending_destroy ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_STATS_T_service > ( ) ) ) . destroyed as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_STATS_T_service ) , "::" , stringify ! ( destroyed ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_STATS_T_service > ( ) ) ) . failures as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_STATS_T_service ) , "::" , stringify ! ( failures ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_VC_STATS_T_commands { pub bad_messages : u32 , pub executed : u32 , pub failed : u32 , pub replies : u32 , pub reply_fails : u32 , } # [ test ] fn bindgen_test_layout_MMAL_VC_STATS_T_commands ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_VC_STATS_T_commands > ( ) , 20usize , concat ! ( "Size of: " , stringify ! ( MMAL_VC_STATS_T_commands ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_VC_STATS_T_commands > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_VC_STATS_T_commands ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_STATS_T_commands > ( ) ) ) . bad_messages as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_STATS_T_commands ) , "::" , stringify ! ( bad_messages ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_STATS_T_commands > ( ) ) ) . executed as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_STATS_T_commands ) , "::" , stringify ! ( executed ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_STATS_T_commands > ( ) ) ) . failed as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_STATS_T_commands ) , "::" , stringify ! ( failed ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_STATS_T_commands > ( ) ) ) . replies as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_STATS_T_commands ) , "::" , stringify ! ( replies ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_STATS_T_commands > ( ) ) ) . reply_fails as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_STATS_T_commands ) , "::" , stringify ! ( reply_fails ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_VC_STATS_T__bindgen_ty_2 { /// < Count of events sent
 pub tx : u32 , /// < Count of events not fully sent
 pub tx_fails : u32 , } # [ test ] fn bindgen_test_layout_MMAL_VC_STATS_T__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_VC_STATS_T__bindgen_ty_2 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( MMAL_VC_STATS_T__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_VC_STATS_T__bindgen_ty_2 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_VC_STATS_T__bindgen_ty_2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_STATS_T__bindgen_ty_2 > ( ) ) ) . tx as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_STATS_T__bindgen_ty_2 ) , "::" , stringify ! ( tx ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_STATS_T__bindgen_ty_2 > ( ) ) ) . tx_fails as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_STATS_T__bindgen_ty_2 ) , "::" , stringify ! ( tx_fails ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_VC_STATS_T__bindgen_ty_3 { pub created : u32 , pub destroyed : u32 , pub destroying : u32 , pub failed : u32 , pub list_size : u32 , pub component_list : [ MMAL_VC_COMP_STATS_T ; 8usize ] , } # [ test ] fn bindgen_test_layout_MMAL_VC_STATS_T__bindgen_ty_3 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_VC_STATS_T__bindgen_ty_3 > ( ) , 344usize , concat ! ( "Size of: " , stringify ! ( MMAL_VC_STATS_T__bindgen_ty_3 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_VC_STATS_T__bindgen_ty_3 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( MMAL_VC_STATS_T__bindgen_ty_3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_STATS_T__bindgen_ty_3 > ( ) ) ) . created as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_STATS_T__bindgen_ty_3 ) , "::" , stringify ! ( created ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_STATS_T__bindgen_ty_3 > ( ) ) ) . destroyed as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_STATS_T__bindgen_ty_3 ) , "::" , stringify ! ( destroyed ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_STATS_T__bindgen_ty_3 > ( ) ) ) . destroying as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_STATS_T__bindgen_ty_3 ) , "::" , stringify ! ( destroying ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_STATS_T__bindgen_ty_3 > ( ) ) ) . failed as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_STATS_T__bindgen_ty_3 ) , "::" , stringify ! ( failed ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_STATS_T__bindgen_ty_3 > ( ) ) ) . list_size as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_STATS_T__bindgen_ty_3 ) , "::" , stringify ! ( list_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_STATS_T__bindgen_ty_3 > ( ) ) ) . component_list as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_STATS_T__bindgen_ty_3 ) , "::" , stringify ! ( component_list ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_VC_STATS_T__bindgen_ty_4 { pub enqueued_messages : u32 , pub dequeued_messages : u32 , pub max_parameter_set_delay : u32 , pub max_messages_waiting : u32 , } # [ test ] fn bindgen_test_layout_MMAL_VC_STATS_T__bindgen_ty_4 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_VC_STATS_T__bindgen_ty_4 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( MMAL_VC_STATS_T__bindgen_ty_4 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_VC_STATS_T__bindgen_ty_4 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_VC_STATS_T__bindgen_ty_4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_STATS_T__bindgen_ty_4 > ( ) ) ) . enqueued_messages as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_STATS_T__bindgen_ty_4 ) , "::" , stringify ! ( enqueued_messages ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_STATS_T__bindgen_ty_4 > ( ) ) ) . dequeued_messages as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_STATS_T__bindgen_ty_4 ) , "::" , stringify ! ( dequeued_messages ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_STATS_T__bindgen_ty_4 > ( ) ) ) . max_parameter_set_delay as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_STATS_T__bindgen_ty_4 ) , "::" , stringify ! ( max_parameter_set_delay ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_STATS_T__bindgen_ty_4 > ( ) ) ) . max_messages_waiting as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_STATS_T__bindgen_ty_4 ) , "::" , stringify ! ( max_messages_waiting ) ) ) ; } # [ test ] fn bindgen_test_layout_MMAL_VC_STATS_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_VC_STATS_T > ( ) , 448usize , concat ! ( "Size of: " , stringify ! ( MMAL_VC_STATS_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_VC_STATS_T > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( MMAL_VC_STATS_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_STATS_T > ( ) ) ) . buffers as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_STATS_T ) , "::" , stringify ! ( buffers ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_STATS_T > ( ) ) ) . service as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_STATS_T ) , "::" , stringify ! ( service ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_STATS_T > ( ) ) ) . commands as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_STATS_T ) , "::" , stringify ! ( commands ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_STATS_T > ( ) ) ) . events as * const _ as usize } , 76usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_STATS_T ) , "::" , stringify ! ( events ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_STATS_T > ( ) ) ) . components as * const _ as usize } , 88usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_STATS_T ) , "::" , stringify ! ( components ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_STATS_T > ( ) ) ) . worker as * const _ as usize } , 432usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_STATS_T ) , "::" , stringify ! ( worker ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct MMAL_VC_HOST_LOG_T { /// Simple circular buffer of plain text log messages separated by NUL
 pub buffer : [ :: std :: os :: raw :: c_char ; 16384usize ] , /// For VCDBG validation and to help detect buffer overflow
 pub magic : u32 , /// Write offset into buffer
 pub offset : i32 , /// Counter of host messages logged since boot
 pub count : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout_MMAL_VC_HOST_LOG_T ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MMAL_VC_HOST_LOG_T > ( ) , 16396usize , concat ! ( "Size of: " , stringify ! ( MMAL_VC_HOST_LOG_T ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MMAL_VC_HOST_LOG_T > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( MMAL_VC_HOST_LOG_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_HOST_LOG_T > ( ) ) ) . buffer as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_HOST_LOG_T ) , "::" , stringify ! ( buffer ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_HOST_LOG_T > ( ) ) ) . magic as * const _ as usize } , 16384usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_HOST_LOG_T ) , "::" , stringify ! ( magic ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_HOST_LOG_T > ( ) ) ) . offset as * const _ as usize } , 16388usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_HOST_LOG_T ) , "::" , stringify ! ( offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MMAL_VC_HOST_LOG_T > ( ) ) ) . count as * const _ as usize } , 16392usize , concat ! ( "Offset of field: " , stringify ! ( MMAL_VC_HOST_LOG_T ) , "::" , stringify ! ( count ) ) ) ; } impl :: std :: fmt :: Debug for MMAL_VC_HOST_LOG_T { fn fmt ( & self , f : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { write ! ( f , "MMAL_VC_HOST_LOG_T {{ buffer: [{}], magic: {:?}, offset: {:?}, count: {:?} }}" , self . buffer . iter ( ) . enumerate ( ) . map ( | ( i , v ) | format ! ( "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: < String > ( ) , self . magic , self . offset , self . count ) } } pub const MMAL_STATS_RESULT_T_MMAL_STATS_FOUND : MMAL_STATS_RESULT_T = 0 ; pub const MMAL_STATS_RESULT_T_MMAL_STATS_COMPONENT_NOT_FOUND : MMAL_STATS_RESULT_T = 1 ; pub const MMAL_STATS_RESULT_T_MMAL_STATS_PORT_NOT_FOUND : MMAL_STATS_RESULT_T = 2 ; pub const MMAL_STATS_RESULT_T_MMAL_STATS_INVALID : MMAL_STATS_RESULT_T = 2147483647 ; pub type MMAL_STATS_RESULT_T = u32 ; extern "C" { pub fn mmal_vc_init ( ) -> MMAL_STATUS_T::Type ; } extern "C" { pub fn mmal_vc_init_fd ( dev_vchiq_fd : :: std :: os :: raw :: c_int ) -> MMAL_STATUS_T::Type ; } extern "C" { pub fn mmal_vc_deinit ( ) ; } extern "C" { pub fn mmal_vc_use ( ) -> MMAL_STATUS_T::Type ; } extern "C" { pub fn mmal_vc_release ( ) -> MMAL_STATUS_T::Type ; } extern "C" { pub fn mmal_vc_get_version ( major : * mut u32 , minor : * mut u32 , minimum : * mut u32 ) -> MMAL_STATUS_T::Type ; } extern "C" { pub fn mmal_vc_get_stats ( stats : * mut MMAL_VC_STATS_T , reset : :: std :: os :: raw :: c_int ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Return the MMAL core statistics for a given component/port.
///
/// @param stats         Updated with given port statistics
/// @param result        Whether the port/component was found
/// @param name          Filled in with the name of the port
/// @param namelen       Length of name
/// @param component     Which component (indexed from zero)
/// @param port_type     Which type of port
/// @param port          Which port (index from zero)
/// @param reset         Reset the stats.
 pub fn mmal_vc_get_core_stats ( stats : * mut MMAL_CORE_STATISTICS_T , result : * mut MMAL_STATS_RESULT_T , name : * mut :: std :: os :: raw :: c_char , namelen : usize , type_ : MMAL_PORT_TYPE_T , component : :: std :: os :: raw :: c_uint , port : :: std :: os :: raw :: c_uint , dir : MMAL_CORE_STATS_DIR , reset : MMAL_BOOL_T ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Stores an arbitrary text message in a circular buffer inside the MMAL VC server.
/// The purpose of this message is to log high level events from the host in order
/// to diagnose problems that require multiple actions to reproduce. e.g. taking
/// multiple pictures with different settings.
///
/// @param   msg  The message text.
/// @return  MMAL_SUCCESS if the message was logged or MMAL_ENOSYS if the API
/// if not supported.
 pub fn mmal_vc_host_log ( msg : * const :: std :: os :: raw :: c_char ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Consumes memory in the relocatable heap.
///
/// The existing reserved memory is freed first then the new chunk is allocated.
/// If zero is specified for the size then the previously reserved memory
/// is freed and no allocation occurs.
///
/// At startup no memory is reserved.
///
/// @param size    Size of memory to consume in bytes.
/// @param handle  Set to the mem handle for the reserved memory or zero
/// if no memory was allocated.
/// @return        MMAL_SUCCESS if memory was reserved (or size zero requested),
/// MMAL_ENOSPC if the allocation failed or MMAL_ENOSYS if the
/// API is not supported e.g in release mode VC images.
/// @internal
 pub fn mmal_vc_consume_mem ( size : usize , handle : * mut u32 ) -> MMAL_STATUS_T::Type ; } pub const MMAL_VC_COMPACT_MODE_T_MMAL_VC_COMPACT_NONE : MMAL_VC_COMPACT_MODE_T = 0 ; pub const MMAL_VC_COMPACT_MODE_T_MMAL_VC_COMPACT_NORMAL : MMAL_VC_COMPACT_MODE_T = 1 ; pub const MMAL_VC_COMPACT_MODE_T_MMAL_VC_COMPACT_DISCARD : MMAL_VC_COMPACT_MODE_T = 2 ; pub const MMAL_VC_COMPACT_MODE_T_MMAL_VC_COMPACT_AGGRESSIVE : MMAL_VC_COMPACT_MODE_T = 4 ; pub const MMAL_VC_COMPACT_MODE_T_MMAL_VC_COMPACT_SHUFFLE : MMAL_VC_COMPACT_MODE_T = 128 ; pub const MMAL_VC_COMPACT_MODE_T_MMAL_VC_COMPACT_ALL : MMAL_VC_COMPACT_MODE_T = 7 ; pub type MMAL_VC_COMPACT_MODE_T = u32 ; extern "C" { /// Trigger relocatable heap compaction.
/// @internal
 pub fn mmal_vc_compact ( mode : MMAL_VC_COMPACT_MODE_T , duration : * mut u32 ) -> MMAL_STATUS_T::Type ; } extern "C" { /// Trigger LMK action from VC, for diagnostics.
/// @internal
 pub fn mmal_vc_lmk ( alloc_size : u32 ) -> MMAL_STATUS_T::Type ; } /// < There are 'n' named semaphores per 1 actual semaphore
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct VCOS_NAMED_SEMAPHORE_IMPL_T { pub _address : u8 , } pub type __builtin_va_list = [ __va_list_tag ; 1usize ] ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __va_list_tag { pub gp_offset : :: std :: os :: raw :: c_uint , pub fp_offset : :: std :: os :: raw :: c_uint , pub overflow_arg_area : * mut :: std :: os :: raw :: c_void , pub reg_save_area : * mut :: std :: os :: raw :: c_void , } # [ test ] fn bindgen_test_layout___va_list_tag ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __va_list_tag > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( __va_list_tag ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __va_list_tag > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __va_list_tag ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __va_list_tag > ( ) ) ) . gp_offset as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( gp_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __va_list_tag > ( ) ) ) . fp_offset as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( fp_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __va_list_tag > ( ) ) ) . overflow_arg_area as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( overflow_arg_area ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __va_list_tag > ( ) ) ) . reg_save_area as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( reg_save_area ) ) ) ; } /// < Data private to the framework
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_BUFFER_HEADER_PRIVATE_T { pub _address : u8 , } /// < Private member used by the framework
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PORT_PRIVATE_T { pub _address : u8 , } /// < Field reserved for use by the client
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_PORT_USERDATA_T { pub _address : u8 , } /// Pointer to private data of the client
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_COMPONENT_USERDATA_T { pub _address : u8 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MMAL_DRIVER_COMPONENT_T { pub _address : u8 , }
